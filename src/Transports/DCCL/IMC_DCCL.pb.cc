// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IMC_DCCL.proto

#include "IMC_DCCL.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace IMC_DCCL {
PROTOBUF_CONSTEXPR ProfileSample::ProfileSample(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.depth_)*/0
  , /*decltype(_impl_.avg_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ProfileSampleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProfileSampleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProfileSampleDefaultTypeInternal() {}
  union {
    ProfileSample _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProfileSampleDefaultTypeInternal _ProfileSample_default_instance_;
PROTOBUF_CONSTEXPR StationKeeping::StationKeeping(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lat_)*/0
  , /*decltype(_impl_.lon_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.z_units_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.speed_units_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StationKeepingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StationKeepingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StationKeepingDefaultTypeInternal() {}
  union {
    StationKeeping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StationKeepingDefaultTypeInternal _StationKeeping_default_instance_;
PROTOBUF_CONSTEXPR FollowPath::FollowPath(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.points_)*/{}
  , /*decltype(_impl_.timeout_)*/0
  , /*decltype(_impl_.lat_)*/0
  , /*decltype(_impl_.lon_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.z_units_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.speed_units_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct FollowPathDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FollowPathDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FollowPathDefaultTypeInternal() {}
  union {
    FollowPath _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FollowPathDefaultTypeInternal _FollowPath_default_instance_;
PROTOBUF_CONSTEXPR Goto::Goto(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.timeout_)*/0
  , /*decltype(_impl_.lat_)*/0
  , /*decltype(_impl_.lon_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.z_units_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.speed_units_)*/0
  , /*decltype(_impl_.roll_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.yaw_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GotoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GotoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GotoDefaultTypeInternal() {}
  union {
    Goto _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GotoDefaultTypeInternal _Goto_default_instance_;
PROTOBUF_CONSTEXPR ParameterValue::ParameterValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ParameterValueUnion_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ParameterValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ParameterValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ParameterValueDefaultTypeInternal() {}
  union {
    ParameterValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ParameterValueDefaultTypeInternal _ParameterValue_default_instance_;
PROTOBUF_CONSTEXPR PathPoint::PathPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PathPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PathPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PathPointDefaultTypeInternal() {}
  union {
    PathPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PathPointDefaultTypeInternal _PathPoint_default_instance_;
PROTOBUF_CONSTEXPR Maneuver::Maneuver(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ManeuverUnion_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ManeuverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ManeuverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ManeuverDefaultTypeInternal() {}
  union {
    Maneuver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ManeuverDefaultTypeInternal _Maneuver_default_instance_;
PROTOBUF_CONSTEXPR EntityParameter::EntityParameter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.value_)*/nullptr
  , /*decltype(_impl_.name_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EntityParameterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EntityParameterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EntityParameterDefaultTypeInternal() {}
  union {
    EntityParameter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EntityParameterDefaultTypeInternal _EntityParameter_default_instance_;
PROTOBUF_CONSTEXPR SetEntityParameters::SetEntityParameters(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.params_)*/{}
  , /*decltype(_impl_.name_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SetEntityParametersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SetEntityParametersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SetEntityParametersDefaultTypeInternal() {}
  union {
    SetEntityParameters _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SetEntityParametersDefaultTypeInternal _SetEntityParameters_default_instance_;
PROTOBUF_CONSTEXPR ManeuverIDCombined::ManeuverIDCombined(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.maneuver_type_)*/0
  , /*decltype(_impl_.maneuver_number_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ManeuverIDCombinedDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ManeuverIDCombinedDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ManeuverIDCombinedDefaultTypeInternal() {}
  union {
    ManeuverIDCombined _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ManeuverIDCombinedDefaultTypeInternal _ManeuverIDCombined_default_instance_;
PROTOBUF_CONSTEXPR ManeuverID::ManeuverID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.ManeuverIDUnion_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct ManeuverIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ManeuverIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ManeuverIDDefaultTypeInternal() {}
  union {
    ManeuverID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ManeuverIDDefaultTypeInternal _ManeuverID_default_instance_;
PROTOBUF_CONSTEXPR TransitionCondition::TransitionCondition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.TransitionConditionUnion_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct TransitionConditionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransitionConditionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransitionConditionDefaultTypeInternal() {}
  union {
    TransitionCondition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransitionConditionDefaultTypeInternal _TransitionCondition_default_instance_;
PROTOBUF_CONSTEXPR Loiter::Loiter(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.timeout_)*/0
  , /*decltype(_impl_.lat_)*/0
  , /*decltype(_impl_.lon_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.z_units_)*/0
  , /*decltype(_impl_.duration_)*/0
  , /*decltype(_impl_.speed_)*/0
  , /*decltype(_impl_.speed_units_)*/0
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.length_)*/0
  , /*decltype(_impl_.bearing_)*/0
  , /*decltype(_impl_.direction_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LoiterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LoiterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LoiterDefaultTypeInternal() {}
  union {
    Loiter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LoiterDefaultTypeInternal _Loiter_default_instance_;
PROTOBUF_CONSTEXPR PlanManeuverStartActionsUnion::PlanManeuverStartActionsUnion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.PlanManeuverStartActionsUnion__)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PlanManeuverStartActionsUnionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanManeuverStartActionsUnionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanManeuverStartActionsUnionDefaultTypeInternal() {}
  union {
    PlanManeuverStartActionsUnion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanManeuverStartActionsUnionDefaultTypeInternal _PlanManeuverStartActionsUnion_default_instance_;
PROTOBUF_CONSTEXPR PlanManeuver::PlanManeuver(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.start_actions_)*/{}
  , /*decltype(_impl_.maneuver_id_)*/nullptr
  , /*decltype(_impl_.data_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlanManeuverDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanManeuverDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanManeuverDefaultTypeInternal() {}
  union {
    PlanManeuver _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanManeuverDefaultTypeInternal _PlanManeuver_default_instance_;
PROTOBUF_CONSTEXPR PlanTransition::PlanTransition(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.source_man_)*/nullptr
  , /*decltype(_impl_.dest_man_)*/nullptr
  , /*decltype(_impl_.conditions_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlanTransitionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanTransitionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanTransitionDefaultTypeInternal() {}
  union {
    PlanTransition _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanTransitionDefaultTypeInternal _PlanTransition_default_instance_;
PROTOBUF_CONSTEXPR VerticalProfile::VerticalProfile(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.samples_)*/{}
  , /*decltype(_impl_.parameter_)*/0
  , /*decltype(_impl_.numsamples_)*/0
  , /*decltype(_impl_.lat_)*/0
  , /*decltype(_impl_.lon_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct VerticalProfileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VerticalProfileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VerticalProfileDefaultTypeInternal() {}
  union {
    VerticalProfile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VerticalProfileDefaultTypeInternal _VerticalProfile_default_instance_;
PROTOBUF_CONSTEXPR EstimatedState::EstimatedState(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.lat_)*/0
  , /*decltype(_impl_.lon_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.z_)*/0
  , /*decltype(_impl_.phi_)*/0
  , /*decltype(_impl_.theta_)*/0
  , /*decltype(_impl_.psi_)*/0
  , /*decltype(_impl_.u_)*/0
  , /*decltype(_impl_.v_)*/0
  , /*decltype(_impl_.w_)*/0
  , /*decltype(_impl_.vx_)*/0
  , /*decltype(_impl_.vy_)*/0
  , /*decltype(_impl_.vz_)*/0
  , /*decltype(_impl_.p_)*/0
  , /*decltype(_impl_.q_)*/0
  , /*decltype(_impl_.r_)*/0
  , /*decltype(_impl_.depth_)*/0
  , /*decltype(_impl_.alt_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EstimatedStateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EstimatedStateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EstimatedStateDefaultTypeInternal() {}
  union {
    EstimatedState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EstimatedStateDefaultTypeInternal _EstimatedState_default_instance_;
PROTOBUF_CONSTEXPR PlanSpecification::PlanSpecification(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.maneuvers_)*/{}
  , /*decltype(_impl_.transitions_)*/{}
  , /*decltype(_impl_.start_actions_)*/{}
  , /*decltype(_impl_.end_actions_)*/{}
  , /*decltype(_impl_.plan_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.description_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.vnamespace_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.start_man_id_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlanSpecificationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanSpecificationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanSpecificationDefaultTypeInternal() {}
  union {
    PlanSpecification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanSpecificationDefaultTypeInternal _PlanSpecification_default_instance_;
PROTOBUF_CONSTEXPR PlanDB::PlanDB(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.plan_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.arg_)*/nullptr
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.op_)*/0
  , /*decltype(_impl_.request_id_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PlanDBDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanDBDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanDBDefaultTypeInternal() {}
  union {
    PlanDB _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanDBDefaultTypeInternal _PlanDB_default_instance_;
PROTOBUF_CONSTEXPR PlanDBArgUnion::PlanDBArgUnion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.PlanDBArgUnion__)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PlanDBArgUnionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanDBArgUnionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanDBArgUnionDefaultTypeInternal() {}
  union {
    PlanDBArgUnion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanDBArgUnionDefaultTypeInternal _PlanDBArgUnion_default_instance_;
PROTOBUF_CONSTEXPR PlanSpecificationStartActionsUnion::PlanSpecificationStartActionsUnion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.PlanSpecificationStartActionsUnion__)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PlanSpecificationStartActionsUnionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanSpecificationStartActionsUnionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanSpecificationStartActionsUnionDefaultTypeInternal() {}
  union {
    PlanSpecificationStartActionsUnion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanSpecificationStartActionsUnionDefaultTypeInternal _PlanSpecificationStartActionsUnion_default_instance_;
PROTOBUF_CONSTEXPR PlanSpecificationEndActionsUnion::PlanSpecificationEndActionsUnion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.PlanSpecificationEndActionsUnion__)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct PlanSpecificationEndActionsUnionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PlanSpecificationEndActionsUnionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PlanSpecificationEndActionsUnionDefaultTypeInternal() {}
  union {
    PlanSpecificationEndActionsUnion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PlanSpecificationEndActionsUnionDefaultTypeInternal _PlanSpecificationEndActionsUnion_default_instance_;
}  // namespace IMC_DCCL
static ::_pb::Metadata file_level_metadata_IMC_5fDCCL_2eproto[23];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_IMC_5fDCCL_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_IMC_5fDCCL_2eproto = nullptr;

const uint32_t TableStruct_IMC_5fDCCL_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ProfileSample, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ProfileSample, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ProfileSample, _impl_.avg_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.lat_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.lon_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.z_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::StationKeeping, _impl_.speed_units_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.timeout_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.lat_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.lon_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.z_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.speed_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::FollowPath, _impl_.points_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.timeout_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.lat_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.lon_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.z_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.speed_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.roll_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Goto, _impl_.yaw_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ParameterValue, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ParameterValue, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ParameterValue, _impl_.ParameterValueUnion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PathPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PathPoint, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PathPoint, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PathPoint, _impl_.z_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Maneuver, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Maneuver, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Maneuver, _impl_.ManeuverUnion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EntityParameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EntityParameter, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EntityParameter, _impl_.value_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::SetEntityParameters, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::SetEntityParameters, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::SetEntityParameters, _impl_.params_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ManeuverIDCombined, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ManeuverIDCombined, _impl_.maneuver_type_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ManeuverIDCombined, _impl_.maneuver_number_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ManeuverID, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ManeuverID, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::ManeuverID, _impl_.ManeuverIDUnion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::TransitionCondition, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::TransitionCondition, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::TransitionCondition, _impl_.TransitionConditionUnion_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.timeout_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.lat_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.lon_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.z_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.duration_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.speed_units_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.bearing_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::Loiter, _impl_.direction_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuverStartActionsUnion, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuverStartActionsUnion, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuverStartActionsUnion, _impl_.PlanManeuverStartActionsUnion__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuver, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuver, _impl_.maneuver_id_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuver, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanManeuver, _impl_.start_actions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanTransition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanTransition, _impl_.source_man_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanTransition, _impl_.dest_man_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanTransition, _impl_.conditions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::VerticalProfile, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::VerticalProfile, _impl_.parameter_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::VerticalProfile, _impl_.numsamples_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::VerticalProfile, _impl_.samples_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::VerticalProfile, _impl_.lat_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::VerticalProfile, _impl_.lon_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.lat_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.lon_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.z_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.phi_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.theta_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.psi_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.u_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.v_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.w_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.vx_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.vy_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.vz_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.p_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.q_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.r_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.depth_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::EstimatedState, _impl_.alt_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.plan_id_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.description_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.vnamespace_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.start_man_id_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.maneuvers_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.transitions_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.start_actions_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecification, _impl_.end_actions_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _impl_.op_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _impl_.request_id_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _impl_.plan_id_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _impl_.arg_),
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDB, _impl_.info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDBArgUnion, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDBArgUnion, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanDBArgUnion, _impl_.PlanDBArgUnion__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecificationStartActionsUnion, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecificationStartActionsUnion, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecificationStartActionsUnion, _impl_.PlanSpecificationStartActionsUnion__),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecificationEndActionsUnion, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecificationEndActionsUnion, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::IMC_DCCL::PlanSpecificationEndActionsUnion, _impl_.PlanSpecificationEndActionsUnion__),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::IMC_DCCL::ProfileSample)},
  { 8, -1, -1, sizeof(::IMC_DCCL::StationKeeping)},
  { 22, -1, -1, sizeof(::IMC_DCCL::FollowPath)},
  { 36, -1, -1, sizeof(::IMC_DCCL::Goto)},
  { 52, -1, -1, sizeof(::IMC_DCCL::ParameterValue)},
  { 62, -1, -1, sizeof(::IMC_DCCL::PathPoint)},
  { 71, -1, -1, sizeof(::IMC_DCCL::Maneuver)},
  { 82, -1, -1, sizeof(::IMC_DCCL::EntityParameter)},
  { 90, -1, -1, sizeof(::IMC_DCCL::SetEntityParameters)},
  { 98, -1, -1, sizeof(::IMC_DCCL::ManeuverIDCombined)},
  { 106, -1, -1, sizeof(::IMC_DCCL::ManeuverID)},
  { 115, -1, -1, sizeof(::IMC_DCCL::TransitionCondition)},
  { 124, -1, -1, sizeof(::IMC_DCCL::Loiter)},
  { 143, -1, -1, sizeof(::IMC_DCCL::PlanManeuverStartActionsUnion)},
  { 151, -1, -1, sizeof(::IMC_DCCL::PlanManeuver)},
  { 160, -1, -1, sizeof(::IMC_DCCL::PlanTransition)},
  { 169, -1, -1, sizeof(::IMC_DCCL::VerticalProfile)},
  { 180, -1, -1, sizeof(::IMC_DCCL::EstimatedState)},
  { 206, -1, -1, sizeof(::IMC_DCCL::PlanSpecification)},
  { 220, -1, -1, sizeof(::IMC_DCCL::PlanDB)},
  { 232, -1, -1, sizeof(::IMC_DCCL::PlanDBArgUnion)},
  { 240, -1, -1, sizeof(::IMC_DCCL::PlanSpecificationStartActionsUnion)},
  { 248, -1, -1, sizeof(::IMC_DCCL::PlanSpecificationEndActionsUnion)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::IMC_DCCL::_ProfileSample_default_instance_._instance,
  &::IMC_DCCL::_StationKeeping_default_instance_._instance,
  &::IMC_DCCL::_FollowPath_default_instance_._instance,
  &::IMC_DCCL::_Goto_default_instance_._instance,
  &::IMC_DCCL::_ParameterValue_default_instance_._instance,
  &::IMC_DCCL::_PathPoint_default_instance_._instance,
  &::IMC_DCCL::_Maneuver_default_instance_._instance,
  &::IMC_DCCL::_EntityParameter_default_instance_._instance,
  &::IMC_DCCL::_SetEntityParameters_default_instance_._instance,
  &::IMC_DCCL::_ManeuverIDCombined_default_instance_._instance,
  &::IMC_DCCL::_ManeuverID_default_instance_._instance,
  &::IMC_DCCL::_TransitionCondition_default_instance_._instance,
  &::IMC_DCCL::_Loiter_default_instance_._instance,
  &::IMC_DCCL::_PlanManeuverStartActionsUnion_default_instance_._instance,
  &::IMC_DCCL::_PlanManeuver_default_instance_._instance,
  &::IMC_DCCL::_PlanTransition_default_instance_._instance,
  &::IMC_DCCL::_VerticalProfile_default_instance_._instance,
  &::IMC_DCCL::_EstimatedState_default_instance_._instance,
  &::IMC_DCCL::_PlanSpecification_default_instance_._instance,
  &::IMC_DCCL::_PlanDB_default_instance_._instance,
  &::IMC_DCCL::_PlanDBArgUnion_default_instance_._instance,
  &::IMC_DCCL::_PlanSpecificationStartActionsUnion_default_instance_._instance,
  &::IMC_DCCL::_PlanSpecificationEndActionsUnion_default_instance_._instance,
};

const char descriptor_table_protodef_IMC_5fDCCL_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016IMC_DCCL.proto\022\010IMC_DCCL\032\034dccl/option_"
  "extensions.proto\"f\n\rProfileSample\022&\n\005dep"
  "th\030\001 \001(\005B\027\242\?\024 \001)\000\000\000\000\000\000\000\0001\000\000\000\000\000@\237@\022$\n\003avg"
  "\030\002 \001(\002B\027\242\?\024 \002)\000\000\000\000\000@\217\3001\000\000\000\000\000@\217@:\007\242\?\004\020P(\004"
  "\"\321\002\n\016StationKeeping\022$\n\003lat\030\001 \001(\002B\027\242\?\024 \n)"
  "\037\205\353Q\270\036\371\2771\037\205\353Q\270\036\371\?\022$\n\003lon\030\002 \001(\002B\027\242\?\024 \006)z\000"
  "\213\374\372!\t\3001z\000\213\374\372!\t@\022\"\n\001z\030\003 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000"
  "y\3001\000\000\000\000\000\000y@\022!\n\007z_units\030\004 \001(\0162\020.IMC_DCCL."
  "ZUnits\022\'\n\006radius\030\005 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000\360\?1\000"
  "\000\000\000\000j\370@\022\'\n\010duration\030\006 \001(\005B\025\242\?\022)\000\000\000\000\000\000\000\0001"
  "\000\000\000\000\340\377\357@\022&\n\005speed\030\007 \001(\002B\027\242\?\024 \001)\000\000\000\000\000@\237\3001"
  "\000\000\000\000\000@\237@\022)\n\013speed_units\030\010 \001(\0162\024.IMC_DCCL"
  ".SpeedUnits:\007\242\?\004\020P(\004\"\320\002\n\nFollowPath\022&\n\007t"
  "imeout\030\001 \001(\005B\025\242\?\022)\000\000\000\000\000\000\000\0001\000\000\000\000\340\377\357@\022$\n\003l"
  "at\030\002 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\371\2771z\000\213\374\372!\371\?\022$\n\003lon"
  "\030\003 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\t\3001z\000\213\374\372!\t@\022\"\n\001z\030\004 \001"
  "(\002B\027\242\?\024 \001)\000\000\000\000\000\000y\3001\000\000\000\000\000\000y@\022!\n\007z_units\030\005"
  " \001(\0162\020.IMC_DCCL.ZUnits\022&\n\005speed\030\006 \001(\002B\027\242"
  "\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022)\n\013speed_units\030\007 "
  "\001(\0162\024.IMC_DCCL.SpeedUnits\022*\n\006points\030\010 \003("
  "\0132\023.IMC_DCCL.PathPointB\005\242\?\002P\036:\010\242\?\005\020\350\007(\004\""
  "\222\003\n\004Goto\022&\n\007timeout\030\001 \001(\005B\025\242\?\022)\000\000\000\000\000\000\000\0001"
  "\000\000\000\000\340\377\357@\022$\n\003lat\030\002 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\371\2771z\000"
  "\213\374\372!\371\?\022$\n\003lon\030\003 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\t\3001z\000\213\374"
  "\372!\t@\022\"\n\001z\030\004 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000y\3001\000\000\000\000\000\000y@"
  "\022!\n\007z_units\030\005 \001(\0162\020.IMC_DCCL.ZUnits\022&\n\005s"
  "peed\030\006 \001(\002B\027\242\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022)\n\013s"
  "peed_units\030\007 \001(\0162\024.IMC_DCCL.SpeedUnits\022%"
  "\n\004roll\030\010 \001(\002B\027\242\?\024 \003)\000\000\000\000\000\000\360\2771o\022\203\300\312!\031@\022&\n"
  "\005pitch\030\t \001(\002B\027\242\?\024 \003)\000\000\000\000\000\000\360\2771o\022\203\300\312!\031@\022$\n"
  "\003yaw\030\n \001(\002B\027\242\?\024 \003)\000\000\000\000\000\000\360\2771o\022\203\300\312!\031@:\007\242\?\004"
  "\020P(\004\"\255\001\n\016ParameterValue\022/\n\014param_number\030"
  "\001 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000y\3001\000\000\000\000\000\210\303@H\000\022*\n\npara"
  "m_enum\030\002 \001(\0162\024.IMC_DCCL.ParamValueH\000\022\035\n\014"
  "param_string\030\003 \001(\tB\005\242\?\002H\024H\000:\010\242\?\005\020\254\002(\004B\025\n"
  "\023ParameterValueUnion\"\200\001\n\tPathPoint\022\"\n\001x\030"
  "\001 \001(\002B\027\242\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022\"\n\001y\030\002 \001("
  "\002B\027\242\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022\"\n\001z\030\003 \001(\002B\027\242"
  "\?\024 \001)\000\000\000\000\000\000y\3001\000\000\000\000\000\000y@:\007\242\?\004\020P(\004\"\355\001\n\010Mane"
  "uver\022\'\n\rgoto_maneuver\030\001 \001(\0132\016.IMC_DCCL.G"
  "otoH\000\0223\n\023followpath_maneuver\030\002 \001(\0132\024.IMC"
  "_DCCL.FollowPathH\000\022+\n\017loiter_maneuver\030\003 "
  "\001(\0132\020.IMC_DCCL.LoiterH\000\022;\n\027stationkeepin"
  "g_maneuver\030\004 \001(\0132\030.IMC_DCCL.StationKeepi"
  "ngH\000:\010\242\?\005\020\254\002(\004B\017\n\rManeuverUnion\"j\n\017Entit"
  "yParameter\022%\n\004name\030\001 \001(\0162\027.IMC_DCCL.Para"
  "meterName\022\'\n\005value\030\002 \001(\0132\030.IMC_DCCL.Para"
  "meterValue:\007\242\?\004\020\024(\004\"t\n\023SetEntityParamete"
  "rs\022\"\n\004name\030\001 \001(\0162\024.IMC_DCCL.EntityName\0220"
  "\n\006params\030\002 \003(\0132\031.IMC_DCCL.EntityParamete"
  "rB\005\242\?\002P\n:\007\242\?\004\020((\004\"|\n\022ManeuverIDCombined\022"
  "-\n\rmaneuver_type\030\001 \001(\0162\026.IMC_DCCL.Maneuv"
  "erType\022.\n\017maneuver_number\030\002 \001(\005B\025\242\?\022)\000\000\000"
  "\000\000\000\000\0001\000\000\000\000\000\000I@:\007\242\?\004\020\036(\004\"y\n\nManeuverID\0223\n"
  "\013id_combined\030\001 \001(\0132\034.IMC_DCCL.ManeuverID"
  "CombinedH\000\022\032\n\tid_string\030\002 \001(\tB\005\242\?\002H\024H\000:\007"
  "\242\?\004\020\036(\004B\021\n\017ManeuverIDUnion\"\232\001\n\023Transitio"
  "nCondition\022;\n\016condition_enum\030\001 \001(\0162!.IMC"
  "_DCCL.TransitionConditionEnumH\000\022!\n\020condi"
  "tion_string\030\002 \001(\tB\005\242\?\002H\024H\000:\007\242\?\004\020\036(\004B\032\n\030T"
  "ransitionConditionUnion\"\367\005\n\006Loiter\022&\n\007ti"
  "meout\030\001 \001(\005B\025\242\?\022)\000\000\000\000\000\000\000\0001\000\000\000\000\340\377\357@\022$\n\003la"
  "t\030\002 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\371\2771z\000\213\374\372!\371\?\022$\n\003lon\030"
  "\003 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\t\3001z\000\213\374\372!\t@\022\"\n\001z\030\004 \001("
  "\002B\027\242\?\024 \001)\000\000\000\000\000\000y\3001\000\000\000\000\000\000y@\022!\n\007z_units\030\005 "
  "\001(\0162\020.IMC_DCCL.ZUnits\022\'\n\010duration\030\006 \001(\005B"
  "\025\242\?\022)\000\000\000\000\000\000\000\0001\000\000\000\000\000\030\305@\022&\n\005speed\030\007 \001(\002B\027\242"
  "\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022)\n\013speed_units\030\010 "
  "\001(\0162\024.IMC_DCCL.SpeedUnits\022-\n\004type\030\t \001(\0162"
  "\037.IMC_DCCL.Loiter.LoiterTypeEnum\022\'\n\006radi"
  "us\030\n \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000\360\?1\000\000\000\000\000j\370@\022\'\n\006len"
  "gth\030\013 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000\360\?1\000\000\000\000\000j\370@\022(\n\007be"
  "aring\030\014 \001(\002B\027\242\?\024 \003)\000\000\000\000\000\000\000\0001o\022\203\300\312!\031@\0221\n\t"
  "direction\030\r \001(\0162\036.IMC_DCCL.Loiter.Direct"
  "ionEnum\"o\n\016LoiterTypeEnum\022\016\n\nLT_DEFAULT\020"
  "\000\022\017\n\013LT_CIRCULAR\020\001\022\020\n\014LT_RACETRACK\020\002\022\014\n\010"
  "LT_EIGHT\020\003\022\014\n\010LT_HOVER\020\004\022\016\n\nLT_UNKNOWN\020\005"
  "\"]\n\rDirectionEnum\022\013\n\007LD_VDEP\020\000\022\r\n\tLD_CLO"
  "CKW\020\001\022\016\n\nLD_CCLOCKW\020\002\022\020\n\014LD_IWINDCURR\020\003\022"
  "\016\n\nLD_UNKNOWN\020\004:\010\242\?\005\020\350\007(\004\"y\n\035PlanManeuve"
  "rStartActionsUnion\022+\n\002ep\030\001 \001(\0132\035.IMC_DCC"
  "L.SetEntityParametersH\000:\t\242\?\006\020\200\3520(\004B \n\036Pl"
  "anManeuverStartActionsUnion_\"\254\001\n\014PlanMan"
  "euver\022)\n\013maneuver_id\030\001 \001(\0132\024.IMC_DCCL.Ma"
  "neuverID\022 \n\004data\030\002 \001(\0132\022.IMC_DCCL.Maneuv"
  "er\022E\n\rstart_actions\030\003 \003(\0132\'.IMC_DCCL.Pla"
  "nManeuverStartActionsUnionB\005\242\?\002P\017:\010\242\?\005\020\220"
  "\003(\004\"\237\001\n\016PlanTransition\022(\n\nsource_man\030\001 \001"
  "(\0132\024.IMC_DCCL.ManeuverID\022&\n\010dest_man\030\002 \001"
  "(\0132\024.IMC_DCCL.ManeuverID\0221\n\nconditions\030\003"
  " \001(\0132\035.IMC_DCCL.TransitionCondition:\010\242\?\005"
  "\020\220\003(\004\"\233\003\n\017VerticalProfile\022:\n\tparameter\030\001"
  " \001(\0162\'.IMC_DCCL.VerticalProfile.Paramete"
  "rEnum\022+\n\nnumsamples\030\002 \001(\005B\027\242\?\024 \001)\000\000\000\000\000\000\000"
  "\0001\000\000\000\000\000\340o@\022/\n\007samples\030\003 \003(\0132\027.IMC_DCCL.P"
  "rofileSampleB\005\242\?\002PF\022$\n\003lat\030\004 \001(\002B\027\242\?\024 \006)"
  "z\000\213\374\372!\371\2771z\000\213\374\372!\371\?\022$\n\003lon\030\005 \001(\002B\027\242\?\024 \006)z\000"
  "\213\374\372!\t\3001z\000\213\374\372!\t@\"\226\001\n\rParameterEnum\022\024\n\020PRO"
  "F_TEMPERATURE\020\000\022\021\n\rPROF_SALINITY\020\001\022\025\n\021PR"
  "OF_CONDUCTIVITY\020\002\022\013\n\007PROF_PH\020\003\022\016\n\nPROF_R"
  "EDOX\020\004\022\024\n\020PROF_CHLOROPHYLL\020\005\022\022\n\016PROF_TUR"
  "BIDITY\020\006:\t\242\?\006\010o\020P(\004\"\206\006\n\016EstimatedState\022$"
  "\n\003lat\030\001 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\371\2771z\000\213\374\372!\371\?\022$\n\003"
  "lon\030\002 \001(\002B\027\242\?\024 \006)z\000\213\374\372!\t\3001z\000\213\374\372!\t@\022\'\n\006he"
  "ight\030\003 \001(\002B\027\242\?\024 \001)\000\000\000\000\000@\217\3001\000\000\000\000\000X\273@\022\"\n\001x"
  "\030\004 \001(\002B\027\242\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022\"\n\001y\030\005 \001"
  "(\002B\027\242\?\024 \001)\000\000\000\000\000@\237\3001\000\000\000\000\000@\237@\022\"\n\001z\030\006 \001(\002B\027"
  "\242\?\024 \001)\000\000\000\000\000\000y\3001\000\000\000\000\000\000y@\022$\n\003phi\030\007 \001(\002B\027\242\?"
  "\024 \003)T\343\245\233\304 \t\3001T\343\245\233\304 \t@\022&\n\005theta\030\010 \001(\002B\027\242\?"
  "\024 \003)\037\205\353Q\270\036\371\2771\037\205\353Q\270\036\371\?\022$\n\003psi\030\t \001(\002B\027\242\?\024 "
  "\003)T\343\245\233\304 \t\3001T\343\245\233\304 \t@\022\"\n\001u\030\n \001(\002B\027\242\?\024 \001)\000\000"
  "\000\000\000\000$\3001\000\000\000\000\000\000$@\022\"\n\001v\030\013 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000"
  "$\3001\000\000\000\000\000\000$@\022\"\n\001w\030\014 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000$\3001\000"
  "\000\000\000\000\000$@\022#\n\002vx\030\r \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000$\3001\000\000\000\000"
  "\000\000$@\022#\n\002vy\030\016 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000$\3001\000\000\000\000\000\000$"
  "@\022#\n\002vz\030\017 \001(\002B\027\242\?\024 \001)\000\000\000\000\000\000$\3001\000\000\000\000\000\000$@\022\""
  "\n\001p\030\020 \001(\002B\027\242\?\024 \003)T\343\245\233\304 \t\3001T\343\245\233\304 \t@\022\"\n\001q\030"
  "\021 \001(\002B\027\242\?\024 \003)T\343\245\233\304 \t\3001T\343\245\233\304 \t@\022\"\n\001r\030\022 \001("
  "\002B\027\242\?\024 \003)T\343\245\233\304 \t\3001T\343\245\233\304 \t@\022&\n\005depth\030\023 \001("
  "\002B\027\242\?\024 \002)\000\000\000\000\000\000\360\2771\000\000\000\000\000\000y@\022$\n\003alt\030\024 \001(\002B"
  "\027\242\?\024 \002)\000\000\000\000\000\000\360\2771\000\000\000\000\000\210\263@:\n\242\?\007\010\336\002\020P(\004\"\230\003\n"
  "\021PlanSpecification\022\026\n\007plan_id\030\001 \001(\tB\005\242\?\002"
  "H\024\022\032\n\013description\030\002 \001(\tB\005\242\?\002H\002\022\031\n\nvnames"
  "pace\030\003 \001(\tB\005\242\?\002H\002\022*\n\014start_man_id\030\004 \001(\0132"
  "\024.IMC_DCCL.ManeuverID\0220\n\tmaneuvers\030\005 \003(\013"
  "2\026.IMC_DCCL.PlanManeuverB\005\242\?\002P\036\0224\n\013trans"
  "itions\030\006 \003(\0132\030.IMC_DCCL.PlanTransitionB\005"
  "\242\?\002P\036\022J\n\rstart_actions\030\007 \003(\0132,.IMC_DCCL."
  "PlanSpecificationStartActionsUnionB\005\242\?\002P"
  "\007\022F\n\013end_actions\030\010 \003(\0132*.IMC_DCCL.PlanSp"
  "ecificationEndActionsUnionB\005\242\?\002P\007:\014\242\?\t\010\247"
  "\004\020\200\3520(\004\"\327\003\n\006PlanDB\022\'\n\004type\030\001 \001(\0162\031.IMC_D"
  "CCL.PlanDB.TypeEnum\022*\n\002op\030\002 \001(\0162\036.IMC_DC"
  "CL.PlanDB.OperationEnum\022+\n\nrequest_id\030\003 "
  "\001(\005B\027\242\?\024 \001)\000\000\000\000\000\000\000\0001\000\000\000\000\000\340o@\022\026\n\007plan_id\030"
  "\004 \001(\tB\005\242\?\002H\024\022%\n\003arg\030\005 \001(\0132\030.IMC_DCCL.Pla"
  "nDBArgUnion\022\023\n\004info\030\006 \001(\tB\005\242\?\002H(\"R\n\010Type"
  "Enum\022\017\n\013DBT_REQUEST\020\000\022\017\n\013DBT_SUCCESS\020\001\022\017"
  "\n\013DBT_FAILURE\020\002\022\023\n\017DBT_IN_PROGRESS\020\003\"\224\001\n"
  "\rOperationEnum\022\014\n\010DBOP_SET\020\000\022\014\n\010DBOP_DEL"
  "\020\001\022\014\n\010DBOP_GET\020\002\022\021\n\rDBOP_GET_INFO\020\003\022\016\n\nD"
  "BOP_CLEAR\020\004\022\022\n\016DBOP_GET_STATE\020\005\022\023\n\017DBOP_"
  "GET_DSTATE\020\006\022\r\n\tDBOP_BOOT\020\007:\014\242\?\t\010\254\004\020\200\3520("
  "\004\"]\n\016PlanDBArgUnion\022-\n\006ps_arg\030\001 \001(\0132\033.IM"
  "C_DCCL.PlanSpecificationH\000:\t\242\?\006\020\200\3520(\004B\021\n"
  "\017PlanDBArgUnion_\"\203\001\n\"PlanSpecificationSt"
  "artActionsUnion\022+\n\002ep\030\001 \001(\0132\035.IMC_DCCL.S"
  "etEntityParametersH\000:\t\242\?\006\020\200\3520(\004B%\n#PlanS"
  "pecificationStartActionsUnion_\"\177\n PlanSp"
  "ecificationEndActionsUnion\022+\n\002ep\030\001 \001(\0132\035"
  ".IMC_DCCL.SetEntityParametersH\000:\t\242\?\006\020\200\3520"
  "(\004B#\n!PlanSpecificationEndActionsUnion_*"
  "N\n\006ZUnits\022\n\n\006Z_NONE\020\000\022\013\n\007Z_DEPTH\020\001\022\016\n\nZ_"
  "ALTITUDE\020\002\022\014\n\010Z_HEIGHT\020\003\022\r\n\tZ_UNKNOWN\020\004*"
  "]\n\nSpeedUnits\022\024\n\020SUNITS_METERS_PS\020\000\022\016\n\nS"
  "UNITS_RPM\020\001\022\025\n\021SUNITS_PERCENTAGE\020\002\022\022\n\016SU"
  "NITS_UNKNOWN\020\003*X\n\014ManeuverType\022\010\n\004GOTO\020\000"
  "\022\n\n\006LOITER\020\001\022\016\n\nFOLLOWPATH\020\002\022\022\n\016STATIONK"
  "EEPING\020\003\022\016\n\nMT_UNKNOWN\020\004*;\n\nParamValue\022\010"
  "\n\004TRUE\020\000\022\t\n\005FALSE\020\001\022\010\n\004BOTH\020\002\022\016\n\nPV_UNKN"
  "OWN\020\003*=\n\027TransitionConditionEnum\022\022\n\016MANE"
  "UVERISDONE\020\000\022\016\n\nTC_UNKNOWN\020\001*\241\006\n\rParamet"
  "erName\022\n\n\006ACTIVE\020\000\022\025\n\021ARDUPILOT_TRACKER\020"
  "\001\022 \n\034BATHYMETRY_CHANNEL_AVAILABLE\020\002\022\036\n\032B"
  "OTTOM_TRACK_MINIMUM_DEPTH\020\003\022\r\n\tDATA_BITS"
  "\020\004\022\016\n\nFLIR_DUO_R\020\005\022\024\n\020FORMATION_FLIGHT\020\006"
  "\022\027\n\023FORMATION_POSITIONS\020\007\022\035\n\031FORMATION_R"
  "EFERENCE_FRAME\020\010\022\r\n\tFREQUENCY\020\t\022\032\n\026HIGH_"
  "FREQUENCY_CHANNEL\020\n\022\033\n\027HIGH_FREQUENCY_CH"
  "ANNELS\020\013\022\030\n\024HIGH_FREQUENCY_RANGE\020\014\022$\n LO"
  "W_FREQUENCY_BATHYMETRY_CHANNEL\020\r\022\031\n\025LOW_"
  "FREQUENCY_CHANNEL\020\016\022\032\n\026LOW_FREQUENCY_CHA"
  "NNELS\020\017\022\027\n\023LOW_FREQUENCY_RANGE\020\020\022\022\n\016ONBO"
  "ARD_CAMERA\020\021\022\033\n\027OPTIMIZE_FOR_THIS_SPEED\020"
  "\022\022 \n\034PERIODICITY_OF_DATA_SAMPLING\020\023\022\020\n\014P"
  "ROFILE_MODE\020\024\022\t\n\005RANGE\020\025\022\024\n\020RANGE_MULTIP"
  "LIER\020\026\022\030\n\024SAMPLE_TIME_DURATION\020\027\022\020\n\014SCAL"
  "E_FACTOR\020\030\022\020\n\014SECTOR_WIDTH\020\031\022\024\n\020SHUTTER_"
  "VALUE_MS\020\032\022\r\n\tSTEP_SIZE\020\033\022\023\n\017STROBE_DELA"
  "Y_US\020\034\022\026\n\022THRUSTER_ALWAYS_ON\020\035\022\024\n\020TRANSI"
  "TION_TO_FW\020\036\022\024\n\020TRANSITION_TO_MC\020\037\022\022\n\016US"
  "E_CONTROLLER\020 \022\020\n\014VEHICLE_LIST\020!*\306\003\n\nEnt"
  "ityName\022\n\n\006CAMERA\020\000\022\010\n\004ADCP\020\001\022\r\n\tAUTOPIL"
  "OT\020\002\022\022\n\016ACOUSTIC_MODEM\020\003\022\007\n\003CTD\020\004\022\024\n\020DIS"
  "SOLVED_OXYGEN\020\005\022\020\n\014FLUOROMETERS\020\006\022\031\n\025FOR"
  "MATION_COORDINATOR\020\007\022\026\n\022HEADING_CONTROLL"
  "ER\020\010\022\022\n\016HEIGHT_CONTROL\020\t\022\007\n\003LBL\020\n\022\036\n\032MOT"
  "OR_CONTROLLER_CHANNEL_0\020\013\022\036\n\032MOTOR_CONTR"
  "OLLER_CHANNEL_1\020\014\022\r\n\tMULTIBEAM\020\r\022\020\n\014PATH"
  "_CONTROL\020\016\022\027\n\023PATH_CONTROL_LEADER\020\017\022\017\n\013P"
  "ENCIL_BEAM\020\020\022\021\n\rPHOTO_TRIGGER\020\021\022\n\n\006RANGE"
  "R\020\022\022\022\n\016REMOTE_CONTROL\020\023\022\024\n\020REMOTE_OPERAT"
  "ION\020\024\022\014\n\010SIDESCAN\020\025\022\r\n\tSLAVE_CPU\020\026\022\r\n\tUA"
  "VCAMERA\020\027b\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_IMC_5fDCCL_2eproto_deps[1] = {
  &::descriptor_table_dccl_2foption_5fextensions_2eproto,
};
static ::_pbi::once_flag descriptor_table_IMC_5fDCCL_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_IMC_5fDCCL_2eproto = {
    false, false, 7737, descriptor_table_protodef_IMC_5fDCCL_2eproto,
    "IMC_DCCL.proto",
    &descriptor_table_IMC_5fDCCL_2eproto_once, descriptor_table_IMC_5fDCCL_2eproto_deps, 1, 23,
    schemas, file_default_instances, TableStruct_IMC_5fDCCL_2eproto::offsets,
    file_level_metadata_IMC_5fDCCL_2eproto, file_level_enum_descriptors_IMC_5fDCCL_2eproto,
    file_level_service_descriptors_IMC_5fDCCL_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_IMC_5fDCCL_2eproto_getter() {
  return &descriptor_table_IMC_5fDCCL_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_IMC_5fDCCL_2eproto(&descriptor_table_IMC_5fDCCL_2eproto);
namespace IMC_DCCL {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Loiter_LoiterTypeEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[0];
}
bool Loiter_LoiterTypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Loiter_LoiterTypeEnum Loiter::LT_DEFAULT;
constexpr Loiter_LoiterTypeEnum Loiter::LT_CIRCULAR;
constexpr Loiter_LoiterTypeEnum Loiter::LT_RACETRACK;
constexpr Loiter_LoiterTypeEnum Loiter::LT_EIGHT;
constexpr Loiter_LoiterTypeEnum Loiter::LT_HOVER;
constexpr Loiter_LoiterTypeEnum Loiter::LT_UNKNOWN;
constexpr Loiter_LoiterTypeEnum Loiter::LoiterTypeEnum_MIN;
constexpr Loiter_LoiterTypeEnum Loiter::LoiterTypeEnum_MAX;
constexpr int Loiter::LoiterTypeEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Loiter_DirectionEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[1];
}
bool Loiter_DirectionEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Loiter_DirectionEnum Loiter::LD_VDEP;
constexpr Loiter_DirectionEnum Loiter::LD_CLOCKW;
constexpr Loiter_DirectionEnum Loiter::LD_CCLOCKW;
constexpr Loiter_DirectionEnum Loiter::LD_IWINDCURR;
constexpr Loiter_DirectionEnum Loiter::LD_UNKNOWN;
constexpr Loiter_DirectionEnum Loiter::DirectionEnum_MIN;
constexpr Loiter_DirectionEnum Loiter::DirectionEnum_MAX;
constexpr int Loiter::DirectionEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VerticalProfile_ParameterEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[2];
}
bool VerticalProfile_ParameterEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_TEMPERATURE;
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_SALINITY;
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_CONDUCTIVITY;
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_PH;
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_REDOX;
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_CHLOROPHYLL;
constexpr VerticalProfile_ParameterEnum VerticalProfile::PROF_TURBIDITY;
constexpr VerticalProfile_ParameterEnum VerticalProfile::ParameterEnum_MIN;
constexpr VerticalProfile_ParameterEnum VerticalProfile::ParameterEnum_MAX;
constexpr int VerticalProfile::ParameterEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlanDB_TypeEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[3];
}
bool PlanDB_TypeEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PlanDB_TypeEnum PlanDB::DBT_REQUEST;
constexpr PlanDB_TypeEnum PlanDB::DBT_SUCCESS;
constexpr PlanDB_TypeEnum PlanDB::DBT_FAILURE;
constexpr PlanDB_TypeEnum PlanDB::DBT_IN_PROGRESS;
constexpr PlanDB_TypeEnum PlanDB::TypeEnum_MIN;
constexpr PlanDB_TypeEnum PlanDB::TypeEnum_MAX;
constexpr int PlanDB::TypeEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlanDB_OperationEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[4];
}
bool PlanDB_OperationEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr PlanDB_OperationEnum PlanDB::DBOP_SET;
constexpr PlanDB_OperationEnum PlanDB::DBOP_DEL;
constexpr PlanDB_OperationEnum PlanDB::DBOP_GET;
constexpr PlanDB_OperationEnum PlanDB::DBOP_GET_INFO;
constexpr PlanDB_OperationEnum PlanDB::DBOP_CLEAR;
constexpr PlanDB_OperationEnum PlanDB::DBOP_GET_STATE;
constexpr PlanDB_OperationEnum PlanDB::DBOP_GET_DSTATE;
constexpr PlanDB_OperationEnum PlanDB::DBOP_BOOT;
constexpr PlanDB_OperationEnum PlanDB::OperationEnum_MIN;
constexpr PlanDB_OperationEnum PlanDB::OperationEnum_MAX;
constexpr int PlanDB::OperationEnum_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ZUnits_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[5];
}
bool ZUnits_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeedUnits_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[6];
}
bool SpeedUnits_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ManeuverType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[7];
}
bool ManeuverType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParamValue_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[8];
}
bool ParamValue_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransitionConditionEnum_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[9];
}
bool TransitionConditionEnum_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParameterName_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[10];
}
bool ParameterName_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityName_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_IMC_5fDCCL_2eproto);
  return file_level_enum_descriptors_IMC_5fDCCL_2eproto[11];
}
bool EntityName_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class ProfileSample::_Internal {
 public:
};

ProfileSample::ProfileSample(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.ProfileSample)
}
ProfileSample::ProfileSample(const ProfileSample& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProfileSample* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.depth_){}
    , decltype(_impl_.avg_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.depth_, &from._impl_.depth_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.avg_) -
    reinterpret_cast<char*>(&_impl_.depth_)) + sizeof(_impl_.avg_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.ProfileSample)
}

inline void ProfileSample::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.depth_){0}
    , decltype(_impl_.avg_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ProfileSample::~ProfileSample() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.ProfileSample)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProfileSample::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProfileSample::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProfileSample::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.ProfileSample)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.depth_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.avg_) -
      reinterpret_cast<char*>(&_impl_.depth_)) + sizeof(_impl_.avg_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProfileSample::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 depth = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float avg = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.avg_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProfileSample::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.ProfileSample)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 depth = 1 [(.dccl.field) = {
  if (this->_internal_depth() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_depth(), target);
  }

  // float avg = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_avg = this->_internal_avg();
  uint32_t raw_avg;
  memcpy(&raw_avg, &tmp_avg, sizeof(tmp_avg));
  if (raw_avg != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_avg(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.ProfileSample)
  return target;
}

size_t ProfileSample::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.ProfileSample)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 depth = 1 [(.dccl.field) = {
  if (this->_internal_depth() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_depth());
  }

  // float avg = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_avg = this->_internal_avg();
  uint32_t raw_avg;
  memcpy(&raw_avg, &tmp_avg, sizeof(tmp_avg));
  if (raw_avg != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProfileSample::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProfileSample::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProfileSample::GetClassData() const { return &_class_data_; }


void ProfileSample::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProfileSample*>(&to_msg);
  auto& from = static_cast<const ProfileSample&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.ProfileSample)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_depth() != 0) {
    _this->_internal_set_depth(from._internal_depth());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_avg = from._internal_avg();
  uint32_t raw_avg;
  memcpy(&raw_avg, &tmp_avg, sizeof(tmp_avg));
  if (raw_avg != 0) {
    _this->_internal_set_avg(from._internal_avg());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProfileSample::CopyFrom(const ProfileSample& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.ProfileSample)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProfileSample::IsInitialized() const {
  return true;
}

void ProfileSample::InternalSwap(ProfileSample* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProfileSample, _impl_.avg_)
      + sizeof(ProfileSample::_impl_.avg_)
      - PROTOBUF_FIELD_OFFSET(ProfileSample, _impl_.depth_)>(
          reinterpret_cast<char*>(&_impl_.depth_),
          reinterpret_cast<char*>(&other->_impl_.depth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProfileSample::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[0]);
}

// ===================================================================

class StationKeeping::_Internal {
 public:
};

StationKeeping::StationKeeping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.StationKeeping)
}
StationKeeping::StationKeeping(const StationKeeping& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StationKeeping* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lat_){}
    , decltype(_impl_.lon_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.z_units_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.speed_units_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lat_, &from._impl_.lat_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_units_) -
    reinterpret_cast<char*>(&_impl_.lat_)) + sizeof(_impl_.speed_units_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.StationKeeping)
}

inline void StationKeeping::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lat_){0}
    , decltype(_impl_.lon_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.z_units_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.speed_units_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StationKeeping::~StationKeeping() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.StationKeeping)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StationKeeping::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void StationKeeping::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StationKeeping::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.StationKeeping)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.lat_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.speed_units_) -
      reinterpret_cast<char*>(&_impl_.lat_)) + sizeof(_impl_.speed_units_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StationKeeping::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float lat = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lon = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ZUnits z_units = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_z_units(static_cast<::IMC_DCCL::ZUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // float radius = 5 [(.dccl.field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // int32 duration = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float speed = 7 [(.dccl.field) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.SpeedUnits speed_units = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_speed_units(static_cast<::IMC_DCCL::SpeedUnits>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StationKeeping::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.StationKeeping)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float lat = 1 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_lat(), target);
  }

  // float lon = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_lon(), target);
  }

  // float z = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // .IMC_DCCL.ZUnits z_units = 4;
  if (this->_internal_z_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_z_units(), target);
  }

  // float radius = 5 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_radius(), target);
  }

  // int32 duration = 6 [(.dccl.field) = {
  if (this->_internal_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_duration(), target);
  }

  // float speed = 7 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_speed(), target);
  }

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  if (this->_internal_speed_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_speed_units(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.StationKeeping)
  return target;
}

size_t StationKeeping::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.StationKeeping)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float lat = 1 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 1 + 4;
  }

  // float lon = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 1 + 4;
  }

  // float z = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.ZUnits z_units = 4;
  if (this->_internal_z_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_z_units());
  }

  // float radius = 5 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 4;
  }

  // int32 duration = 6 [(.dccl.field) = {
  if (this->_internal_duration() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_duration());
  }

  // float speed = 7 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  if (this->_internal_speed_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_speed_units());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StationKeeping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StationKeeping::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StationKeeping::GetClassData() const { return &_class_data_; }


void StationKeeping::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StationKeeping*>(&to_msg);
  auto& from = static_cast<const StationKeeping&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.StationKeeping)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = from._internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = from._internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  if (from._internal_z_units() != 0) {
    _this->_internal_set_z_units(from._internal_z_units());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  if (from._internal_duration() != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_speed_units() != 0) {
    _this->_internal_set_speed_units(from._internal_speed_units());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StationKeeping::CopyFrom(const StationKeeping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.StationKeeping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StationKeeping::IsInitialized() const {
  return true;
}

void StationKeeping::InternalSwap(StationKeeping* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StationKeeping, _impl_.speed_units_)
      + sizeof(StationKeeping::_impl_.speed_units_)
      - PROTOBUF_FIELD_OFFSET(StationKeeping, _impl_.lat_)>(
          reinterpret_cast<char*>(&_impl_.lat_),
          reinterpret_cast<char*>(&other->_impl_.lat_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StationKeeping::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[1]);
}

// ===================================================================

class FollowPath::_Internal {
 public:
};

FollowPath::FollowPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.FollowPath)
}
FollowPath::FollowPath(const FollowPath& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  FollowPath* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){from._impl_.points_}
    , decltype(_impl_.timeout_){}
    , decltype(_impl_.lat_){}
    , decltype(_impl_.lon_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.z_units_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.speed_units_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timeout_, &from._impl_.timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_units_) -
    reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.speed_units_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.FollowPath)
}

inline void FollowPath::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.points_){arena}
    , decltype(_impl_.timeout_){0}
    , decltype(_impl_.lat_){0}
    , decltype(_impl_.lon_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.z_units_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.speed_units_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

FollowPath::~FollowPath() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.FollowPath)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FollowPath::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.points_.~RepeatedPtrField();
}

void FollowPath::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void FollowPath::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.FollowPath)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.points_.Clear();
  ::memset(&_impl_.timeout_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.speed_units_) -
      reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.speed_units_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* FollowPath::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 timeout = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float lat = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lon = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 4 [(.dccl.field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ZUnits z_units = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_z_units(static_cast<::IMC_DCCL::ZUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // float speed = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.SpeedUnits speed_units = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_speed_units(static_cast<::IMC_DCCL::SpeedUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_points(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FollowPath::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.FollowPath)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 timeout = 1 [(.dccl.field) = {
  if (this->_internal_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout(), target);
  }

  // float lat = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_lat(), target);
  }

  // float lon = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_lon(), target);
  }

  // float z = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_z(), target);
  }

  // .IMC_DCCL.ZUnits z_units = 5;
  if (this->_internal_z_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_z_units(), target);
  }

  // float speed = 6 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_speed(), target);
  }

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  if (this->_internal_speed_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_speed_units(), target);
  }

  // repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_points_size()); i < n; i++) {
    const auto& repfield = this->_internal_points(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.FollowPath)
  return target;
}

size_t FollowPath::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.FollowPath)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
  total_size += 1UL * this->_internal_points_size();
  for (const auto& msg : this->_impl_.points_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // int32 timeout = 1 [(.dccl.field) = {
  if (this->_internal_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout());
  }

  // float lat = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 1 + 4;
  }

  // float lon = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 1 + 4;
  }

  // float z = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.ZUnits z_units = 5;
  if (this->_internal_z_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_z_units());
  }

  // float speed = 6 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  if (this->_internal_speed_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_speed_units());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData FollowPath::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    FollowPath::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*FollowPath::GetClassData() const { return &_class_data_; }


void FollowPath::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<FollowPath*>(&to_msg);
  auto& from = static_cast<const FollowPath&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.FollowPath)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.points_.MergeFrom(from._impl_.points_);
  if (from._internal_timeout() != 0) {
    _this->_internal_set_timeout(from._internal_timeout());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = from._internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = from._internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  if (from._internal_z_units() != 0) {
    _this->_internal_set_z_units(from._internal_z_units());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_speed_units() != 0) {
    _this->_internal_set_speed_units(from._internal_speed_units());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void FollowPath::CopyFrom(const FollowPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.FollowPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FollowPath::IsInitialized() const {
  return true;
}

void FollowPath::InternalSwap(FollowPath* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.points_.InternalSwap(&other->_impl_.points_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FollowPath, _impl_.speed_units_)
      + sizeof(FollowPath::_impl_.speed_units_)
      - PROTOBUF_FIELD_OFFSET(FollowPath, _impl_.timeout_)>(
          reinterpret_cast<char*>(&_impl_.timeout_),
          reinterpret_cast<char*>(&other->_impl_.timeout_));
}

::PROTOBUF_NAMESPACE_ID::Metadata FollowPath::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[2]);
}

// ===================================================================

class Goto::_Internal {
 public:
};

Goto::Goto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.Goto)
}
Goto::Goto(const Goto& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Goto* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.timeout_){}
    , decltype(_impl_.lat_){}
    , decltype(_impl_.lon_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.z_units_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.speed_units_){}
    , decltype(_impl_.roll_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.yaw_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timeout_, &from._impl_.timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.yaw_) -
    reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.yaw_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.Goto)
}

inline void Goto::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.timeout_){0}
    , decltype(_impl_.lat_){0}
    , decltype(_impl_.lon_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.z_units_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.speed_units_){0}
    , decltype(_impl_.roll_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.yaw_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Goto::~Goto() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.Goto)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Goto::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Goto::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Goto::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.Goto)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.timeout_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.yaw_) -
      reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.yaw_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Goto::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 timeout = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float lat = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lon = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 4 [(.dccl.field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ZUnits z_units = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_z_units(static_cast<::IMC_DCCL::ZUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // float speed = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.SpeedUnits speed_units = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_speed_units(static_cast<::IMC_DCCL::SpeedUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // float roll = 8 [(.dccl.field) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.roll_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float pitch = 9 [(.dccl.field) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float yaw = 10 [(.dccl.field) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.yaw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Goto::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.Goto)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 timeout = 1 [(.dccl.field) = {
  if (this->_internal_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout(), target);
  }

  // float lat = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_lat(), target);
  }

  // float lon = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_lon(), target);
  }

  // float z = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_z(), target);
  }

  // .IMC_DCCL.ZUnits z_units = 5;
  if (this->_internal_z_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_z_units(), target);
  }

  // float speed = 6 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_speed(), target);
  }

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  if (this->_internal_speed_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_speed_units(), target);
  }

  // float roll = 8 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = this->_internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_roll(), target);
  }

  // float pitch = 9 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_pitch(), target);
  }

  // float yaw = 10 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_yaw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.Goto)
  return target;
}

size_t Goto::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.Goto)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 timeout = 1 [(.dccl.field) = {
  if (this->_internal_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout());
  }

  // float lat = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 1 + 4;
  }

  // float lon = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 1 + 4;
  }

  // float z = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.ZUnits z_units = 5;
  if (this->_internal_z_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_z_units());
  }

  // float speed = 6 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  if (this->_internal_speed_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_speed_units());
  }

  // float roll = 8 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = this->_internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    total_size += 1 + 4;
  }

  // float pitch = 9 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = this->_internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    total_size += 1 + 4;
  }

  // float yaw = 10 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = this->_internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Goto::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Goto::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Goto::GetClassData() const { return &_class_data_; }


void Goto::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Goto*>(&to_msg);
  auto& from = static_cast<const Goto&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.Goto)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_timeout() != 0) {
    _this->_internal_set_timeout(from._internal_timeout());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = from._internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = from._internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  if (from._internal_z_units() != 0) {
    _this->_internal_set_z_units(from._internal_z_units());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_speed_units() != 0) {
    _this->_internal_set_speed_units(from._internal_speed_units());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_roll = from._internal_roll();
  uint32_t raw_roll;
  memcpy(&raw_roll, &tmp_roll, sizeof(tmp_roll));
  if (raw_roll != 0) {
    _this->_internal_set_roll(from._internal_roll());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_pitch = from._internal_pitch();
  uint32_t raw_pitch;
  memcpy(&raw_pitch, &tmp_pitch, sizeof(tmp_pitch));
  if (raw_pitch != 0) {
    _this->_internal_set_pitch(from._internal_pitch());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_yaw = from._internal_yaw();
  uint32_t raw_yaw;
  memcpy(&raw_yaw, &tmp_yaw, sizeof(tmp_yaw));
  if (raw_yaw != 0) {
    _this->_internal_set_yaw(from._internal_yaw());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Goto::CopyFrom(const Goto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.Goto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Goto::IsInitialized() const {
  return true;
}

void Goto::InternalSwap(Goto* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Goto, _impl_.yaw_)
      + sizeof(Goto::_impl_.yaw_)
      - PROTOBUF_FIELD_OFFSET(Goto, _impl_.timeout_)>(
          reinterpret_cast<char*>(&_impl_.timeout_),
          reinterpret_cast<char*>(&other->_impl_.timeout_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Goto::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[3]);
}

// ===================================================================

class ParameterValue::_Internal {
 public:
};

ParameterValue::ParameterValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.ParameterValue)
}
ParameterValue::ParameterValue(const ParameterValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ParameterValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ParameterValueUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ParameterValueUnion();
  switch (from.ParameterValueUnion_case()) {
    case kParamNumber: {
      _this->_internal_set_param_number(from._internal_param_number());
      break;
    }
    case kParamEnum: {
      _this->_internal_set_param_enum(from._internal_param_enum());
      break;
    }
    case kParamString: {
      _this->_internal_set_param_string(from._internal_param_string());
      break;
    }
    case PARAMETERVALUEUNION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.ParameterValue)
}

inline void ParameterValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ParameterValueUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ParameterValueUnion();
}

ParameterValue::~ParameterValue() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.ParameterValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ParameterValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ParameterValueUnion()) {
    clear_ParameterValueUnion();
  }
}

void ParameterValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ParameterValue::clear_ParameterValueUnion() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.ParameterValue)
  switch (ParameterValueUnion_case()) {
    case kParamNumber: {
      // No need to clear
      break;
    }
    case kParamEnum: {
      // No need to clear
      break;
    }
    case kParamString: {
      _impl_.ParameterValueUnion_.param_string_.Destroy();
      break;
    }
    case PARAMETERVALUEUNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PARAMETERVALUEUNION_NOT_SET;
}


void ParameterValue::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.ParameterValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ParameterValueUnion();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ParameterValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float param_number = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _internal_set_param_number(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ParamValue param_enum = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_param_enum(static_cast<::IMC_DCCL::ParamValue>(val));
        } else
          goto handle_unusual;
        continue;
      // string param_string = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_param_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.ParameterValue.param_string"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ParameterValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.ParameterValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float param_number = 1 [(.dccl.field) = {
  if (_internal_has_param_number()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_param_number(), target);
  }

  // .IMC_DCCL.ParamValue param_enum = 2;
  if (_internal_has_param_enum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_param_enum(), target);
  }

  // string param_string = 3 [(.dccl.field) = {
  if (_internal_has_param_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_param_string().data(), static_cast<int>(this->_internal_param_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.ParameterValue.param_string");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_param_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.ParameterValue)
  return target;
}

size_t ParameterValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.ParameterValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ParameterValueUnion_case()) {
    // float param_number = 1 [(.dccl.field) = {
    case kParamNumber: {
      total_size += 1 + 4;
      break;
    }
    // .IMC_DCCL.ParamValue param_enum = 2;
    case kParamEnum: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_param_enum());
      break;
    }
    // string param_string = 3 [(.dccl.field) = {
    case kParamString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_param_string());
      break;
    }
    case PARAMETERVALUEUNION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ParameterValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ParameterValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ParameterValue::GetClassData() const { return &_class_data_; }


void ParameterValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ParameterValue*>(&to_msg);
  auto& from = static_cast<const ParameterValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.ParameterValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ParameterValueUnion_case()) {
    case kParamNumber: {
      _this->_internal_set_param_number(from._internal_param_number());
      break;
    }
    case kParamEnum: {
      _this->_internal_set_param_enum(from._internal_param_enum());
      break;
    }
    case kParamString: {
      _this->_internal_set_param_string(from._internal_param_string());
      break;
    }
    case PARAMETERVALUEUNION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ParameterValue::CopyFrom(const ParameterValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.ParameterValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ParameterValue::IsInitialized() const {
  return true;
}

void ParameterValue::InternalSwap(ParameterValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ParameterValueUnion_, other->_impl_.ParameterValueUnion_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ParameterValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[4]);
}

// ===================================================================

class PathPoint::_Internal {
 public:
};

PathPoint::PathPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PathPoint)
}
PathPoint::PathPoint(const PathPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PathPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.z_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PathPoint)
}

inline void PathPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PathPoint::~PathPoint() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PathPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PathPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void PathPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PathPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PathPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.z_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.z_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PathPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PathPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PathPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float z = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PathPoint)
  return target;
}

size_t PathPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PathPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PathPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PathPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PathPoint::GetClassData() const { return &_class_data_; }


void PathPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PathPoint*>(&to_msg);
  auto& from = static_cast<const PathPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PathPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PathPoint::CopyFrom(const PathPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PathPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PathPoint::IsInitialized() const {
  return true;
}

void PathPoint::InternalSwap(PathPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PathPoint, _impl_.z_)
      + sizeof(PathPoint::_impl_.z_)
      - PROTOBUF_FIELD_OFFSET(PathPoint, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PathPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[5]);
}

// ===================================================================

class Maneuver::_Internal {
 public:
  static const ::IMC_DCCL::Goto& goto_maneuver(const Maneuver* msg);
  static const ::IMC_DCCL::FollowPath& followpath_maneuver(const Maneuver* msg);
  static const ::IMC_DCCL::Loiter& loiter_maneuver(const Maneuver* msg);
  static const ::IMC_DCCL::StationKeeping& stationkeeping_maneuver(const Maneuver* msg);
};

const ::IMC_DCCL::Goto&
Maneuver::_Internal::goto_maneuver(const Maneuver* msg) {
  return *msg->_impl_.ManeuverUnion_.goto_maneuver_;
}
const ::IMC_DCCL::FollowPath&
Maneuver::_Internal::followpath_maneuver(const Maneuver* msg) {
  return *msg->_impl_.ManeuverUnion_.followpath_maneuver_;
}
const ::IMC_DCCL::Loiter&
Maneuver::_Internal::loiter_maneuver(const Maneuver* msg) {
  return *msg->_impl_.ManeuverUnion_.loiter_maneuver_;
}
const ::IMC_DCCL::StationKeeping&
Maneuver::_Internal::stationkeeping_maneuver(const Maneuver* msg) {
  return *msg->_impl_.ManeuverUnion_.stationkeeping_maneuver_;
}
void Maneuver::set_allocated_goto_maneuver(::IMC_DCCL::Goto* goto_maneuver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ManeuverUnion();
  if (goto_maneuver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(goto_maneuver);
    if (message_arena != submessage_arena) {
      goto_maneuver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, goto_maneuver, submessage_arena);
    }
    set_has_goto_maneuver();
    _impl_.ManeuverUnion_.goto_maneuver_ = goto_maneuver;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.Maneuver.goto_maneuver)
}
void Maneuver::set_allocated_followpath_maneuver(::IMC_DCCL::FollowPath* followpath_maneuver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ManeuverUnion();
  if (followpath_maneuver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(followpath_maneuver);
    if (message_arena != submessage_arena) {
      followpath_maneuver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, followpath_maneuver, submessage_arena);
    }
    set_has_followpath_maneuver();
    _impl_.ManeuverUnion_.followpath_maneuver_ = followpath_maneuver;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.Maneuver.followpath_maneuver)
}
void Maneuver::set_allocated_loiter_maneuver(::IMC_DCCL::Loiter* loiter_maneuver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ManeuverUnion();
  if (loiter_maneuver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(loiter_maneuver);
    if (message_arena != submessage_arena) {
      loiter_maneuver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, loiter_maneuver, submessage_arena);
    }
    set_has_loiter_maneuver();
    _impl_.ManeuverUnion_.loiter_maneuver_ = loiter_maneuver;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.Maneuver.loiter_maneuver)
}
void Maneuver::set_allocated_stationkeeping_maneuver(::IMC_DCCL::StationKeeping* stationkeeping_maneuver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ManeuverUnion();
  if (stationkeeping_maneuver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(stationkeeping_maneuver);
    if (message_arena != submessage_arena) {
      stationkeeping_maneuver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stationkeeping_maneuver, submessage_arena);
    }
    set_has_stationkeeping_maneuver();
    _impl_.ManeuverUnion_.stationkeeping_maneuver_ = stationkeeping_maneuver;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.Maneuver.stationkeeping_maneuver)
}
Maneuver::Maneuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.Maneuver)
}
Maneuver::Maneuver(const Maneuver& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Maneuver* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ManeuverUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ManeuverUnion();
  switch (from.ManeuverUnion_case()) {
    case kGotoManeuver: {
      _this->_internal_mutable_goto_maneuver()->::IMC_DCCL::Goto::MergeFrom(
          from._internal_goto_maneuver());
      break;
    }
    case kFollowpathManeuver: {
      _this->_internal_mutable_followpath_maneuver()->::IMC_DCCL::FollowPath::MergeFrom(
          from._internal_followpath_maneuver());
      break;
    }
    case kLoiterManeuver: {
      _this->_internal_mutable_loiter_maneuver()->::IMC_DCCL::Loiter::MergeFrom(
          from._internal_loiter_maneuver());
      break;
    }
    case kStationkeepingManeuver: {
      _this->_internal_mutable_stationkeeping_maneuver()->::IMC_DCCL::StationKeeping::MergeFrom(
          from._internal_stationkeeping_maneuver());
      break;
    }
    case MANEUVERUNION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.Maneuver)
}

inline void Maneuver::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ManeuverUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ManeuverUnion();
}

Maneuver::~Maneuver() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.Maneuver)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Maneuver::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ManeuverUnion()) {
    clear_ManeuverUnion();
  }
}

void Maneuver::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Maneuver::clear_ManeuverUnion() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.Maneuver)
  switch (ManeuverUnion_case()) {
    case kGotoManeuver: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ManeuverUnion_.goto_maneuver_;
      }
      break;
    }
    case kFollowpathManeuver: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ManeuverUnion_.followpath_maneuver_;
      }
      break;
    }
    case kLoiterManeuver: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ManeuverUnion_.loiter_maneuver_;
      }
      break;
    }
    case kStationkeepingManeuver: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ManeuverUnion_.stationkeeping_maneuver_;
      }
      break;
    }
    case MANEUVERUNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MANEUVERUNION_NOT_SET;
}


void Maneuver::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.Maneuver)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ManeuverUnion();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Maneuver::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.Goto goto_maneuver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_goto_maneuver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.FollowPath followpath_maneuver = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_followpath_maneuver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.Loiter loiter_maneuver = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_loiter_maneuver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.StationKeeping stationkeeping_maneuver = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_stationkeeping_maneuver(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Maneuver::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.Maneuver)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.Goto goto_maneuver = 1;
  if (_internal_has_goto_maneuver()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::goto_maneuver(this),
        _Internal::goto_maneuver(this).GetCachedSize(), target, stream);
  }

  // .IMC_DCCL.FollowPath followpath_maneuver = 2;
  if (_internal_has_followpath_maneuver()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::followpath_maneuver(this),
        _Internal::followpath_maneuver(this).GetCachedSize(), target, stream);
  }

  // .IMC_DCCL.Loiter loiter_maneuver = 3;
  if (_internal_has_loiter_maneuver()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::loiter_maneuver(this),
        _Internal::loiter_maneuver(this).GetCachedSize(), target, stream);
  }

  // .IMC_DCCL.StationKeeping stationkeeping_maneuver = 4;
  if (_internal_has_stationkeeping_maneuver()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::stationkeeping_maneuver(this),
        _Internal::stationkeeping_maneuver(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.Maneuver)
  return target;
}

size_t Maneuver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.Maneuver)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ManeuverUnion_case()) {
    // .IMC_DCCL.Goto goto_maneuver = 1;
    case kGotoManeuver: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ManeuverUnion_.goto_maneuver_);
      break;
    }
    // .IMC_DCCL.FollowPath followpath_maneuver = 2;
    case kFollowpathManeuver: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ManeuverUnion_.followpath_maneuver_);
      break;
    }
    // .IMC_DCCL.Loiter loiter_maneuver = 3;
    case kLoiterManeuver: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ManeuverUnion_.loiter_maneuver_);
      break;
    }
    // .IMC_DCCL.StationKeeping stationkeeping_maneuver = 4;
    case kStationkeepingManeuver: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ManeuverUnion_.stationkeeping_maneuver_);
      break;
    }
    case MANEUVERUNION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Maneuver::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Maneuver::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Maneuver::GetClassData() const { return &_class_data_; }


void Maneuver::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Maneuver*>(&to_msg);
  auto& from = static_cast<const Maneuver&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.Maneuver)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ManeuverUnion_case()) {
    case kGotoManeuver: {
      _this->_internal_mutable_goto_maneuver()->::IMC_DCCL::Goto::MergeFrom(
          from._internal_goto_maneuver());
      break;
    }
    case kFollowpathManeuver: {
      _this->_internal_mutable_followpath_maneuver()->::IMC_DCCL::FollowPath::MergeFrom(
          from._internal_followpath_maneuver());
      break;
    }
    case kLoiterManeuver: {
      _this->_internal_mutable_loiter_maneuver()->::IMC_DCCL::Loiter::MergeFrom(
          from._internal_loiter_maneuver());
      break;
    }
    case kStationkeepingManeuver: {
      _this->_internal_mutable_stationkeeping_maneuver()->::IMC_DCCL::StationKeeping::MergeFrom(
          from._internal_stationkeeping_maneuver());
      break;
    }
    case MANEUVERUNION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Maneuver::CopyFrom(const Maneuver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.Maneuver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Maneuver::IsInitialized() const {
  return true;
}

void Maneuver::InternalSwap(Maneuver* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ManeuverUnion_, other->_impl_.ManeuverUnion_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Maneuver::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[6]);
}

// ===================================================================

class EntityParameter::_Internal {
 public:
  static const ::IMC_DCCL::ParameterValue& value(const EntityParameter* msg);
};

const ::IMC_DCCL::ParameterValue&
EntityParameter::_Internal::value(const EntityParameter* msg) {
  return *msg->_impl_.value_;
}
EntityParameter::EntityParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.EntityParameter)
}
EntityParameter::EntityParameter(const EntityParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EntityParameter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){nullptr}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_value()) {
    _this->_impl_.value_ = new ::IMC_DCCL::ParameterValue(*from._impl_.value_);
  }
  _this->_impl_.name_ = from._impl_.name_;
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.EntityParameter)
}

inline void EntityParameter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.value_){nullptr}
    , decltype(_impl_.name_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EntityParameter::~EntityParameter() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.EntityParameter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EntityParameter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.value_;
}

void EntityParameter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EntityParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.EntityParameter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
  _impl_.name_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EntityParameter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.ParameterName name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_name(static_cast<::IMC_DCCL::ParameterName>(val));
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ParameterValue value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_value(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EntityParameter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.EntityParameter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.ParameterName name = 1;
  if (this->_internal_name() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_name(), target);
  }

  // .IMC_DCCL.ParameterValue value = 2;
  if (this->_internal_has_value()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::value(this),
        _Internal::value(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.EntityParameter)
  return target;
}

size_t EntityParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.EntityParameter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .IMC_DCCL.ParameterValue value = 2;
  if (this->_internal_has_value()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.value_);
  }

  // .IMC_DCCL.ParameterName name = 1;
  if (this->_internal_name() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EntityParameter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EntityParameter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EntityParameter::GetClassData() const { return &_class_data_; }


void EntityParameter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EntityParameter*>(&to_msg);
  auto& from = static_cast<const EntityParameter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.EntityParameter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _this->_internal_mutable_value()->::IMC_DCCL::ParameterValue::MergeFrom(
        from._internal_value());
  }
  if (from._internal_name() != 0) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EntityParameter::CopyFrom(const EntityParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.EntityParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EntityParameter::IsInitialized() const {
  return true;
}

void EntityParameter::InternalSwap(EntityParameter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EntityParameter, _impl_.name_)
      + sizeof(EntityParameter::_impl_.name_)
      - PROTOBUF_FIELD_OFFSET(EntityParameter, _impl_.value_)>(
          reinterpret_cast<char*>(&_impl_.value_),
          reinterpret_cast<char*>(&other->_impl_.value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EntityParameter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[7]);
}

// ===================================================================

class SetEntityParameters::_Internal {
 public:
};

SetEntityParameters::SetEntityParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.SetEntityParameters)
}
SetEntityParameters::SetEntityParameters(const SetEntityParameters& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SetEntityParameters* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){from._impl_.params_}
    , decltype(_impl_.name_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.name_ = from._impl_.name_;
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.SetEntityParameters)
}

inline void SetEntityParameters::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.params_){arena}
    , decltype(_impl_.name_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SetEntityParameters::~SetEntityParameters() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.SetEntityParameters)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SetEntityParameters::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.params_.~RepeatedPtrField();
}

void SetEntityParameters::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SetEntityParameters::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.SetEntityParameters)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.params_.Clear();
  _impl_.name_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SetEntityParameters::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.EntityName name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_name(static_cast<::IMC_DCCL::EntityName>(val));
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_params(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SetEntityParameters::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.SetEntityParameters)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.EntityName name = 1;
  if (this->_internal_name() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_name(), target);
  }

  // repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_params_size()); i < n; i++) {
    const auto& repfield = this->_internal_params(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.SetEntityParameters)
  return target;
}

size_t SetEntityParameters::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.SetEntityParameters)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
  total_size += 1UL * this->_internal_params_size();
  for (const auto& msg : this->_impl_.params_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .IMC_DCCL.EntityName name = 1;
  if (this->_internal_name() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SetEntityParameters::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SetEntityParameters::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SetEntityParameters::GetClassData() const { return &_class_data_; }


void SetEntityParameters::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SetEntityParameters*>(&to_msg);
  auto& from = static_cast<const SetEntityParameters&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.SetEntityParameters)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.params_.MergeFrom(from._impl_.params_);
  if (from._internal_name() != 0) {
    _this->_internal_set_name(from._internal_name());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SetEntityParameters::CopyFrom(const SetEntityParameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.SetEntityParameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SetEntityParameters::IsInitialized() const {
  return true;
}

void SetEntityParameters::InternalSwap(SetEntityParameters* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.params_.InternalSwap(&other->_impl_.params_);
  swap(_impl_.name_, other->_impl_.name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SetEntityParameters::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[8]);
}

// ===================================================================

class ManeuverIDCombined::_Internal {
 public:
};

ManeuverIDCombined::ManeuverIDCombined(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.ManeuverIDCombined)
}
ManeuverIDCombined::ManeuverIDCombined(const ManeuverIDCombined& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ManeuverIDCombined* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.maneuver_type_){}
    , decltype(_impl_.maneuver_number_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.maneuver_type_, &from._impl_.maneuver_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.maneuver_number_) -
    reinterpret_cast<char*>(&_impl_.maneuver_type_)) + sizeof(_impl_.maneuver_number_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.ManeuverIDCombined)
}

inline void ManeuverIDCombined::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.maneuver_type_){0}
    , decltype(_impl_.maneuver_number_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

ManeuverIDCombined::~ManeuverIDCombined() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.ManeuverIDCombined)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ManeuverIDCombined::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ManeuverIDCombined::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ManeuverIDCombined::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.ManeuverIDCombined)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.maneuver_type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.maneuver_number_) -
      reinterpret_cast<char*>(&_impl_.maneuver_type_)) + sizeof(_impl_.maneuver_number_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ManeuverIDCombined::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.ManeuverType maneuver_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_maneuver_type(static_cast<::IMC_DCCL::ManeuverType>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 maneuver_number = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.maneuver_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ManeuverIDCombined::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.ManeuverIDCombined)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.ManeuverType maneuver_type = 1;
  if (this->_internal_maneuver_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_maneuver_type(), target);
  }

  // int32 maneuver_number = 2 [(.dccl.field) = {
  if (this->_internal_maneuver_number() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_maneuver_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.ManeuverIDCombined)
  return target;
}

size_t ManeuverIDCombined::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.ManeuverIDCombined)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .IMC_DCCL.ManeuverType maneuver_type = 1;
  if (this->_internal_maneuver_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_maneuver_type());
  }

  // int32 maneuver_number = 2 [(.dccl.field) = {
  if (this->_internal_maneuver_number() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_maneuver_number());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ManeuverIDCombined::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ManeuverIDCombined::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ManeuverIDCombined::GetClassData() const { return &_class_data_; }


void ManeuverIDCombined::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ManeuverIDCombined*>(&to_msg);
  auto& from = static_cast<const ManeuverIDCombined&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.ManeuverIDCombined)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_maneuver_type() != 0) {
    _this->_internal_set_maneuver_type(from._internal_maneuver_type());
  }
  if (from._internal_maneuver_number() != 0) {
    _this->_internal_set_maneuver_number(from._internal_maneuver_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ManeuverIDCombined::CopyFrom(const ManeuverIDCombined& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.ManeuverIDCombined)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ManeuverIDCombined::IsInitialized() const {
  return true;
}

void ManeuverIDCombined::InternalSwap(ManeuverIDCombined* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ManeuverIDCombined, _impl_.maneuver_number_)
      + sizeof(ManeuverIDCombined::_impl_.maneuver_number_)
      - PROTOBUF_FIELD_OFFSET(ManeuverIDCombined, _impl_.maneuver_type_)>(
          reinterpret_cast<char*>(&_impl_.maneuver_type_),
          reinterpret_cast<char*>(&other->_impl_.maneuver_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ManeuverIDCombined::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[9]);
}

// ===================================================================

class ManeuverID::_Internal {
 public:
  static const ::IMC_DCCL::ManeuverIDCombined& id_combined(const ManeuverID* msg);
};

const ::IMC_DCCL::ManeuverIDCombined&
ManeuverID::_Internal::id_combined(const ManeuverID* msg) {
  return *msg->_impl_.ManeuverIDUnion_.id_combined_;
}
void ManeuverID::set_allocated_id_combined(::IMC_DCCL::ManeuverIDCombined* id_combined) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ManeuverIDUnion();
  if (id_combined) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(id_combined);
    if (message_arena != submessage_arena) {
      id_combined = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id_combined, submessage_arena);
    }
    set_has_id_combined();
    _impl_.ManeuverIDUnion_.id_combined_ = id_combined;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.ManeuverID.id_combined)
}
ManeuverID::ManeuverID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.ManeuverID)
}
ManeuverID::ManeuverID(const ManeuverID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ManeuverID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.ManeuverIDUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_ManeuverIDUnion();
  switch (from.ManeuverIDUnion_case()) {
    case kIdCombined: {
      _this->_internal_mutable_id_combined()->::IMC_DCCL::ManeuverIDCombined::MergeFrom(
          from._internal_id_combined());
      break;
    }
    case kIdString: {
      _this->_internal_set_id_string(from._internal_id_string());
      break;
    }
    case MANEUVERIDUNION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.ManeuverID)
}

inline void ManeuverID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.ManeuverIDUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_ManeuverIDUnion();
}

ManeuverID::~ManeuverID() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.ManeuverID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ManeuverID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_ManeuverIDUnion()) {
    clear_ManeuverIDUnion();
  }
}

void ManeuverID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ManeuverID::clear_ManeuverIDUnion() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.ManeuverID)
  switch (ManeuverIDUnion_case()) {
    case kIdCombined: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.ManeuverIDUnion_.id_combined_;
      }
      break;
    }
    case kIdString: {
      _impl_.ManeuverIDUnion_.id_string_.Destroy();
      break;
    }
    case MANEUVERIDUNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = MANEUVERIDUNION_NOT_SET;
}


void ManeuverID::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.ManeuverID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_ManeuverIDUnion();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ManeuverID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.ManeuverIDCombined id_combined = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_id_combined(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string id_string = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_id_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.ManeuverID.id_string"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ManeuverID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.ManeuverID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.ManeuverIDCombined id_combined = 1;
  if (_internal_has_id_combined()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::id_combined(this),
        _Internal::id_combined(this).GetCachedSize(), target, stream);
  }

  // string id_string = 2 [(.dccl.field) = {
  if (_internal_has_id_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_id_string().data(), static_cast<int>(this->_internal_id_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.ManeuverID.id_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_id_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.ManeuverID)
  return target;
}

size_t ManeuverID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.ManeuverID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (ManeuverIDUnion_case()) {
    // .IMC_DCCL.ManeuverIDCombined id_combined = 1;
    case kIdCombined: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ManeuverIDUnion_.id_combined_);
      break;
    }
    // string id_string = 2 [(.dccl.field) = {
    case kIdString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id_string());
      break;
    }
    case MANEUVERIDUNION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ManeuverID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ManeuverID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ManeuverID::GetClassData() const { return &_class_data_; }


void ManeuverID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ManeuverID*>(&to_msg);
  auto& from = static_cast<const ManeuverID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.ManeuverID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.ManeuverIDUnion_case()) {
    case kIdCombined: {
      _this->_internal_mutable_id_combined()->::IMC_DCCL::ManeuverIDCombined::MergeFrom(
          from._internal_id_combined());
      break;
    }
    case kIdString: {
      _this->_internal_set_id_string(from._internal_id_string());
      break;
    }
    case MANEUVERIDUNION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ManeuverID::CopyFrom(const ManeuverID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.ManeuverID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ManeuverID::IsInitialized() const {
  return true;
}

void ManeuverID::InternalSwap(ManeuverID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.ManeuverIDUnion_, other->_impl_.ManeuverIDUnion_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ManeuverID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[10]);
}

// ===================================================================

class TransitionCondition::_Internal {
 public:
};

TransitionCondition::TransitionCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.TransitionCondition)
}
TransitionCondition::TransitionCondition(const TransitionCondition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransitionCondition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.TransitionConditionUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_TransitionConditionUnion();
  switch (from.TransitionConditionUnion_case()) {
    case kConditionEnum: {
      _this->_internal_set_condition_enum(from._internal_condition_enum());
      break;
    }
    case kConditionString: {
      _this->_internal_set_condition_string(from._internal_condition_string());
      break;
    }
    case TRANSITIONCONDITIONUNION_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.TransitionCondition)
}

inline void TransitionCondition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.TransitionConditionUnion_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_TransitionConditionUnion();
}

TransitionCondition::~TransitionCondition() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.TransitionCondition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransitionCondition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_TransitionConditionUnion()) {
    clear_TransitionConditionUnion();
  }
}

void TransitionCondition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransitionCondition::clear_TransitionConditionUnion() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.TransitionCondition)
  switch (TransitionConditionUnion_case()) {
    case kConditionEnum: {
      // No need to clear
      break;
    }
    case kConditionString: {
      _impl_.TransitionConditionUnion_.condition_string_.Destroy();
      break;
    }
    case TRANSITIONCONDITIONUNION_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = TRANSITIONCONDITIONUNION_NOT_SET;
}


void TransitionCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.TransitionCondition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_TransitionConditionUnion();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransitionCondition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.TransitionConditionEnum condition_enum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_condition_enum(static_cast<::IMC_DCCL::TransitionConditionEnum>(val));
        } else
          goto handle_unusual;
        continue;
      // string condition_string = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_condition_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.TransitionCondition.condition_string"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransitionCondition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.TransitionCondition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.TransitionConditionEnum condition_enum = 1;
  if (_internal_has_condition_enum()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_condition_enum(), target);
  }

  // string condition_string = 2 [(.dccl.field) = {
  if (_internal_has_condition_string()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_condition_string().data(), static_cast<int>(this->_internal_condition_string().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.TransitionCondition.condition_string");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_condition_string(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.TransitionCondition)
  return target;
}

size_t TransitionCondition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.TransitionCondition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (TransitionConditionUnion_case()) {
    // .IMC_DCCL.TransitionConditionEnum condition_enum = 1;
    case kConditionEnum: {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_condition_enum());
      break;
    }
    // string condition_string = 2 [(.dccl.field) = {
    case kConditionString: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_condition_string());
      break;
    }
    case TRANSITIONCONDITIONUNION_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransitionCondition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransitionCondition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransitionCondition::GetClassData() const { return &_class_data_; }


void TransitionCondition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransitionCondition*>(&to_msg);
  auto& from = static_cast<const TransitionCondition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.TransitionCondition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.TransitionConditionUnion_case()) {
    case kConditionEnum: {
      _this->_internal_set_condition_enum(from._internal_condition_enum());
      break;
    }
    case kConditionString: {
      _this->_internal_set_condition_string(from._internal_condition_string());
      break;
    }
    case TRANSITIONCONDITIONUNION_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransitionCondition::CopyFrom(const TransitionCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.TransitionCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransitionCondition::IsInitialized() const {
  return true;
}

void TransitionCondition::InternalSwap(TransitionCondition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.TransitionConditionUnion_, other->_impl_.TransitionConditionUnion_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransitionCondition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[11]);
}

// ===================================================================

class Loiter::_Internal {
 public:
};

Loiter::Loiter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.Loiter)
}
Loiter::Loiter(const Loiter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Loiter* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.timeout_){}
    , decltype(_impl_.lat_){}
    , decltype(_impl_.lon_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.z_units_){}
    , decltype(_impl_.duration_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.speed_units_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.length_){}
    , decltype(_impl_.bearing_){}
    , decltype(_impl_.direction_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.timeout_, &from._impl_.timeout_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.direction_) -
    reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.direction_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.Loiter)
}

inline void Loiter::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.timeout_){0}
    , decltype(_impl_.lat_){0}
    , decltype(_impl_.lon_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.z_units_){0}
    , decltype(_impl_.duration_){0}
    , decltype(_impl_.speed_){0}
    , decltype(_impl_.speed_units_){0}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.length_){0}
    , decltype(_impl_.bearing_){0}
    , decltype(_impl_.direction_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Loiter::~Loiter() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.Loiter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Loiter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Loiter::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Loiter::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.Loiter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.timeout_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.direction_) -
      reinterpret_cast<char*>(&_impl_.timeout_)) + sizeof(_impl_.direction_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Loiter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 timeout = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.timeout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float lat = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lon = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 4 [(.dccl.field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ZUnits z_units = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_z_units(static_cast<::IMC_DCCL::ZUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 duration = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _impl_.duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // float speed = 7 [(.dccl.field) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.SpeedUnits speed_units = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_speed_units(static_cast<::IMC_DCCL::SpeedUnits>(val));
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.Loiter.LoiterTypeEnum type = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::IMC_DCCL::Loiter_LoiterTypeEnum>(val));
        } else
          goto handle_unusual;
        continue;
      // float radius = 10 [(.dccl.field) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float length = 11 [(.dccl.field) = {
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float bearing = 12 [(.dccl.field) = {
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.bearing_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.Loiter.DirectionEnum direction = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_direction(static_cast<::IMC_DCCL::Loiter_DirectionEnum>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Loiter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.Loiter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 timeout = 1 [(.dccl.field) = {
  if (this->_internal_timeout() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_timeout(), target);
  }

  // float lat = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_lat(), target);
  }

  // float lon = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_lon(), target);
  }

  // float z = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_z(), target);
  }

  // .IMC_DCCL.ZUnits z_units = 5;
  if (this->_internal_z_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_z_units(), target);
  }

  // int32 duration = 6 [(.dccl.field) = {
  if (this->_internal_duration() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_duration(), target);
  }

  // float speed = 7 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_speed(), target);
  }

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  if (this->_internal_speed_units() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_speed_units(), target);
  }

  // .IMC_DCCL.Loiter.LoiterTypeEnum type = 9;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_type(), target);
  }

  // float radius = 10 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_radius(), target);
  }

  // float length = 11 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length = this->_internal_length();
  uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_length(), target);
  }

  // float bearing = 12 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bearing = this->_internal_bearing();
  uint32_t raw_bearing;
  memcpy(&raw_bearing, &tmp_bearing, sizeof(tmp_bearing));
  if (raw_bearing != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_bearing(), target);
  }

  // .IMC_DCCL.Loiter.DirectionEnum direction = 13;
  if (this->_internal_direction() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.Loiter)
  return target;
}

size_t Loiter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.Loiter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 timeout = 1 [(.dccl.field) = {
  if (this->_internal_timeout() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_timeout());
  }

  // float lat = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 1 + 4;
  }

  // float lon = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 1 + 4;
  }

  // float z = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.ZUnits z_units = 5;
  if (this->_internal_z_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_z_units());
  }

  // int32 duration = 6 [(.dccl.field) = {
  if (this->_internal_duration() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_duration());
  }

  // float speed = 7 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = this->_internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  if (this->_internal_speed_units() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_speed_units());
  }

  // .IMC_DCCL.Loiter.LoiterTypeEnum type = 9;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // float radius = 10 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 4;
  }

  // float length = 11 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length = this->_internal_length();
  uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    total_size += 1 + 4;
  }

  // float bearing = 12 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bearing = this->_internal_bearing();
  uint32_t raw_bearing;
  memcpy(&raw_bearing, &tmp_bearing, sizeof(tmp_bearing));
  if (raw_bearing != 0) {
    total_size += 1 + 4;
  }

  // .IMC_DCCL.Loiter.DirectionEnum direction = 13;
  if (this->_internal_direction() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_direction());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Loiter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Loiter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Loiter::GetClassData() const { return &_class_data_; }


void Loiter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Loiter*>(&to_msg);
  auto& from = static_cast<const Loiter&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.Loiter)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_timeout() != 0) {
    _this->_internal_set_timeout(from._internal_timeout());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = from._internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = from._internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  if (from._internal_z_units() != 0) {
    _this->_internal_set_z_units(from._internal_z_units());
  }
  if (from._internal_duration() != 0) {
    _this->_internal_set_duration(from._internal_duration());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_speed = from._internal_speed();
  uint32_t raw_speed;
  memcpy(&raw_speed, &tmp_speed, sizeof(tmp_speed));
  if (raw_speed != 0) {
    _this->_internal_set_speed(from._internal_speed());
  }
  if (from._internal_speed_units() != 0) {
    _this->_internal_set_speed_units(from._internal_speed_units());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_length = from._internal_length();
  uint32_t raw_length;
  memcpy(&raw_length, &tmp_length, sizeof(tmp_length));
  if (raw_length != 0) {
    _this->_internal_set_length(from._internal_length());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_bearing = from._internal_bearing();
  uint32_t raw_bearing;
  memcpy(&raw_bearing, &tmp_bearing, sizeof(tmp_bearing));
  if (raw_bearing != 0) {
    _this->_internal_set_bearing(from._internal_bearing());
  }
  if (from._internal_direction() != 0) {
    _this->_internal_set_direction(from._internal_direction());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Loiter::CopyFrom(const Loiter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.Loiter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Loiter::IsInitialized() const {
  return true;
}

void Loiter::InternalSwap(Loiter* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Loiter, _impl_.direction_)
      + sizeof(Loiter::_impl_.direction_)
      - PROTOBUF_FIELD_OFFSET(Loiter, _impl_.timeout_)>(
          reinterpret_cast<char*>(&_impl_.timeout_),
          reinterpret_cast<char*>(&other->_impl_.timeout_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Loiter::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[12]);
}

// ===================================================================

class PlanManeuverStartActionsUnion::_Internal {
 public:
  static const ::IMC_DCCL::SetEntityParameters& ep(const PlanManeuverStartActionsUnion* msg);
};

const ::IMC_DCCL::SetEntityParameters&
PlanManeuverStartActionsUnion::_Internal::ep(const PlanManeuverStartActionsUnion* msg) {
  return *msg->_impl_.PlanManeuverStartActionsUnion__.ep_;
}
void PlanManeuverStartActionsUnion::set_allocated_ep(::IMC_DCCL::SetEntityParameters* ep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PlanManeuverStartActionsUnion_();
  if (ep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ep);
    if (message_arena != submessage_arena) {
      ep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ep, submessage_arena);
    }
    set_has_ep();
    _impl_.PlanManeuverStartActionsUnion__.ep_ = ep;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanManeuverStartActionsUnion.ep)
}
PlanManeuverStartActionsUnion::PlanManeuverStartActionsUnion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanManeuverStartActionsUnion)
}
PlanManeuverStartActionsUnion::PlanManeuverStartActionsUnion(const PlanManeuverStartActionsUnion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanManeuverStartActionsUnion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanManeuverStartActionsUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_PlanManeuverStartActionsUnion_();
  switch (from.PlanManeuverStartActionsUnion__case()) {
    case kEp: {
      _this->_internal_mutable_ep()->::IMC_DCCL::SetEntityParameters::MergeFrom(
          from._internal_ep());
      break;
    }
    case PLANMANEUVERSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanManeuverStartActionsUnion)
}

inline void PlanManeuverStartActionsUnion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanManeuverStartActionsUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_PlanManeuverStartActionsUnion_();
}

PlanManeuverStartActionsUnion::~PlanManeuverStartActionsUnion() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanManeuverStartActionsUnion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanManeuverStartActionsUnion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_PlanManeuverStartActionsUnion_()) {
    clear_PlanManeuverStartActionsUnion_();
  }
}

void PlanManeuverStartActionsUnion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanManeuverStartActionsUnion::clear_PlanManeuverStartActionsUnion_() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.PlanManeuverStartActionsUnion)
  switch (PlanManeuverStartActionsUnion__case()) {
    case kEp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.PlanManeuverStartActionsUnion__.ep_;
      }
      break;
    }
    case PLANMANEUVERSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PLANMANEUVERSTARTACTIONSUNION__NOT_SET;
}


void PlanManeuverStartActionsUnion::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanManeuverStartActionsUnion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_PlanManeuverStartActionsUnion_();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanManeuverStartActionsUnion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.SetEntityParameters ep = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanManeuverStartActionsUnion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanManeuverStartActionsUnion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.SetEntityParameters ep = 1;
  if (_internal_has_ep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ep(this),
        _Internal::ep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanManeuverStartActionsUnion)
  return target;
}

size_t PlanManeuverStartActionsUnion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanManeuverStartActionsUnion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (PlanManeuverStartActionsUnion__case()) {
    // .IMC_DCCL.SetEntityParameters ep = 1;
    case kEp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.PlanManeuverStartActionsUnion__.ep_);
      break;
    }
    case PLANMANEUVERSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanManeuverStartActionsUnion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanManeuverStartActionsUnion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanManeuverStartActionsUnion::GetClassData() const { return &_class_data_; }


void PlanManeuverStartActionsUnion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanManeuverStartActionsUnion*>(&to_msg);
  auto& from = static_cast<const PlanManeuverStartActionsUnion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanManeuverStartActionsUnion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.PlanManeuverStartActionsUnion__case()) {
    case kEp: {
      _this->_internal_mutable_ep()->::IMC_DCCL::SetEntityParameters::MergeFrom(
          from._internal_ep());
      break;
    }
    case PLANMANEUVERSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanManeuverStartActionsUnion::CopyFrom(const PlanManeuverStartActionsUnion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanManeuverStartActionsUnion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanManeuverStartActionsUnion::IsInitialized() const {
  return true;
}

void PlanManeuverStartActionsUnion::InternalSwap(PlanManeuverStartActionsUnion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.PlanManeuverStartActionsUnion__, other->_impl_.PlanManeuverStartActionsUnion__);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanManeuverStartActionsUnion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[13]);
}

// ===================================================================

class PlanManeuver::_Internal {
 public:
  static const ::IMC_DCCL::ManeuverID& maneuver_id(const PlanManeuver* msg);
  static const ::IMC_DCCL::Maneuver& data(const PlanManeuver* msg);
};

const ::IMC_DCCL::ManeuverID&
PlanManeuver::_Internal::maneuver_id(const PlanManeuver* msg) {
  return *msg->_impl_.maneuver_id_;
}
const ::IMC_DCCL::Maneuver&
PlanManeuver::_Internal::data(const PlanManeuver* msg) {
  return *msg->_impl_.data_;
}
PlanManeuver::PlanManeuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanManeuver)
}
PlanManeuver::PlanManeuver(const PlanManeuver& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanManeuver* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.start_actions_){from._impl_.start_actions_}
    , decltype(_impl_.maneuver_id_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_maneuver_id()) {
    _this->_impl_.maneuver_id_ = new ::IMC_DCCL::ManeuverID(*from._impl_.maneuver_id_);
  }
  if (from._internal_has_data()) {
    _this->_impl_.data_ = new ::IMC_DCCL::Maneuver(*from._impl_.data_);
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanManeuver)
}

inline void PlanManeuver::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.start_actions_){arena}
    , decltype(_impl_.maneuver_id_){nullptr}
    , decltype(_impl_.data_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlanManeuver::~PlanManeuver() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanManeuver)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanManeuver::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.start_actions_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.maneuver_id_;
  if (this != internal_default_instance()) delete _impl_.data_;
}

void PlanManeuver::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanManeuver::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanManeuver)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.start_actions_.Clear();
  if (GetArenaForAllocation() == nullptr && _impl_.maneuver_id_ != nullptr) {
    delete _impl_.maneuver_id_;
  }
  _impl_.maneuver_id_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanManeuver::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.ManeuverID maneuver_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_maneuver_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.Maneuver data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.PlanManeuverStartActionsUnion start_actions = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_start_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanManeuver::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanManeuver)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.ManeuverID maneuver_id = 1;
  if (this->_internal_has_maneuver_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::maneuver_id(this),
        _Internal::maneuver_id(this).GetCachedSize(), target, stream);
  }

  // .IMC_DCCL.Maneuver data = 2;
  if (this->_internal_has_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::data(this),
        _Internal::data(this).GetCachedSize(), target, stream);
  }

  // repeated .IMC_DCCL.PlanManeuverStartActionsUnion start_actions = 3 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_start_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_start_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanManeuver)
  return target;
}

size_t PlanManeuver::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanManeuver)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IMC_DCCL.PlanManeuverStartActionsUnion start_actions = 3 [(.dccl.field) = {
  total_size += 1UL * this->_internal_start_actions_size();
  for (const auto& msg : this->_impl_.start_actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .IMC_DCCL.ManeuverID maneuver_id = 1;
  if (this->_internal_has_maneuver_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.maneuver_id_);
  }

  // .IMC_DCCL.Maneuver data = 2;
  if (this->_internal_has_data()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.data_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanManeuver::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanManeuver::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanManeuver::GetClassData() const { return &_class_data_; }


void PlanManeuver::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanManeuver*>(&to_msg);
  auto& from = static_cast<const PlanManeuver&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanManeuver)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.start_actions_.MergeFrom(from._impl_.start_actions_);
  if (from._internal_has_maneuver_id()) {
    _this->_internal_mutable_maneuver_id()->::IMC_DCCL::ManeuverID::MergeFrom(
        from._internal_maneuver_id());
  }
  if (from._internal_has_data()) {
    _this->_internal_mutable_data()->::IMC_DCCL::Maneuver::MergeFrom(
        from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanManeuver::CopyFrom(const PlanManeuver& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanManeuver)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanManeuver::IsInitialized() const {
  return true;
}

void PlanManeuver::InternalSwap(PlanManeuver* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.start_actions_.InternalSwap(&other->_impl_.start_actions_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanManeuver, _impl_.data_)
      + sizeof(PlanManeuver::_impl_.data_)
      - PROTOBUF_FIELD_OFFSET(PlanManeuver, _impl_.maneuver_id_)>(
          reinterpret_cast<char*>(&_impl_.maneuver_id_),
          reinterpret_cast<char*>(&other->_impl_.maneuver_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanManeuver::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[14]);
}

// ===================================================================

class PlanTransition::_Internal {
 public:
  static const ::IMC_DCCL::ManeuverID& source_man(const PlanTransition* msg);
  static const ::IMC_DCCL::ManeuverID& dest_man(const PlanTransition* msg);
  static const ::IMC_DCCL::TransitionCondition& conditions(const PlanTransition* msg);
};

const ::IMC_DCCL::ManeuverID&
PlanTransition::_Internal::source_man(const PlanTransition* msg) {
  return *msg->_impl_.source_man_;
}
const ::IMC_DCCL::ManeuverID&
PlanTransition::_Internal::dest_man(const PlanTransition* msg) {
  return *msg->_impl_.dest_man_;
}
const ::IMC_DCCL::TransitionCondition&
PlanTransition::_Internal::conditions(const PlanTransition* msg) {
  return *msg->_impl_.conditions_;
}
PlanTransition::PlanTransition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanTransition)
}
PlanTransition::PlanTransition(const PlanTransition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanTransition* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.source_man_){nullptr}
    , decltype(_impl_.dest_man_){nullptr}
    , decltype(_impl_.conditions_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_source_man()) {
    _this->_impl_.source_man_ = new ::IMC_DCCL::ManeuverID(*from._impl_.source_man_);
  }
  if (from._internal_has_dest_man()) {
    _this->_impl_.dest_man_ = new ::IMC_DCCL::ManeuverID(*from._impl_.dest_man_);
  }
  if (from._internal_has_conditions()) {
    _this->_impl_.conditions_ = new ::IMC_DCCL::TransitionCondition(*from._impl_.conditions_);
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanTransition)
}

inline void PlanTransition::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.source_man_){nullptr}
    , decltype(_impl_.dest_man_){nullptr}
    , decltype(_impl_.conditions_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PlanTransition::~PlanTransition() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanTransition)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanTransition::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.source_man_;
  if (this != internal_default_instance()) delete _impl_.dest_man_;
  if (this != internal_default_instance()) delete _impl_.conditions_;
}

void PlanTransition::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanTransition::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanTransition)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.source_man_ != nullptr) {
    delete _impl_.source_man_;
  }
  _impl_.source_man_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.dest_man_ != nullptr) {
    delete _impl_.dest_man_;
  }
  _impl_.dest_man_ = nullptr;
  if (GetArenaForAllocation() == nullptr && _impl_.conditions_ != nullptr) {
    delete _impl_.conditions_;
  }
  _impl_.conditions_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanTransition::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.ManeuverID source_man = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_source_man(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ManeuverID dest_man = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dest_man(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.TransitionCondition conditions = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_conditions(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanTransition::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanTransition)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.ManeuverID source_man = 1;
  if (this->_internal_has_source_man()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::source_man(this),
        _Internal::source_man(this).GetCachedSize(), target, stream);
  }

  // .IMC_DCCL.ManeuverID dest_man = 2;
  if (this->_internal_has_dest_man()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dest_man(this),
        _Internal::dest_man(this).GetCachedSize(), target, stream);
  }

  // .IMC_DCCL.TransitionCondition conditions = 3;
  if (this->_internal_has_conditions()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::conditions(this),
        _Internal::conditions(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanTransition)
  return target;
}

size_t PlanTransition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanTransition)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .IMC_DCCL.ManeuverID source_man = 1;
  if (this->_internal_has_source_man()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.source_man_);
  }

  // .IMC_DCCL.ManeuverID dest_man = 2;
  if (this->_internal_has_dest_man()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.dest_man_);
  }

  // .IMC_DCCL.TransitionCondition conditions = 3;
  if (this->_internal_has_conditions()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.conditions_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanTransition::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanTransition::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanTransition::GetClassData() const { return &_class_data_; }


void PlanTransition::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanTransition*>(&to_msg);
  auto& from = static_cast<const PlanTransition&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanTransition)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_source_man()) {
    _this->_internal_mutable_source_man()->::IMC_DCCL::ManeuverID::MergeFrom(
        from._internal_source_man());
  }
  if (from._internal_has_dest_man()) {
    _this->_internal_mutable_dest_man()->::IMC_DCCL::ManeuverID::MergeFrom(
        from._internal_dest_man());
  }
  if (from._internal_has_conditions()) {
    _this->_internal_mutable_conditions()->::IMC_DCCL::TransitionCondition::MergeFrom(
        from._internal_conditions());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanTransition::CopyFrom(const PlanTransition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanTransition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanTransition::IsInitialized() const {
  return true;
}

void PlanTransition::InternalSwap(PlanTransition* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanTransition, _impl_.conditions_)
      + sizeof(PlanTransition::_impl_.conditions_)
      - PROTOBUF_FIELD_OFFSET(PlanTransition, _impl_.source_man_)>(
          reinterpret_cast<char*>(&_impl_.source_man_),
          reinterpret_cast<char*>(&other->_impl_.source_man_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanTransition::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[15]);
}

// ===================================================================

class VerticalProfile::_Internal {
 public:
};

VerticalProfile::VerticalProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.VerticalProfile)
}
VerticalProfile::VerticalProfile(const VerticalProfile& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  VerticalProfile* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.samples_){from._impl_.samples_}
    , decltype(_impl_.parameter_){}
    , decltype(_impl_.numsamples_){}
    , decltype(_impl_.lat_){}
    , decltype(_impl_.lon_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.parameter_, &from._impl_.parameter_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.lon_) -
    reinterpret_cast<char*>(&_impl_.parameter_)) + sizeof(_impl_.lon_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.VerticalProfile)
}

inline void VerticalProfile::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.samples_){arena}
    , decltype(_impl_.parameter_){0}
    , decltype(_impl_.numsamples_){0}
    , decltype(_impl_.lat_){0}
    , decltype(_impl_.lon_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

VerticalProfile::~VerticalProfile() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.VerticalProfile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VerticalProfile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.samples_.~RepeatedPtrField();
}

void VerticalProfile::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void VerticalProfile::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.VerticalProfile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.samples_.Clear();
  ::memset(&_impl_.parameter_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.lon_) -
      reinterpret_cast<char*>(&_impl_.parameter_)) + sizeof(_impl_.lon_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* VerticalProfile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.VerticalProfile.ParameterEnum parameter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_parameter(static_cast<::IMC_DCCL::VerticalProfile_ParameterEnum>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 numsamples = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.numsamples_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.ProfileSample samples = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_samples(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // float lat = 4 [(.dccl.field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lon = 5 [(.dccl.field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VerticalProfile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.VerticalProfile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.VerticalProfile.ParameterEnum parameter = 1;
  if (this->_internal_parameter() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_parameter(), target);
  }

  // int32 numsamples = 2 [(.dccl.field) = {
  if (this->_internal_numsamples() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_numsamples(), target);
  }

  // repeated .IMC_DCCL.ProfileSample samples = 3 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_samples_size()); i < n; i++) {
    const auto& repfield = this->_internal_samples(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // float lat = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_lat(), target);
  }

  // float lon = 5 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_lon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.VerticalProfile)
  return target;
}

size_t VerticalProfile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.VerticalProfile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IMC_DCCL.ProfileSample samples = 3 [(.dccl.field) = {
  total_size += 1UL * this->_internal_samples_size();
  for (const auto& msg : this->_impl_.samples_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .IMC_DCCL.VerticalProfile.ParameterEnum parameter = 1;
  if (this->_internal_parameter() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_parameter());
  }

  // int32 numsamples = 2 [(.dccl.field) = {
  if (this->_internal_numsamples() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_numsamples());
  }

  // float lat = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 1 + 4;
  }

  // float lon = 5 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData VerticalProfile::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    VerticalProfile::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*VerticalProfile::GetClassData() const { return &_class_data_; }


void VerticalProfile::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<VerticalProfile*>(&to_msg);
  auto& from = static_cast<const VerticalProfile&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.VerticalProfile)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.samples_.MergeFrom(from._impl_.samples_);
  if (from._internal_parameter() != 0) {
    _this->_internal_set_parameter(from._internal_parameter());
  }
  if (from._internal_numsamples() != 0) {
    _this->_internal_set_numsamples(from._internal_numsamples());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = from._internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = from._internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void VerticalProfile::CopyFrom(const VerticalProfile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.VerticalProfile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VerticalProfile::IsInitialized() const {
  return true;
}

void VerticalProfile::InternalSwap(VerticalProfile* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.samples_.InternalSwap(&other->_impl_.samples_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VerticalProfile, _impl_.lon_)
      + sizeof(VerticalProfile::_impl_.lon_)
      - PROTOBUF_FIELD_OFFSET(VerticalProfile, _impl_.parameter_)>(
          reinterpret_cast<char*>(&_impl_.parameter_),
          reinterpret_cast<char*>(&other->_impl_.parameter_));
}

::PROTOBUF_NAMESPACE_ID::Metadata VerticalProfile::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[16]);
}

// ===================================================================

class EstimatedState::_Internal {
 public:
};

EstimatedState::EstimatedState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.EstimatedState)
}
EstimatedState::EstimatedState(const EstimatedState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EstimatedState* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.lat_){}
    , decltype(_impl_.lon_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.z_){}
    , decltype(_impl_.phi_){}
    , decltype(_impl_.theta_){}
    , decltype(_impl_.psi_){}
    , decltype(_impl_.u_){}
    , decltype(_impl_.v_){}
    , decltype(_impl_.w_){}
    , decltype(_impl_.vx_){}
    , decltype(_impl_.vy_){}
    , decltype(_impl_.vz_){}
    , decltype(_impl_.p_){}
    , decltype(_impl_.q_){}
    , decltype(_impl_.r_){}
    , decltype(_impl_.depth_){}
    , decltype(_impl_.alt_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.lat_, &from._impl_.lat_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.alt_) -
    reinterpret_cast<char*>(&_impl_.lat_)) + sizeof(_impl_.alt_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.EstimatedState)
}

inline void EstimatedState::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.lat_){0}
    , decltype(_impl_.lon_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.z_){0}
    , decltype(_impl_.phi_){0}
    , decltype(_impl_.theta_){0}
    , decltype(_impl_.psi_){0}
    , decltype(_impl_.u_){0}
    , decltype(_impl_.v_){0}
    , decltype(_impl_.w_){0}
    , decltype(_impl_.vx_){0}
    , decltype(_impl_.vy_){0}
    , decltype(_impl_.vz_){0}
    , decltype(_impl_.p_){0}
    , decltype(_impl_.q_){0}
    , decltype(_impl_.r_){0}
    , decltype(_impl_.depth_){0}
    , decltype(_impl_.alt_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

EstimatedState::~EstimatedState() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.EstimatedState)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EstimatedState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EstimatedState::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EstimatedState::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.EstimatedState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.lat_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.alt_) -
      reinterpret_cast<char*>(&_impl_.lat_)) + sizeof(_impl_.alt_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EstimatedState::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float lat = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.lat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float lon = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.lon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float height = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float x = 4 [(.dccl.field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 5 [(.dccl.field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float z = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float phi = 7 [(.dccl.field) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _impl_.phi_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float theta = 8 [(.dccl.field) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _impl_.theta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float psi = 9 [(.dccl.field) = {
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _impl_.psi_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float u = 10 [(.dccl.field) = {
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _impl_.u_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float v = 11 [(.dccl.field) = {
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _impl_.v_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float w = 12 [(.dccl.field) = {
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _impl_.w_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float vx = 13 [(.dccl.field) = {
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _impl_.vx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float vy = 14 [(.dccl.field) = {
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _impl_.vy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float vz = 15 [(.dccl.field) = {
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _impl_.vz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float p = 16 [(.dccl.field) = {
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _impl_.p_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float q = 17 [(.dccl.field) = {
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _impl_.q_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float r = 18 [(.dccl.field) = {
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _impl_.r_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float depth = 19 [(.dccl.field) = {
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _impl_.depth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float alt = 20 [(.dccl.field) = {
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _impl_.alt_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EstimatedState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.EstimatedState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float lat = 1 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_lat(), target);
  }

  // float lon = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_lon(), target);
  }

  // float height = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_height(), target);
  }

  // float x = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_x(), target);
  }

  // float y = 5 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_y(), target);
  }

  // float z = 6 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_z(), target);
  }

  // float phi = 7 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_phi = this->_internal_phi();
  uint32_t raw_phi;
  memcpy(&raw_phi, &tmp_phi, sizeof(tmp_phi));
  if (raw_phi != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_phi(), target);
  }

  // float theta = 8 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_theta = this->_internal_theta();
  uint32_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_theta(), target);
  }

  // float psi = 9 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_psi = this->_internal_psi();
  uint32_t raw_psi;
  memcpy(&raw_psi, &tmp_psi, sizeof(tmp_psi));
  if (raw_psi != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_psi(), target);
  }

  // float u = 10 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_u = this->_internal_u();
  uint32_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_u(), target);
  }

  // float v = 11 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v = this->_internal_v();
  uint32_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(11, this->_internal_v(), target);
  }

  // float w = 12 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_w(), target);
  }

  // float vx = 13 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = this->_internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_vx(), target);
  }

  // float vy = 14 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = this->_internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_vy(), target);
  }

  // float vz = 15 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vz = this->_internal_vz();
  uint32_t raw_vz;
  memcpy(&raw_vz, &tmp_vz, sizeof(tmp_vz));
  if (raw_vz != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_vz(), target);
  }

  // float p = 16 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_p = this->_internal_p();
  uint32_t raw_p;
  memcpy(&raw_p, &tmp_p, sizeof(tmp_p));
  if (raw_p != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_p(), target);
  }

  // float q = 17 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_q = this->_internal_q();
  uint32_t raw_q;
  memcpy(&raw_q, &tmp_q, sizeof(tmp_q));
  if (raw_q != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(17, this->_internal_q(), target);
  }

  // float r = 18 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_r = this->_internal_r();
  uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_r(), target);
  }

  // float depth = 19 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = this->_internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_depth(), target);
  }

  // float alt = 20 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alt = this->_internal_alt();
  uint32_t raw_alt;
  memcpy(&raw_alt, &tmp_alt, sizeof(tmp_alt));
  if (raw_alt != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_alt(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.EstimatedState)
  return target;
}

size_t EstimatedState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.EstimatedState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float lat = 1 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = this->_internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    total_size += 1 + 4;
  }

  // float lon = 2 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = this->_internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    total_size += 1 + 4;
  }

  // float height = 3 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 1 + 4;
  }

  // float x = 4 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 5 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float z = 6 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = this->_internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    total_size += 1 + 4;
  }

  // float phi = 7 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_phi = this->_internal_phi();
  uint32_t raw_phi;
  memcpy(&raw_phi, &tmp_phi, sizeof(tmp_phi));
  if (raw_phi != 0) {
    total_size += 1 + 4;
  }

  // float theta = 8 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_theta = this->_internal_theta();
  uint32_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    total_size += 1 + 4;
  }

  // float psi = 9 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_psi = this->_internal_psi();
  uint32_t raw_psi;
  memcpy(&raw_psi, &tmp_psi, sizeof(tmp_psi));
  if (raw_psi != 0) {
    total_size += 1 + 4;
  }

  // float u = 10 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_u = this->_internal_u();
  uint32_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    total_size += 1 + 4;
  }

  // float v = 11 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v = this->_internal_v();
  uint32_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    total_size += 1 + 4;
  }

  // float w = 12 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = this->_internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    total_size += 1 + 4;
  }

  // float vx = 13 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = this->_internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    total_size += 1 + 4;
  }

  // float vy = 14 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = this->_internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    total_size += 1 + 4;
  }

  // float vz = 15 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vz = this->_internal_vz();
  uint32_t raw_vz;
  memcpy(&raw_vz, &tmp_vz, sizeof(tmp_vz));
  if (raw_vz != 0) {
    total_size += 1 + 4;
  }

  // float p = 16 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_p = this->_internal_p();
  uint32_t raw_p;
  memcpy(&raw_p, &tmp_p, sizeof(tmp_p));
  if (raw_p != 0) {
    total_size += 2 + 4;
  }

  // float q = 17 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_q = this->_internal_q();
  uint32_t raw_q;
  memcpy(&raw_q, &tmp_q, sizeof(tmp_q));
  if (raw_q != 0) {
    total_size += 2 + 4;
  }

  // float r = 18 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_r = this->_internal_r();
  uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    total_size += 2 + 4;
  }

  // float depth = 19 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = this->_internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    total_size += 2 + 4;
  }

  // float alt = 20 [(.dccl.field) = {
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alt = this->_internal_alt();
  uint32_t raw_alt;
  memcpy(&raw_alt, &tmp_alt, sizeof(tmp_alt));
  if (raw_alt != 0) {
    total_size += 2 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EstimatedState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EstimatedState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EstimatedState::GetClassData() const { return &_class_data_; }


void EstimatedState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EstimatedState*>(&to_msg);
  auto& from = static_cast<const EstimatedState&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.EstimatedState)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lat = from._internal_lat();
  uint32_t raw_lat;
  memcpy(&raw_lat, &tmp_lat, sizeof(tmp_lat));
  if (raw_lat != 0) {
    _this->_internal_set_lat(from._internal_lat());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_lon = from._internal_lon();
  uint32_t raw_lon;
  memcpy(&raw_lon, &tmp_lon, sizeof(tmp_lon));
  if (raw_lon != 0) {
    _this->_internal_set_lon(from._internal_lon());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = from._internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_z = from._internal_z();
  uint32_t raw_z;
  memcpy(&raw_z, &tmp_z, sizeof(tmp_z));
  if (raw_z != 0) {
    _this->_internal_set_z(from._internal_z());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_phi = from._internal_phi();
  uint32_t raw_phi;
  memcpy(&raw_phi, &tmp_phi, sizeof(tmp_phi));
  if (raw_phi != 0) {
    _this->_internal_set_phi(from._internal_phi());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_theta = from._internal_theta();
  uint32_t raw_theta;
  memcpy(&raw_theta, &tmp_theta, sizeof(tmp_theta));
  if (raw_theta != 0) {
    _this->_internal_set_theta(from._internal_theta());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_psi = from._internal_psi();
  uint32_t raw_psi;
  memcpy(&raw_psi, &tmp_psi, sizeof(tmp_psi));
  if (raw_psi != 0) {
    _this->_internal_set_psi(from._internal_psi());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_u = from._internal_u();
  uint32_t raw_u;
  memcpy(&raw_u, &tmp_u, sizeof(tmp_u));
  if (raw_u != 0) {
    _this->_internal_set_u(from._internal_u());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_v = from._internal_v();
  uint32_t raw_v;
  memcpy(&raw_v, &tmp_v, sizeof(tmp_v));
  if (raw_v != 0) {
    _this->_internal_set_v(from._internal_v());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_w = from._internal_w();
  uint32_t raw_w;
  memcpy(&raw_w, &tmp_w, sizeof(tmp_w));
  if (raw_w != 0) {
    _this->_internal_set_w(from._internal_w());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vx = from._internal_vx();
  uint32_t raw_vx;
  memcpy(&raw_vx, &tmp_vx, sizeof(tmp_vx));
  if (raw_vx != 0) {
    _this->_internal_set_vx(from._internal_vx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vy = from._internal_vy();
  uint32_t raw_vy;
  memcpy(&raw_vy, &tmp_vy, sizeof(tmp_vy));
  if (raw_vy != 0) {
    _this->_internal_set_vy(from._internal_vy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_vz = from._internal_vz();
  uint32_t raw_vz;
  memcpy(&raw_vz, &tmp_vz, sizeof(tmp_vz));
  if (raw_vz != 0) {
    _this->_internal_set_vz(from._internal_vz());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_p = from._internal_p();
  uint32_t raw_p;
  memcpy(&raw_p, &tmp_p, sizeof(tmp_p));
  if (raw_p != 0) {
    _this->_internal_set_p(from._internal_p());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_q = from._internal_q();
  uint32_t raw_q;
  memcpy(&raw_q, &tmp_q, sizeof(tmp_q));
  if (raw_q != 0) {
    _this->_internal_set_q(from._internal_q());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_r = from._internal_r();
  uint32_t raw_r;
  memcpy(&raw_r, &tmp_r, sizeof(tmp_r));
  if (raw_r != 0) {
    _this->_internal_set_r(from._internal_r());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_depth = from._internal_depth();
  uint32_t raw_depth;
  memcpy(&raw_depth, &tmp_depth, sizeof(tmp_depth));
  if (raw_depth != 0) {
    _this->_internal_set_depth(from._internal_depth());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_alt = from._internal_alt();
  uint32_t raw_alt;
  memcpy(&raw_alt, &tmp_alt, sizeof(tmp_alt));
  if (raw_alt != 0) {
    _this->_internal_set_alt(from._internal_alt());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EstimatedState::CopyFrom(const EstimatedState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.EstimatedState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EstimatedState::IsInitialized() const {
  return true;
}

void EstimatedState::InternalSwap(EstimatedState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EstimatedState, _impl_.alt_)
      + sizeof(EstimatedState::_impl_.alt_)
      - PROTOBUF_FIELD_OFFSET(EstimatedState, _impl_.lat_)>(
          reinterpret_cast<char*>(&_impl_.lat_),
          reinterpret_cast<char*>(&other->_impl_.lat_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EstimatedState::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[17]);
}

// ===================================================================

class PlanSpecification::_Internal {
 public:
  static const ::IMC_DCCL::ManeuverID& start_man_id(const PlanSpecification* msg);
};

const ::IMC_DCCL::ManeuverID&
PlanSpecification::_Internal::start_man_id(const PlanSpecification* msg) {
  return *msg->_impl_.start_man_id_;
}
PlanSpecification::PlanSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanSpecification)
}
PlanSpecification::PlanSpecification(const PlanSpecification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanSpecification* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.maneuvers_){from._impl_.maneuvers_}
    , decltype(_impl_.transitions_){from._impl_.transitions_}
    , decltype(_impl_.start_actions_){from._impl_.start_actions_}
    , decltype(_impl_.end_actions_){from._impl_.end_actions_}
    , decltype(_impl_.plan_id_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.vnamespace_){}
    , decltype(_impl_.start_man_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.plan_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plan_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_plan_id().empty()) {
    _this->_impl_.plan_id_.Set(from._internal_plan_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_description().empty()) {
    _this->_impl_.description_.Set(from._internal_description(), 
      _this->GetArenaForAllocation());
  }
  _impl_.vnamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vnamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_vnamespace().empty()) {
    _this->_impl_.vnamespace_.Set(from._internal_vnamespace(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_start_man_id()) {
    _this->_impl_.start_man_id_ = new ::IMC_DCCL::ManeuverID(*from._impl_.start_man_id_);
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanSpecification)
}

inline void PlanSpecification::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.maneuvers_){arena}
    , decltype(_impl_.transitions_){arena}
    , decltype(_impl_.start_actions_){arena}
    , decltype(_impl_.end_actions_){arena}
    , decltype(_impl_.plan_id_){}
    , decltype(_impl_.description_){}
    , decltype(_impl_.vnamespace_){}
    , decltype(_impl_.start_man_id_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.plan_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plan_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.vnamespace_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.vnamespace_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlanSpecification::~PlanSpecification() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanSpecification)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanSpecification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.maneuvers_.~RepeatedPtrField();
  _impl_.transitions_.~RepeatedPtrField();
  _impl_.start_actions_.~RepeatedPtrField();
  _impl_.end_actions_.~RepeatedPtrField();
  _impl_.plan_id_.Destroy();
  _impl_.description_.Destroy();
  _impl_.vnamespace_.Destroy();
  if (this != internal_default_instance()) delete _impl_.start_man_id_;
}

void PlanSpecification::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanSpecification::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanSpecification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.maneuvers_.Clear();
  _impl_.transitions_.Clear();
  _impl_.start_actions_.Clear();
  _impl_.end_actions_.Clear();
  _impl_.plan_id_.ClearToEmpty();
  _impl_.description_.ClearToEmpty();
  _impl_.vnamespace_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.start_man_id_ != nullptr) {
    delete _impl_.start_man_id_;
  }
  _impl_.start_man_id_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanSpecification::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string plan_id = 1 [(.dccl.field) = {
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_plan_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.PlanSpecification.plan_id"));
        } else
          goto handle_unusual;
        continue;
      // string description = 2 [(.dccl.field) = {
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.PlanSpecification.description"));
        } else
          goto handle_unusual;
        continue;
      // string vnamespace = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_vnamespace();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.PlanSpecification.vnamespace"));
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.ManeuverID start_man_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_start_man_id(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_maneuvers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_transitions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.PlanSpecificationStartActionsUnion start_actions = 7 [(.dccl.field) = {
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_start_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .IMC_DCCL.PlanSpecificationEndActionsUnion end_actions = 8 [(.dccl.field) = {
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_end_actions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanSpecification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanSpecification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string plan_id = 1 [(.dccl.field) = {
  if (!this->_internal_plan_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_plan_id().data(), static_cast<int>(this->_internal_plan_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.PlanSpecification.plan_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_plan_id(), target);
  }

  // string description = 2 [(.dccl.field) = {
  if (!this->_internal_description().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.PlanSpecification.description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_description(), target);
  }

  // string vnamespace = 3 [(.dccl.field) = {
  if (!this->_internal_vnamespace().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_vnamespace().data(), static_cast<int>(this->_internal_vnamespace().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.PlanSpecification.vnamespace");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_vnamespace(), target);
  }

  // .IMC_DCCL.ManeuverID start_man_id = 4;
  if (this->_internal_has_start_man_id()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::start_man_id(this),
        _Internal::start_man_id(this).GetCachedSize(), target, stream);
  }

  // repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_maneuvers_size()); i < n; i++) {
    const auto& repfield = this->_internal_maneuvers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_transitions_size()); i < n; i++) {
    const auto& repfield = this->_internal_transitions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .IMC_DCCL.PlanSpecificationStartActionsUnion start_actions = 7 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_start_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_start_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .IMC_DCCL.PlanSpecificationEndActionsUnion end_actions = 8 [(.dccl.field) = {
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_end_actions_size()); i < n; i++) {
    const auto& repfield = this->_internal_end_actions(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanSpecification)
  return target;
}

size_t PlanSpecification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanSpecification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
  total_size += 1UL * this->_internal_maneuvers_size();
  for (const auto& msg : this->_impl_.maneuvers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
  total_size += 1UL * this->_internal_transitions_size();
  for (const auto& msg : this->_impl_.transitions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .IMC_DCCL.PlanSpecificationStartActionsUnion start_actions = 7 [(.dccl.field) = {
  total_size += 1UL * this->_internal_start_actions_size();
  for (const auto& msg : this->_impl_.start_actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .IMC_DCCL.PlanSpecificationEndActionsUnion end_actions = 8 [(.dccl.field) = {
  total_size += 1UL * this->_internal_end_actions_size();
  for (const auto& msg : this->_impl_.end_actions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // string plan_id = 1 [(.dccl.field) = {
  if (!this->_internal_plan_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_plan_id());
  }

  // string description = 2 [(.dccl.field) = {
  if (!this->_internal_description().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_description());
  }

  // string vnamespace = 3 [(.dccl.field) = {
  if (!this->_internal_vnamespace().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_vnamespace());
  }

  // .IMC_DCCL.ManeuverID start_man_id = 4;
  if (this->_internal_has_start_man_id()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.start_man_id_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanSpecification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanSpecification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanSpecification::GetClassData() const { return &_class_data_; }


void PlanSpecification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanSpecification*>(&to_msg);
  auto& from = static_cast<const PlanSpecification&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanSpecification)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.maneuvers_.MergeFrom(from._impl_.maneuvers_);
  _this->_impl_.transitions_.MergeFrom(from._impl_.transitions_);
  _this->_impl_.start_actions_.MergeFrom(from._impl_.start_actions_);
  _this->_impl_.end_actions_.MergeFrom(from._impl_.end_actions_);
  if (!from._internal_plan_id().empty()) {
    _this->_internal_set_plan_id(from._internal_plan_id());
  }
  if (!from._internal_description().empty()) {
    _this->_internal_set_description(from._internal_description());
  }
  if (!from._internal_vnamespace().empty()) {
    _this->_internal_set_vnamespace(from._internal_vnamespace());
  }
  if (from._internal_has_start_man_id()) {
    _this->_internal_mutable_start_man_id()->::IMC_DCCL::ManeuverID::MergeFrom(
        from._internal_start_man_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanSpecification::CopyFrom(const PlanSpecification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanSpecification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanSpecification::IsInitialized() const {
  return true;
}

void PlanSpecification::InternalSwap(PlanSpecification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.maneuvers_.InternalSwap(&other->_impl_.maneuvers_);
  _impl_.transitions_.InternalSwap(&other->_impl_.transitions_);
  _impl_.start_actions_.InternalSwap(&other->_impl_.start_actions_);
  _impl_.end_actions_.InternalSwap(&other->_impl_.end_actions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.plan_id_, lhs_arena,
      &other->_impl_.plan_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.description_, lhs_arena,
      &other->_impl_.description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.vnamespace_, lhs_arena,
      &other->_impl_.vnamespace_, rhs_arena
  );
  swap(_impl_.start_man_id_, other->_impl_.start_man_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanSpecification::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[18]);
}

// ===================================================================

class PlanDB::_Internal {
 public:
  static const ::IMC_DCCL::PlanDBArgUnion& arg(const PlanDB* msg);
};

const ::IMC_DCCL::PlanDBArgUnion&
PlanDB::_Internal::arg(const PlanDB* msg) {
  return *msg->_impl_.arg_;
}
PlanDB::PlanDB(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanDB)
}
PlanDB::PlanDB(const PlanDB& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanDB* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.plan_id_){}
    , decltype(_impl_.info_){}
    , decltype(_impl_.arg_){nullptr}
    , decltype(_impl_.type_){}
    , decltype(_impl_.op_){}
    , decltype(_impl_.request_id_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.plan_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plan_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_plan_id().empty()) {
    _this->_impl_.plan_id_.Set(from._internal_plan_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_info().empty()) {
    _this->_impl_.info_.Set(from._internal_info(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_arg()) {
    _this->_impl_.arg_ = new ::IMC_DCCL::PlanDBArgUnion(*from._impl_.arg_);
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.request_id_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.request_id_));
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanDB)
}

inline void PlanDB::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.plan_id_){}
    , decltype(_impl_.info_){}
    , decltype(_impl_.arg_){nullptr}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.op_){0}
    , decltype(_impl_.request_id_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.plan_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.plan_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PlanDB::~PlanDB() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanDB)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanDB::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.plan_id_.Destroy();
  _impl_.info_.Destroy();
  if (this != internal_default_instance()) delete _impl_.arg_;
}

void PlanDB::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanDB::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanDB)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.plan_id_.ClearToEmpty();
  _impl_.info_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.arg_ != nullptr) {
    delete _impl_.arg_;
  }
  _impl_.arg_ = nullptr;
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.request_id_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.request_id_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanDB::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.PlanDB.TypeEnum type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::IMC_DCCL::PlanDB_TypeEnum>(val));
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.PlanDB.OperationEnum op = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_op(static_cast<::IMC_DCCL::PlanDB_OperationEnum>(val));
        } else
          goto handle_unusual;
        continue;
      // int32 request_id = 3 [(.dccl.field) = {
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string plan_id = 4 [(.dccl.field) = {
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_plan_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.PlanDB.plan_id"));
        } else
          goto handle_unusual;
        continue;
      // .IMC_DCCL.PlanDBArgUnion arg = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_arg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string info = 6 [(.dccl.field) = {
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "IMC_DCCL.PlanDB.info"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanDB::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanDB)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.PlanDB.TypeEnum type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // .IMC_DCCL.PlanDB.OperationEnum op = 2;
  if (this->_internal_op() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_op(), target);
  }

  // int32 request_id = 3 [(.dccl.field) = {
  if (this->_internal_request_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_request_id(), target);
  }

  // string plan_id = 4 [(.dccl.field) = {
  if (!this->_internal_plan_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_plan_id().data(), static_cast<int>(this->_internal_plan_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.PlanDB.plan_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_plan_id(), target);
  }

  // .IMC_DCCL.PlanDBArgUnion arg = 5;
  if (this->_internal_has_arg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::arg(this),
        _Internal::arg(this).GetCachedSize(), target, stream);
  }

  // string info = 6 [(.dccl.field) = {
  if (!this->_internal_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_info().data(), static_cast<int>(this->_internal_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "IMC_DCCL.PlanDB.info");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanDB)
  return target;
}

size_t PlanDB::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanDB)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string plan_id = 4 [(.dccl.field) = {
  if (!this->_internal_plan_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_plan_id());
  }

  // string info = 6 [(.dccl.field) = {
  if (!this->_internal_info().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_info());
  }

  // .IMC_DCCL.PlanDBArgUnion arg = 5;
  if (this->_internal_has_arg()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.arg_);
  }

  // .IMC_DCCL.PlanDB.TypeEnum type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // .IMC_DCCL.PlanDB.OperationEnum op = 2;
  if (this->_internal_op() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_op());
  }

  // int32 request_id = 3 [(.dccl.field) = {
  if (this->_internal_request_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_request_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanDB::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanDB::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanDB::GetClassData() const { return &_class_data_; }


void PlanDB::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanDB*>(&to_msg);
  auto& from = static_cast<const PlanDB&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanDB)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_plan_id().empty()) {
    _this->_internal_set_plan_id(from._internal_plan_id());
  }
  if (!from._internal_info().empty()) {
    _this->_internal_set_info(from._internal_info());
  }
  if (from._internal_has_arg()) {
    _this->_internal_mutable_arg()->::IMC_DCCL::PlanDBArgUnion::MergeFrom(
        from._internal_arg());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_op() != 0) {
    _this->_internal_set_op(from._internal_op());
  }
  if (from._internal_request_id() != 0) {
    _this->_internal_set_request_id(from._internal_request_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanDB::CopyFrom(const PlanDB& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanDB)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanDB::IsInitialized() const {
  return true;
}

void PlanDB::InternalSwap(PlanDB* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.plan_id_, lhs_arena,
      &other->_impl_.plan_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.info_, lhs_arena,
      &other->_impl_.info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PlanDB, _impl_.request_id_)
      + sizeof(PlanDB::_impl_.request_id_)
      - PROTOBUF_FIELD_OFFSET(PlanDB, _impl_.arg_)>(
          reinterpret_cast<char*>(&_impl_.arg_),
          reinterpret_cast<char*>(&other->_impl_.arg_));
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanDB::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[19]);
}

// ===================================================================

class PlanDBArgUnion::_Internal {
 public:
  static const ::IMC_DCCL::PlanSpecification& ps_arg(const PlanDBArgUnion* msg);
};

const ::IMC_DCCL::PlanSpecification&
PlanDBArgUnion::_Internal::ps_arg(const PlanDBArgUnion* msg) {
  return *msg->_impl_.PlanDBArgUnion__.ps_arg_;
}
void PlanDBArgUnion::set_allocated_ps_arg(::IMC_DCCL::PlanSpecification* ps_arg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PlanDBArgUnion_();
  if (ps_arg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ps_arg);
    if (message_arena != submessage_arena) {
      ps_arg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ps_arg, submessage_arena);
    }
    set_has_ps_arg();
    _impl_.PlanDBArgUnion__.ps_arg_ = ps_arg;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanDBArgUnion.ps_arg)
}
PlanDBArgUnion::PlanDBArgUnion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanDBArgUnion)
}
PlanDBArgUnion::PlanDBArgUnion(const PlanDBArgUnion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanDBArgUnion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanDBArgUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_PlanDBArgUnion_();
  switch (from.PlanDBArgUnion__case()) {
    case kPsArg: {
      _this->_internal_mutable_ps_arg()->::IMC_DCCL::PlanSpecification::MergeFrom(
          from._internal_ps_arg());
      break;
    }
    case PLANDBARGUNION__NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanDBArgUnion)
}

inline void PlanDBArgUnion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanDBArgUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_PlanDBArgUnion_();
}

PlanDBArgUnion::~PlanDBArgUnion() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanDBArgUnion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanDBArgUnion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_PlanDBArgUnion_()) {
    clear_PlanDBArgUnion_();
  }
}

void PlanDBArgUnion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanDBArgUnion::clear_PlanDBArgUnion_() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.PlanDBArgUnion)
  switch (PlanDBArgUnion__case()) {
    case kPsArg: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.PlanDBArgUnion__.ps_arg_;
      }
      break;
    }
    case PLANDBARGUNION__NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PLANDBARGUNION__NOT_SET;
}


void PlanDBArgUnion::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanDBArgUnion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_PlanDBArgUnion_();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanDBArgUnion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.PlanSpecification ps_arg = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ps_arg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanDBArgUnion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanDBArgUnion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.PlanSpecification ps_arg = 1;
  if (_internal_has_ps_arg()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ps_arg(this),
        _Internal::ps_arg(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanDBArgUnion)
  return target;
}

size_t PlanDBArgUnion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanDBArgUnion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (PlanDBArgUnion__case()) {
    // .IMC_DCCL.PlanSpecification ps_arg = 1;
    case kPsArg: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.PlanDBArgUnion__.ps_arg_);
      break;
    }
    case PLANDBARGUNION__NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanDBArgUnion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanDBArgUnion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanDBArgUnion::GetClassData() const { return &_class_data_; }


void PlanDBArgUnion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanDBArgUnion*>(&to_msg);
  auto& from = static_cast<const PlanDBArgUnion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanDBArgUnion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.PlanDBArgUnion__case()) {
    case kPsArg: {
      _this->_internal_mutable_ps_arg()->::IMC_DCCL::PlanSpecification::MergeFrom(
          from._internal_ps_arg());
      break;
    }
    case PLANDBARGUNION__NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanDBArgUnion::CopyFrom(const PlanDBArgUnion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanDBArgUnion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanDBArgUnion::IsInitialized() const {
  return true;
}

void PlanDBArgUnion::InternalSwap(PlanDBArgUnion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.PlanDBArgUnion__, other->_impl_.PlanDBArgUnion__);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanDBArgUnion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[20]);
}

// ===================================================================

class PlanSpecificationStartActionsUnion::_Internal {
 public:
  static const ::IMC_DCCL::SetEntityParameters& ep(const PlanSpecificationStartActionsUnion* msg);
};

const ::IMC_DCCL::SetEntityParameters&
PlanSpecificationStartActionsUnion::_Internal::ep(const PlanSpecificationStartActionsUnion* msg) {
  return *msg->_impl_.PlanSpecificationStartActionsUnion__.ep_;
}
void PlanSpecificationStartActionsUnion::set_allocated_ep(::IMC_DCCL::SetEntityParameters* ep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PlanSpecificationStartActionsUnion_();
  if (ep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ep);
    if (message_arena != submessage_arena) {
      ep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ep, submessage_arena);
    }
    set_has_ep();
    _impl_.PlanSpecificationStartActionsUnion__.ep_ = ep;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecificationStartActionsUnion.ep)
}
PlanSpecificationStartActionsUnion::PlanSpecificationStartActionsUnion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanSpecificationStartActionsUnion)
}
PlanSpecificationStartActionsUnion::PlanSpecificationStartActionsUnion(const PlanSpecificationStartActionsUnion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanSpecificationStartActionsUnion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanSpecificationStartActionsUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_PlanSpecificationStartActionsUnion_();
  switch (from.PlanSpecificationStartActionsUnion__case()) {
    case kEp: {
      _this->_internal_mutable_ep()->::IMC_DCCL::SetEntityParameters::MergeFrom(
          from._internal_ep());
      break;
    }
    case PLANSPECIFICATIONSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanSpecificationStartActionsUnion)
}

inline void PlanSpecificationStartActionsUnion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanSpecificationStartActionsUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_PlanSpecificationStartActionsUnion_();
}

PlanSpecificationStartActionsUnion::~PlanSpecificationStartActionsUnion() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanSpecificationStartActionsUnion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanSpecificationStartActionsUnion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_PlanSpecificationStartActionsUnion_()) {
    clear_PlanSpecificationStartActionsUnion_();
  }
}

void PlanSpecificationStartActionsUnion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanSpecificationStartActionsUnion::clear_PlanSpecificationStartActionsUnion_() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.PlanSpecificationStartActionsUnion)
  switch (PlanSpecificationStartActionsUnion__case()) {
    case kEp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.PlanSpecificationStartActionsUnion__.ep_;
      }
      break;
    }
    case PLANSPECIFICATIONSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PLANSPECIFICATIONSTARTACTIONSUNION__NOT_SET;
}


void PlanSpecificationStartActionsUnion::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanSpecificationStartActionsUnion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_PlanSpecificationStartActionsUnion_();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanSpecificationStartActionsUnion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.SetEntityParameters ep = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanSpecificationStartActionsUnion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanSpecificationStartActionsUnion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.SetEntityParameters ep = 1;
  if (_internal_has_ep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ep(this),
        _Internal::ep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanSpecificationStartActionsUnion)
  return target;
}

size_t PlanSpecificationStartActionsUnion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanSpecificationStartActionsUnion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (PlanSpecificationStartActionsUnion__case()) {
    // .IMC_DCCL.SetEntityParameters ep = 1;
    case kEp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.PlanSpecificationStartActionsUnion__.ep_);
      break;
    }
    case PLANSPECIFICATIONSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanSpecificationStartActionsUnion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanSpecificationStartActionsUnion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanSpecificationStartActionsUnion::GetClassData() const { return &_class_data_; }


void PlanSpecificationStartActionsUnion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanSpecificationStartActionsUnion*>(&to_msg);
  auto& from = static_cast<const PlanSpecificationStartActionsUnion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanSpecificationStartActionsUnion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.PlanSpecificationStartActionsUnion__case()) {
    case kEp: {
      _this->_internal_mutable_ep()->::IMC_DCCL::SetEntityParameters::MergeFrom(
          from._internal_ep());
      break;
    }
    case PLANSPECIFICATIONSTARTACTIONSUNION__NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanSpecificationStartActionsUnion::CopyFrom(const PlanSpecificationStartActionsUnion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanSpecificationStartActionsUnion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanSpecificationStartActionsUnion::IsInitialized() const {
  return true;
}

void PlanSpecificationStartActionsUnion::InternalSwap(PlanSpecificationStartActionsUnion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.PlanSpecificationStartActionsUnion__, other->_impl_.PlanSpecificationStartActionsUnion__);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanSpecificationStartActionsUnion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[21]);
}

// ===================================================================

class PlanSpecificationEndActionsUnion::_Internal {
 public:
  static const ::IMC_DCCL::SetEntityParameters& ep(const PlanSpecificationEndActionsUnion* msg);
};

const ::IMC_DCCL::SetEntityParameters&
PlanSpecificationEndActionsUnion::_Internal::ep(const PlanSpecificationEndActionsUnion* msg) {
  return *msg->_impl_.PlanSpecificationEndActionsUnion__.ep_;
}
void PlanSpecificationEndActionsUnion::set_allocated_ep(::IMC_DCCL::SetEntityParameters* ep) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_PlanSpecificationEndActionsUnion_();
  if (ep) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ep);
    if (message_arena != submessage_arena) {
      ep = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ep, submessage_arena);
    }
    set_has_ep();
    _impl_.PlanSpecificationEndActionsUnion__.ep_ = ep;
  }
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecificationEndActionsUnion.ep)
}
PlanSpecificationEndActionsUnion::PlanSpecificationEndActionsUnion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:IMC_DCCL.PlanSpecificationEndActionsUnion)
}
PlanSpecificationEndActionsUnion::PlanSpecificationEndActionsUnion(const PlanSpecificationEndActionsUnion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PlanSpecificationEndActionsUnion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanSpecificationEndActionsUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_PlanSpecificationEndActionsUnion_();
  switch (from.PlanSpecificationEndActionsUnion__case()) {
    case kEp: {
      _this->_internal_mutable_ep()->::IMC_DCCL::SetEntityParameters::MergeFrom(
          from._internal_ep());
      break;
    }
    case PLANSPECIFICATIONENDACTIONSUNION__NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:IMC_DCCL.PlanSpecificationEndActionsUnion)
}

inline void PlanSpecificationEndActionsUnion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.PlanSpecificationEndActionsUnion__){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_PlanSpecificationEndActionsUnion_();
}

PlanSpecificationEndActionsUnion::~PlanSpecificationEndActionsUnion() {
  // @@protoc_insertion_point(destructor:IMC_DCCL.PlanSpecificationEndActionsUnion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PlanSpecificationEndActionsUnion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_PlanSpecificationEndActionsUnion_()) {
    clear_PlanSpecificationEndActionsUnion_();
  }
}

void PlanSpecificationEndActionsUnion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PlanSpecificationEndActionsUnion::clear_PlanSpecificationEndActionsUnion_() {
// @@protoc_insertion_point(one_of_clear_start:IMC_DCCL.PlanSpecificationEndActionsUnion)
  switch (PlanSpecificationEndActionsUnion__case()) {
    case kEp: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.PlanSpecificationEndActionsUnion__.ep_;
      }
      break;
    }
    case PLANSPECIFICATIONENDACTIONSUNION__NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = PLANSPECIFICATIONENDACTIONSUNION__NOT_SET;
}


void PlanSpecificationEndActionsUnion::Clear() {
// @@protoc_insertion_point(message_clear_start:IMC_DCCL.PlanSpecificationEndActionsUnion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_PlanSpecificationEndActionsUnion_();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PlanSpecificationEndActionsUnion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .IMC_DCCL.SetEntityParameters ep = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_ep(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PlanSpecificationEndActionsUnion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMC_DCCL.PlanSpecificationEndActionsUnion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .IMC_DCCL.SetEntityParameters ep = 1;
  if (_internal_has_ep()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::ep(this),
        _Internal::ep(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMC_DCCL.PlanSpecificationEndActionsUnion)
  return target;
}

size_t PlanSpecificationEndActionsUnion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMC_DCCL.PlanSpecificationEndActionsUnion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (PlanSpecificationEndActionsUnion__case()) {
    // .IMC_DCCL.SetEntityParameters ep = 1;
    case kEp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.PlanSpecificationEndActionsUnion__.ep_);
      break;
    }
    case PLANSPECIFICATIONENDACTIONSUNION__NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PlanSpecificationEndActionsUnion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PlanSpecificationEndActionsUnion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PlanSpecificationEndActionsUnion::GetClassData() const { return &_class_data_; }


void PlanSpecificationEndActionsUnion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PlanSpecificationEndActionsUnion*>(&to_msg);
  auto& from = static_cast<const PlanSpecificationEndActionsUnion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:IMC_DCCL.PlanSpecificationEndActionsUnion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.PlanSpecificationEndActionsUnion__case()) {
    case kEp: {
      _this->_internal_mutable_ep()->::IMC_DCCL::SetEntityParameters::MergeFrom(
          from._internal_ep());
      break;
    }
    case PLANSPECIFICATIONENDACTIONSUNION__NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PlanSpecificationEndActionsUnion::CopyFrom(const PlanSpecificationEndActionsUnion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMC_DCCL.PlanSpecificationEndActionsUnion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlanSpecificationEndActionsUnion::IsInitialized() const {
  return true;
}

void PlanSpecificationEndActionsUnion::InternalSwap(PlanSpecificationEndActionsUnion* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.PlanSpecificationEndActionsUnion__, other->_impl_.PlanSpecificationEndActionsUnion__);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata PlanSpecificationEndActionsUnion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_IMC_5fDCCL_2eproto_getter, &descriptor_table_IMC_5fDCCL_2eproto_once,
      file_level_metadata_IMC_5fDCCL_2eproto[22]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace IMC_DCCL
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::IMC_DCCL::ProfileSample*
Arena::CreateMaybeMessage< ::IMC_DCCL::ProfileSample >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::ProfileSample >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::StationKeeping*
Arena::CreateMaybeMessage< ::IMC_DCCL::StationKeeping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::StationKeeping >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::FollowPath*
Arena::CreateMaybeMessage< ::IMC_DCCL::FollowPath >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::FollowPath >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::Goto*
Arena::CreateMaybeMessage< ::IMC_DCCL::Goto >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::Goto >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::ParameterValue*
Arena::CreateMaybeMessage< ::IMC_DCCL::ParameterValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::ParameterValue >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PathPoint*
Arena::CreateMaybeMessage< ::IMC_DCCL::PathPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PathPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::Maneuver*
Arena::CreateMaybeMessage< ::IMC_DCCL::Maneuver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::Maneuver >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::EntityParameter*
Arena::CreateMaybeMessage< ::IMC_DCCL::EntityParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::EntityParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::SetEntityParameters*
Arena::CreateMaybeMessage< ::IMC_DCCL::SetEntityParameters >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::SetEntityParameters >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::ManeuverIDCombined*
Arena::CreateMaybeMessage< ::IMC_DCCL::ManeuverIDCombined >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::ManeuverIDCombined >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::ManeuverID*
Arena::CreateMaybeMessage< ::IMC_DCCL::ManeuverID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::ManeuverID >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::TransitionCondition*
Arena::CreateMaybeMessage< ::IMC_DCCL::TransitionCondition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::TransitionCondition >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::Loiter*
Arena::CreateMaybeMessage< ::IMC_DCCL::Loiter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::Loiter >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanManeuverStartActionsUnion*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanManeuverStartActionsUnion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanManeuverStartActionsUnion >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanManeuver*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanManeuver >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanManeuver >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanTransition*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanTransition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanTransition >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::VerticalProfile*
Arena::CreateMaybeMessage< ::IMC_DCCL::VerticalProfile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::VerticalProfile >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::EstimatedState*
Arena::CreateMaybeMessage< ::IMC_DCCL::EstimatedState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::EstimatedState >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanSpecification*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanSpecification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanSpecification >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanDB*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanDB >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanDB >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanDBArgUnion*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanDBArgUnion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanDBArgUnion >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanSpecificationStartActionsUnion*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanSpecificationStartActionsUnion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanSpecificationStartActionsUnion >(arena);
}
template<> PROTOBUF_NOINLINE ::IMC_DCCL::PlanSpecificationEndActionsUnion*
Arena::CreateMaybeMessage< ::IMC_DCCL::PlanSpecificationEndActionsUnion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMC_DCCL::PlanSpecificationEndActionsUnion >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
