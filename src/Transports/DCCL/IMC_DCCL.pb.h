// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IMC_DCCL.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_IMC_5fDCCL_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_IMC_5fDCCL_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dccl/option_extensions.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_IMC_5fDCCL_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_IMC_5fDCCL_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_IMC_5fDCCL_2eproto;
namespace IMC_DCCL {
class EntityParameter;
struct EntityParameterDefaultTypeInternal;
extern EntityParameterDefaultTypeInternal _EntityParameter_default_instance_;
class EntityParameters;
struct EntityParametersDefaultTypeInternal;
extern EntityParametersDefaultTypeInternal _EntityParameters_default_instance_;
class EstimatedState;
struct EstimatedStateDefaultTypeInternal;
extern EstimatedStateDefaultTypeInternal _EstimatedState_default_instance_;
class FollowPath;
struct FollowPathDefaultTypeInternal;
extern FollowPathDefaultTypeInternal _FollowPath_default_instance_;
class Goto;
struct GotoDefaultTypeInternal;
extern GotoDefaultTypeInternal _Goto_default_instance_;
class Header;
struct HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Loiter;
struct LoiterDefaultTypeInternal;
extern LoiterDefaultTypeInternal _Loiter_default_instance_;
class Maneuver;
struct ManeuverDefaultTypeInternal;
extern ManeuverDefaultTypeInternal _Maneuver_default_instance_;
class ManeuverID;
struct ManeuverIDDefaultTypeInternal;
extern ManeuverIDDefaultTypeInternal _ManeuverID_default_instance_;
class ParameterValue;
struct ParameterValueDefaultTypeInternal;
extern ParameterValueDefaultTypeInternal _ParameterValue_default_instance_;
class PathPoint;
struct PathPointDefaultTypeInternal;
extern PathPointDefaultTypeInternal _PathPoint_default_instance_;
class PlanManeuver;
struct PlanManeuverDefaultTypeInternal;
extern PlanManeuverDefaultTypeInternal _PlanManeuver_default_instance_;
class PlanSpecification;
struct PlanSpecificationDefaultTypeInternal;
extern PlanSpecificationDefaultTypeInternal _PlanSpecification_default_instance_;
class PlanTransition;
struct PlanTransitionDefaultTypeInternal;
extern PlanTransitionDefaultTypeInternal _PlanTransition_default_instance_;
class PlanVariable;
struct PlanVariableDefaultTypeInternal;
extern PlanVariableDefaultTypeInternal _PlanVariable_default_instance_;
class StationKeeping;
struct StationKeepingDefaultTypeInternal;
extern StationKeepingDefaultTypeInternal _StationKeeping_default_instance_;
}  // namespace IMC_DCCL
PROTOBUF_NAMESPACE_OPEN
template<> ::IMC_DCCL::EntityParameter* Arena::CreateMaybeMessage<::IMC_DCCL::EntityParameter>(Arena*);
template<> ::IMC_DCCL::EntityParameters* Arena::CreateMaybeMessage<::IMC_DCCL::EntityParameters>(Arena*);
template<> ::IMC_DCCL::EstimatedState* Arena::CreateMaybeMessage<::IMC_DCCL::EstimatedState>(Arena*);
template<> ::IMC_DCCL::FollowPath* Arena::CreateMaybeMessage<::IMC_DCCL::FollowPath>(Arena*);
template<> ::IMC_DCCL::Goto* Arena::CreateMaybeMessage<::IMC_DCCL::Goto>(Arena*);
template<> ::IMC_DCCL::Header* Arena::CreateMaybeMessage<::IMC_DCCL::Header>(Arena*);
template<> ::IMC_DCCL::Loiter* Arena::CreateMaybeMessage<::IMC_DCCL::Loiter>(Arena*);
template<> ::IMC_DCCL::Maneuver* Arena::CreateMaybeMessage<::IMC_DCCL::Maneuver>(Arena*);
template<> ::IMC_DCCL::ManeuverID* Arena::CreateMaybeMessage<::IMC_DCCL::ManeuverID>(Arena*);
template<> ::IMC_DCCL::ParameterValue* Arena::CreateMaybeMessage<::IMC_DCCL::ParameterValue>(Arena*);
template<> ::IMC_DCCL::PathPoint* Arena::CreateMaybeMessage<::IMC_DCCL::PathPoint>(Arena*);
template<> ::IMC_DCCL::PlanManeuver* Arena::CreateMaybeMessage<::IMC_DCCL::PlanManeuver>(Arena*);
template<> ::IMC_DCCL::PlanSpecification* Arena::CreateMaybeMessage<::IMC_DCCL::PlanSpecification>(Arena*);
template<> ::IMC_DCCL::PlanTransition* Arena::CreateMaybeMessage<::IMC_DCCL::PlanTransition>(Arena*);
template<> ::IMC_DCCL::PlanVariable* Arena::CreateMaybeMessage<::IMC_DCCL::PlanVariable>(Arena*);
template<> ::IMC_DCCL::StationKeeping* Arena::CreateMaybeMessage<::IMC_DCCL::StationKeeping>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace IMC_DCCL {

enum ZUnits : int {
  NONE_ZU = 0,
  DEPTH = 1,
  ALTITUDE = 2,
  HEIGHT = 3,
  ZUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ZUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ZUnits_IsValid(int value);
constexpr ZUnits ZUnits_MIN = NONE_ZU;
constexpr ZUnits ZUnits_MAX = HEIGHT;
constexpr int ZUnits_ARRAYSIZE = ZUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ZUnits_descriptor();
template<typename T>
inline const std::string& ZUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ZUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ZUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ZUnits_descriptor(), enum_t_value);
}
inline bool ZUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ZUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ZUnits>(
    ZUnits_descriptor(), name, value);
}
enum SpeedUnits : int {
  METERS_PS = 0,
  RPM = 1,
  PERCENTAGE = 2,
  SpeedUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SpeedUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SpeedUnits_IsValid(int value);
constexpr SpeedUnits SpeedUnits_MIN = METERS_PS;
constexpr SpeedUnits SpeedUnits_MAX = PERCENTAGE;
constexpr int SpeedUnits_ARRAYSIZE = SpeedUnits_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SpeedUnits_descriptor();
template<typename T>
inline const std::string& SpeedUnits_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SpeedUnits>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SpeedUnits_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SpeedUnits_descriptor(), enum_t_value);
}
inline bool SpeedUnits_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SpeedUnits* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SpeedUnits>(
    SpeedUnits_descriptor(), name, value);
}
enum LoiterType : int {
  DEFAULT = 0,
  CIRCULAR = 1,
  RACETRACK = 2,
  EIGHT = 3,
  HOVER = 4,
  LoiterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LoiterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LoiterType_IsValid(int value);
constexpr LoiterType LoiterType_MIN = DEFAULT;
constexpr LoiterType LoiterType_MAX = HOVER;
constexpr int LoiterType_ARRAYSIZE = LoiterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LoiterType_descriptor();
template<typename T>
inline const std::string& LoiterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LoiterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LoiterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LoiterType_descriptor(), enum_t_value);
}
inline bool LoiterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoiterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LoiterType>(
    LoiterType_descriptor(), name, value);
}
enum DirectionType : int {
  VDEP = 0,
  CLOCKW = 1,
  CCLOCKW = 2,
  IWINDCURR = 3,
  DirectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DirectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DirectionType_IsValid(int value);
constexpr DirectionType DirectionType_MIN = VDEP;
constexpr DirectionType DirectionType_MAX = IWINDCURR;
constexpr int DirectionType_ARRAYSIZE = DirectionType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DirectionType_descriptor();
template<typename T>
inline const std::string& DirectionType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DirectionType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DirectionType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DirectionType_descriptor(), enum_t_value);
}
inline bool DirectionType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DirectionType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DirectionType>(
    DirectionType_descriptor(), name, value);
}
enum ManeuverType : int {
  GOTO = 0,
  FOLLOWPATH = 1,
  LOITER = 2,
  STATIONKEEPING = 3,
  ManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ManeuverType_IsValid(int value);
constexpr ManeuverType ManeuverType_MIN = GOTO;
constexpr ManeuverType ManeuverType_MAX = STATIONKEEPING;
constexpr int ManeuverType_ARRAYSIZE = ManeuverType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ManeuverType_descriptor();
template<typename T>
inline const std::string& ManeuverType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ManeuverType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ManeuverType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ManeuverType_descriptor(), enum_t_value);
}
inline bool ManeuverType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ManeuverType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ManeuverType>(
    ManeuverType_descriptor(), name, value);
}
enum ParameterName : int {
  NONE_PN = 0,
  ACTIVE = 1,
  BOTTOM_TRACK_MINIMUM_DEPTH = 2,
  HIGH_FREQ_CHANNELS = 3,
  HIGH_FREQ_RANGE = 4,
  LOW_FREQ_CHANNELS = 5,
  LOW_FREQ_RANGE = 6,
  RANGE_MULTIPLIER = 7,
  STROBE_DELAY = 8,
  SHUTTER_VALUE = 9,
  RANGE = 10,
  FREQUENCY = 11,
  THRUSTER_ALWAYS_ON = 12,
  SAMPLE_TIME_DURATION = 13,
  PERIODICITY_OF_DATA_SAMPLING = 14,
  ParameterName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParameterName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParameterName_IsValid(int value);
constexpr ParameterName ParameterName_MIN = NONE_PN;
constexpr ParameterName ParameterName_MAX = PERIODICITY_OF_DATA_SAMPLING;
constexpr int ParameterName_ARRAYSIZE = ParameterName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParameterName_descriptor();
template<typename T>
inline const std::string& ParameterName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParameterName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParameterName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParameterName_descriptor(), enum_t_value);
}
inline bool ParameterName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParameterName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParameterName>(
    ParameterName_descriptor(), name, value);
}
enum ParamValue : int {
  NONE_PV = 0,
  TRUE = 1,
  FALSE = 2,
  BOTH = 3,
  ParamValue_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ParamValue_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ParamValue_IsValid(int value);
constexpr ParamValue ParamValue_MIN = NONE_PV;
constexpr ParamValue ParamValue_MAX = BOTH;
constexpr int ParamValue_ARRAYSIZE = ParamValue_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ParamValue_descriptor();
template<typename T>
inline const std::string& ParamValue_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ParamValue>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ParamValue_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ParamValue_descriptor(), enum_t_value);
}
inline bool ParamValue_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ParamValue* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ParamValue>(
    ParamValue_descriptor(), name, value);
}
enum EntityName : int {
  NONE_EN = 0,
  PATH_CONTROL = 1,
  RANGER = 2,
  ACOUSTIC_MODEM = 3,
  SIDESCAN = 4,
  CAMERA = 5,
  MULTIBEAM = 6,
  FLUOROMETERS = 7,
  ADCP = 8,
  DISSOLVED_OXYGEN = 9,
  CTD = 10,
  HEADING_CONTROLLER = 11,
  EntityName_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  EntityName_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool EntityName_IsValid(int value);
constexpr EntityName EntityName_MIN = NONE_EN;
constexpr EntityName EntityName_MAX = HEADING_CONTROLLER;
constexpr int EntityName_ARRAYSIZE = EntityName_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EntityName_descriptor();
template<typename T>
inline const std::string& EntityName_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EntityName>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EntityName_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EntityName_descriptor(), enum_t_value);
}
inline bool EntityName_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EntityName* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EntityName>(
    EntityName_descriptor(), name, value);
}
enum TransitionCondition : int {
  NONE_TC = 0,
  MANEUVERISDONE = 1,
  TransitionCondition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TransitionCondition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TransitionCondition_IsValid(int value);
constexpr TransitionCondition TransitionCondition_MIN = NONE_TC;
constexpr TransitionCondition TransitionCondition_MAX = MANEUVERISDONE;
constexpr int TransitionCondition_ARRAYSIZE = TransitionCondition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransitionCondition_descriptor();
template<typename T>
inline const std::string& TransitionCondition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransitionCondition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransitionCondition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransitionCondition_descriptor(), enum_t_value);
}
inline bool TransitionCondition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransitionCondition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransitionCondition>(
    TransitionCondition_descriptor(), name, value);
}
enum Type : int {
  BOOLEAN = 0,
  NUMBER = 1,
  TEXT = 2,
  MESSAGE = 3,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool Type_IsValid(int value);
constexpr Type Type_MIN = BOOLEAN;
constexpr Type Type_MAX = MESSAGE;
constexpr int Type_ARRAYSIZE = Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Type_descriptor();
template<typename T>
inline const std::string& Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Type_descriptor(), enum_t_value);
}
inline bool Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
enum AccessType : int {
  INPUT = 0,
  OUTPUT = 1,
  LOCAL = 2,
  AccessType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  AccessType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool AccessType_IsValid(int value);
constexpr AccessType AccessType_MIN = INPUT;
constexpr AccessType AccessType_MAX = LOCAL;
constexpr int AccessType_ARRAYSIZE = AccessType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* AccessType_descriptor();
template<typename T>
inline const std::string& AccessType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AccessType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AccessType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    AccessType_descriptor(), enum_t_value);
}
inline bool AccessType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AccessType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<AccessType>(
    AccessType_descriptor(), name, value);
}
// ===================================================================

class EstimatedState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.EstimatedState) */ {
 public:
  inline EstimatedState() : EstimatedState(nullptr) {}
  ~EstimatedState() override;
  explicit PROTOBUF_CONSTEXPR EstimatedState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EstimatedState(const EstimatedState& from);
  EstimatedState(EstimatedState&& from) noexcept
    : EstimatedState() {
    *this = ::std::move(from);
  }

  inline EstimatedState& operator=(const EstimatedState& from) {
    CopyFrom(from);
    return *this;
  }
  inline EstimatedState& operator=(EstimatedState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EstimatedState& default_instance() {
    return *internal_default_instance();
  }
  static inline const EstimatedState* internal_default_instance() {
    return reinterpret_cast<const EstimatedState*>(
               &_EstimatedState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(EstimatedState& a, EstimatedState& b) {
    a.Swap(&b);
  }
  inline void Swap(EstimatedState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EstimatedState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EstimatedState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EstimatedState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EstimatedState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EstimatedState& from) {
    EstimatedState::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstimatedState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.EstimatedState";
  }
  protected:
  explicit EstimatedState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kHeightFieldNumber = 3,
    kXFieldNumber = 4,
    kYFieldNumber = 5,
    kZFieldNumber = 6,
    kPhiFieldNumber = 7,
    kThetaFieldNumber = 8,
    kPsiFieldNumber = 9,
    kUFieldNumber = 10,
    kVFieldNumber = 11,
    kWFieldNumber = 12,
    kVxFieldNumber = 13,
    kVyFieldNumber = 14,
    kVzFieldNumber = 15,
    kPFieldNumber = 16,
    kQFieldNumber = 17,
    kRFieldNumber = 18,
    kDepthFieldNumber = 19,
    kAltitudeFieldNumber = 20,
  };
  // float lat = 1 [(.dccl.field) = {
  void clear_lat();
  float lat() const;
  void set_lat(float value);
  private:
  float _internal_lat() const;
  void _internal_set_lat(float value);
  public:

  // float lon = 2 [(.dccl.field) = {
  void clear_lon();
  float lon() const;
  void set_lon(float value);
  private:
  float _internal_lon() const;
  void _internal_set_lon(float value);
  public:

  // float height = 3 [(.dccl.field) = {
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // float x = 4 [(.dccl.field) = {
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 5 [(.dccl.field) = {
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 6 [(.dccl.field) = {
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // float phi = 7 [(.dccl.field) = {
  void clear_phi();
  float phi() const;
  void set_phi(float value);
  private:
  float _internal_phi() const;
  void _internal_set_phi(float value);
  public:

  // float theta = 8 [(.dccl.field) = {
  void clear_theta();
  float theta() const;
  void set_theta(float value);
  private:
  float _internal_theta() const;
  void _internal_set_theta(float value);
  public:

  // float psi = 9 [(.dccl.field) = {
  void clear_psi();
  float psi() const;
  void set_psi(float value);
  private:
  float _internal_psi() const;
  void _internal_set_psi(float value);
  public:

  // float u = 10 [(.dccl.field) = {
  void clear_u();
  float u() const;
  void set_u(float value);
  private:
  float _internal_u() const;
  void _internal_set_u(float value);
  public:

  // float v = 11 [(.dccl.field) = {
  void clear_v();
  float v() const;
  void set_v(float value);
  private:
  float _internal_v() const;
  void _internal_set_v(float value);
  public:

  // float w = 12 [(.dccl.field) = {
  void clear_w();
  float w() const;
  void set_w(float value);
  private:
  float _internal_w() const;
  void _internal_set_w(float value);
  public:

  // float vx = 13 [(.dccl.field) = {
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // float vy = 14 [(.dccl.field) = {
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // float vz = 15 [(.dccl.field) = {
  void clear_vz();
  float vz() const;
  void set_vz(float value);
  private:
  float _internal_vz() const;
  void _internal_set_vz(float value);
  public:

  // float p = 16 [(.dccl.field) = {
  void clear_p();
  float p() const;
  void set_p(float value);
  private:
  float _internal_p() const;
  void _internal_set_p(float value);
  public:

  // float q = 17 [(.dccl.field) = {
  void clear_q();
  float q() const;
  void set_q(float value);
  private:
  float _internal_q() const;
  void _internal_set_q(float value);
  public:

  // float r = 18 [(.dccl.field) = {
  void clear_r();
  float r() const;
  void set_r(float value);
  private:
  float _internal_r() const;
  void _internal_set_r(float value);
  public:

  // float depth = 19 [(.dccl.field) = {
  void clear_depth();
  float depth() const;
  void set_depth(float value);
  private:
  float _internal_depth() const;
  void _internal_set_depth(float value);
  public:

  // float altitude = 20 [(.dccl.field) = {
  void clear_altitude();
  float altitude() const;
  void set_altitude(float value);
  private:
  float _internal_altitude() const;
  void _internal_set_altitude(float value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.EstimatedState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float lat_;
    float lon_;
    float height_;
    float x_;
    float y_;
    float z_;
    float phi_;
    float theta_;
    float psi_;
    float u_;
    float v_;
    float w_;
    float vx_;
    float vy_;
    float vz_;
    float p_;
    float q_;
    float r_;
    float depth_;
    float altitude_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class Goto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Goto) */ {
 public:
  inline Goto() : Goto(nullptr) {}
  ~Goto() override;
  explicit PROTOBUF_CONSTEXPR Goto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Goto(const Goto& from);
  Goto(Goto&& from) noexcept
    : Goto() {
    *this = ::std::move(from);
  }

  inline Goto& operator=(const Goto& from) {
    CopyFrom(from);
    return *this;
  }
  inline Goto& operator=(Goto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Goto& default_instance() {
    return *internal_default_instance();
  }
  static inline const Goto* internal_default_instance() {
    return reinterpret_cast<const Goto*>(
               &_Goto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Goto& a, Goto& b) {
    a.Swap(&b);
  }
  inline void Swap(Goto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Goto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Goto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Goto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Goto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Goto& from) {
    Goto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Goto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.Goto";
  }
  protected:
  explicit Goto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutFieldNumber = 1,
    kLatFieldNumber = 2,
    kLonFieldNumber = 3,
    kZFieldNumber = 4,
    kZUnitsFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kSpeedUnitsFieldNumber = 7,
    kRollFieldNumber = 8,
    kPitchFieldNumber = 9,
    kYawFieldNumber = 10,
  };
  // int32 timeout = 1 [(.dccl.field) = {
  void clear_timeout();
  int32_t timeout() const;
  void set_timeout(int32_t value);
  private:
  int32_t _internal_timeout() const;
  void _internal_set_timeout(int32_t value);
  public:

  // float lat = 2 [(.dccl.field) = {
  void clear_lat();
  float lat() const;
  void set_lat(float value);
  private:
  float _internal_lat() const;
  void _internal_set_lat(float value);
  public:

  // float lon = 3 [(.dccl.field) = {
  void clear_lon();
  float lon() const;
  void set_lon(float value);
  private:
  float _internal_lon() const;
  void _internal_set_lon(float value);
  public:

  // float z = 4 [(.dccl.field) = {
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // .IMC_DCCL.ZUnits z_units = 5;
  void clear_z_units();
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);
  private:
  ::IMC_DCCL::ZUnits _internal_z_units() const;
  void _internal_set_z_units(::IMC_DCCL::ZUnits value);
  public:

  // float speed = 6 [(.dccl.field) = {
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  void clear_speed_units();
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);
  private:
  ::IMC_DCCL::SpeedUnits _internal_speed_units() const;
  void _internal_set_speed_units(::IMC_DCCL::SpeedUnits value);
  public:

  // float roll = 8 [(.dccl.field) = {
  void clear_roll();
  float roll() const;
  void set_roll(float value);
  private:
  float _internal_roll() const;
  void _internal_set_roll(float value);
  public:

  // float pitch = 9 [(.dccl.field) = {
  void clear_pitch();
  float pitch() const;
  void set_pitch(float value);
  private:
  float _internal_pitch() const;
  void _internal_set_pitch(float value);
  public:

  // float yaw = 10 [(.dccl.field) = {
  void clear_yaw();
  float yaw() const;
  void set_yaw(float value);
  private:
  float _internal_yaw() const;
  void _internal_set_yaw(float value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.Goto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t timeout_;
    float lat_;
    float lon_;
    float z_;
    int z_units_;
    float speed_;
    int speed_units_;
    float roll_;
    float pitch_;
    float yaw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class StationKeeping final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.StationKeeping) */ {
 public:
  inline StationKeeping() : StationKeeping(nullptr) {}
  ~StationKeeping() override;
  explicit PROTOBUF_CONSTEXPR StationKeeping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StationKeeping(const StationKeeping& from);
  StationKeeping(StationKeeping&& from) noexcept
    : StationKeeping() {
    *this = ::std::move(from);
  }

  inline StationKeeping& operator=(const StationKeeping& from) {
    CopyFrom(from);
    return *this;
  }
  inline StationKeeping& operator=(StationKeeping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StationKeeping& default_instance() {
    return *internal_default_instance();
  }
  static inline const StationKeeping* internal_default_instance() {
    return reinterpret_cast<const StationKeeping*>(
               &_StationKeeping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StationKeeping& a, StationKeeping& b) {
    a.Swap(&b);
  }
  inline void Swap(StationKeeping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StationKeeping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StationKeeping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StationKeeping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StationKeeping& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StationKeeping& from) {
    StationKeeping::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StationKeeping* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.StationKeeping";
  }
  protected:
  explicit StationKeeping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLatFieldNumber = 1,
    kLonFieldNumber = 2,
    kZFieldNumber = 3,
    kZUnitsFieldNumber = 4,
    kRadiusFieldNumber = 5,
    kDurationFieldNumber = 6,
    kSpeedFieldNumber = 7,
    kSpeedUnitsFieldNumber = 8,
  };
  // float lat = 1 [(.dccl.field) = {
  void clear_lat();
  float lat() const;
  void set_lat(float value);
  private:
  float _internal_lat() const;
  void _internal_set_lat(float value);
  public:

  // float lon = 2 [(.dccl.field) = {
  void clear_lon();
  float lon() const;
  void set_lon(float value);
  private:
  float _internal_lon() const;
  void _internal_set_lon(float value);
  public:

  // float z = 3 [(.dccl.field) = {
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // .IMC_DCCL.ZUnits z_units = 4;
  void clear_z_units();
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);
  private:
  ::IMC_DCCL::ZUnits _internal_z_units() const;
  void _internal_set_z_units(::IMC_DCCL::ZUnits value);
  public:

  // float radius = 5 [(.dccl.field) = {
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // int32 duration = 6 [(.dccl.field) = {
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // float speed = 7 [(.dccl.field) = {
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  void clear_speed_units();
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);
  private:
  ::IMC_DCCL::SpeedUnits _internal_speed_units() const;
  void _internal_set_speed_units(::IMC_DCCL::SpeedUnits value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.StationKeeping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float lat_;
    float lon_;
    float z_;
    int z_units_;
    float radius_;
    int32_t duration_;
    float speed_;
    int speed_units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class FollowPath final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.FollowPath) */ {
 public:
  inline FollowPath() : FollowPath(nullptr) {}
  ~FollowPath() override;
  explicit PROTOBUF_CONSTEXPR FollowPath(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FollowPath(const FollowPath& from);
  FollowPath(FollowPath&& from) noexcept
    : FollowPath() {
    *this = ::std::move(from);
  }

  inline FollowPath& operator=(const FollowPath& from) {
    CopyFrom(from);
    return *this;
  }
  inline FollowPath& operator=(FollowPath&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FollowPath& default_instance() {
    return *internal_default_instance();
  }
  static inline const FollowPath* internal_default_instance() {
    return reinterpret_cast<const FollowPath*>(
               &_FollowPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(FollowPath& a, FollowPath& b) {
    a.Swap(&b);
  }
  inline void Swap(FollowPath* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FollowPath* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FollowPath* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FollowPath>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FollowPath& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FollowPath& from) {
    FollowPath::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowPath* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.FollowPath";
  }
  protected:
  explicit FollowPath(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPointsFieldNumber = 8,
    kTimeoutFieldNumber = 1,
    kLatFieldNumber = 2,
    kLonFieldNumber = 3,
    kZFieldNumber = 4,
    kZUnitsFieldNumber = 5,
    kSpeedFieldNumber = 6,
    kSpeedUnitsFieldNumber = 7,
  };
  // repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
  int points_size() const;
  private:
  int _internal_points_size() const;
  public:
  void clear_points();
  ::IMC_DCCL::PathPoint* mutable_points(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PathPoint >*
      mutable_points();
  private:
  const ::IMC_DCCL::PathPoint& _internal_points(int index) const;
  ::IMC_DCCL::PathPoint* _internal_add_points();
  public:
  const ::IMC_DCCL::PathPoint& points(int index) const;
  ::IMC_DCCL::PathPoint* add_points();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PathPoint >&
      points() const;

  // int32 timeout = 1 [(.dccl.field) = {
  void clear_timeout();
  int32_t timeout() const;
  void set_timeout(int32_t value);
  private:
  int32_t _internal_timeout() const;
  void _internal_set_timeout(int32_t value);
  public:

  // float lat = 2 [(.dccl.field) = {
  void clear_lat();
  float lat() const;
  void set_lat(float value);
  private:
  float _internal_lat() const;
  void _internal_set_lat(float value);
  public:

  // float lon = 3 [(.dccl.field) = {
  void clear_lon();
  float lon() const;
  void set_lon(float value);
  private:
  float _internal_lon() const;
  void _internal_set_lon(float value);
  public:

  // float z = 4 [(.dccl.field) = {
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // .IMC_DCCL.ZUnits z_units = 5;
  void clear_z_units();
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);
  private:
  ::IMC_DCCL::ZUnits _internal_z_units() const;
  void _internal_set_z_units(::IMC_DCCL::ZUnits value);
  public:

  // float speed = 6 [(.dccl.field) = {
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  void clear_speed_units();
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);
  private:
  ::IMC_DCCL::SpeedUnits _internal_speed_units() const;
  void _internal_set_speed_units(::IMC_DCCL::SpeedUnits value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.FollowPath)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PathPoint > points_;
    int32_t timeout_;
    float lat_;
    float lon_;
    float z_;
    int z_units_;
    float speed_;
    int speed_units_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class Loiter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Loiter) */ {
 public:
  inline Loiter() : Loiter(nullptr) {}
  ~Loiter() override;
  explicit PROTOBUF_CONSTEXPR Loiter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Loiter(const Loiter& from);
  Loiter(Loiter&& from) noexcept
    : Loiter() {
    *this = ::std::move(from);
  }

  inline Loiter& operator=(const Loiter& from) {
    CopyFrom(from);
    return *this;
  }
  inline Loiter& operator=(Loiter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Loiter& default_instance() {
    return *internal_default_instance();
  }
  static inline const Loiter* internal_default_instance() {
    return reinterpret_cast<const Loiter*>(
               &_Loiter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Loiter& a, Loiter& b) {
    a.Swap(&b);
  }
  inline void Swap(Loiter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Loiter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Loiter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Loiter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Loiter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Loiter& from) {
    Loiter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Loiter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.Loiter";
  }
  protected:
  explicit Loiter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeoutFieldNumber = 1,
    kLatFieldNumber = 2,
    kLonFieldNumber = 3,
    kZFieldNumber = 4,
    kZUnitsFieldNumber = 5,
    kDurationFieldNumber = 6,
    kSpeedFieldNumber = 7,
    kSpeedUnitsFieldNumber = 8,
    kTypeFieldNumber = 9,
    kRadiusFieldNumber = 10,
    kLengthFieldNumber = 11,
    kBearingFieldNumber = 12,
    kDirectionFieldNumber = 13,
  };
  // int32 timeout = 1 [(.dccl.field) = {
  void clear_timeout();
  int32_t timeout() const;
  void set_timeout(int32_t value);
  private:
  int32_t _internal_timeout() const;
  void _internal_set_timeout(int32_t value);
  public:

  // float lat = 2 [(.dccl.field) = {
  void clear_lat();
  float lat() const;
  void set_lat(float value);
  private:
  float _internal_lat() const;
  void _internal_set_lat(float value);
  public:

  // float lon = 3 [(.dccl.field) = {
  void clear_lon();
  float lon() const;
  void set_lon(float value);
  private:
  float _internal_lon() const;
  void _internal_set_lon(float value);
  public:

  // float z = 4 [(.dccl.field) = {
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // .IMC_DCCL.ZUnits z_units = 5;
  void clear_z_units();
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);
  private:
  ::IMC_DCCL::ZUnits _internal_z_units() const;
  void _internal_set_z_units(::IMC_DCCL::ZUnits value);
  public:

  // int32 duration = 6 [(.dccl.field) = {
  void clear_duration();
  int32_t duration() const;
  void set_duration(int32_t value);
  private:
  int32_t _internal_duration() const;
  void _internal_set_duration(int32_t value);
  public:

  // float speed = 7 [(.dccl.field) = {
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  void clear_speed_units();
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);
  private:
  ::IMC_DCCL::SpeedUnits _internal_speed_units() const;
  void _internal_set_speed_units(::IMC_DCCL::SpeedUnits value);
  public:

  // .IMC_DCCL.LoiterType type = 9;
  void clear_type();
  ::IMC_DCCL::LoiterType type() const;
  void set_type(::IMC_DCCL::LoiterType value);
  private:
  ::IMC_DCCL::LoiterType _internal_type() const;
  void _internal_set_type(::IMC_DCCL::LoiterType value);
  public:

  // float radius = 10 [(.dccl.field) = {
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // float length = 11 [(.dccl.field) = {
  void clear_length();
  float length() const;
  void set_length(float value);
  private:
  float _internal_length() const;
  void _internal_set_length(float value);
  public:

  // float bearing = 12 [(.dccl.field) = {
  void clear_bearing();
  float bearing() const;
  void set_bearing(float value);
  private:
  float _internal_bearing() const;
  void _internal_set_bearing(float value);
  public:

  // .IMC_DCCL.DirectionType direction = 13;
  void clear_direction();
  ::IMC_DCCL::DirectionType direction() const;
  void set_direction(::IMC_DCCL::DirectionType value);
  private:
  ::IMC_DCCL::DirectionType _internal_direction() const;
  void _internal_set_direction(::IMC_DCCL::DirectionType value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.Loiter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t timeout_;
    float lat_;
    float lon_;
    float z_;
    int z_units_;
    int32_t duration_;
    float speed_;
    int speed_units_;
    int type_;
    float radius_;
    float length_;
    float bearing_;
    int direction_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class PathPoint final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PathPoint) */ {
 public:
  inline PathPoint() : PathPoint(nullptr) {}
  ~PathPoint() override;
  explicit PROTOBUF_CONSTEXPR PathPoint(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PathPoint(const PathPoint& from);
  PathPoint(PathPoint&& from) noexcept
    : PathPoint() {
    *this = ::std::move(from);
  }

  inline PathPoint& operator=(const PathPoint& from) {
    CopyFrom(from);
    return *this;
  }
  inline PathPoint& operator=(PathPoint&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PathPoint& default_instance() {
    return *internal_default_instance();
  }
  static inline const PathPoint* internal_default_instance() {
    return reinterpret_cast<const PathPoint*>(
               &_PathPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PathPoint& a, PathPoint& b) {
    a.Swap(&b);
  }
  inline void Swap(PathPoint* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PathPoint* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PathPoint* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PathPoint>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PathPoint& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PathPoint& from) {
    PathPoint::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathPoint* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.PathPoint";
  }
  protected:
  explicit PathPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1 [(.dccl.field) = {
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2 [(.dccl.field) = {
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3 [(.dccl.field) = {
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PathPoint)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class Maneuver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Maneuver) */ {
 public:
  inline Maneuver() : Maneuver(nullptr) {}
  ~Maneuver() override;
  explicit PROTOBUF_CONSTEXPR Maneuver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Maneuver(const Maneuver& from);
  Maneuver(Maneuver&& from) noexcept
    : Maneuver() {
    *this = ::std::move(from);
  }

  inline Maneuver& operator=(const Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Maneuver& operator=(Maneuver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Maneuver& default_instance() {
    return *internal_default_instance();
  }
  enum ManeuverUnionCase {
    kGotoManeuver = 1,
    kFollowpathManeuver = 2,
    kLoiterManeuver = 3,
    kStationkeepingManeuver = 4,
    MANEUVERUNION_NOT_SET = 0,
  };

  static inline const Maneuver* internal_default_instance() {
    return reinterpret_cast<const Maneuver*>(
               &_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Maneuver& a, Maneuver& b) {
    a.Swap(&b);
  }
  inline void Swap(Maneuver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Maneuver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Maneuver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Maneuver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Maneuver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Maneuver& from) {
    Maneuver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Maneuver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.Maneuver";
  }
  protected:
  explicit Maneuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGotoManeuverFieldNumber = 1,
    kFollowpathManeuverFieldNumber = 2,
    kLoiterManeuverFieldNumber = 3,
    kStationkeepingManeuverFieldNumber = 4,
  };
  // .IMC_DCCL.Goto goto_maneuver = 1;
  bool has_goto_maneuver() const;
  private:
  bool _internal_has_goto_maneuver() const;
  public:
  void clear_goto_maneuver();
  const ::IMC_DCCL::Goto& goto_maneuver() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::Goto* release_goto_maneuver();
  ::IMC_DCCL::Goto* mutable_goto_maneuver();
  void set_allocated_goto_maneuver(::IMC_DCCL::Goto* goto_maneuver);
  private:
  const ::IMC_DCCL::Goto& _internal_goto_maneuver() const;
  ::IMC_DCCL::Goto* _internal_mutable_goto_maneuver();
  public:
  void unsafe_arena_set_allocated_goto_maneuver(
      ::IMC_DCCL::Goto* goto_maneuver);
  ::IMC_DCCL::Goto* unsafe_arena_release_goto_maneuver();

  // .IMC_DCCL.FollowPath followpath_maneuver = 2;
  bool has_followpath_maneuver() const;
  private:
  bool _internal_has_followpath_maneuver() const;
  public:
  void clear_followpath_maneuver();
  const ::IMC_DCCL::FollowPath& followpath_maneuver() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::FollowPath* release_followpath_maneuver();
  ::IMC_DCCL::FollowPath* mutable_followpath_maneuver();
  void set_allocated_followpath_maneuver(::IMC_DCCL::FollowPath* followpath_maneuver);
  private:
  const ::IMC_DCCL::FollowPath& _internal_followpath_maneuver() const;
  ::IMC_DCCL::FollowPath* _internal_mutable_followpath_maneuver();
  public:
  void unsafe_arena_set_allocated_followpath_maneuver(
      ::IMC_DCCL::FollowPath* followpath_maneuver);
  ::IMC_DCCL::FollowPath* unsafe_arena_release_followpath_maneuver();

  // .IMC_DCCL.Loiter loiter_maneuver = 3;
  bool has_loiter_maneuver() const;
  private:
  bool _internal_has_loiter_maneuver() const;
  public:
  void clear_loiter_maneuver();
  const ::IMC_DCCL::Loiter& loiter_maneuver() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::Loiter* release_loiter_maneuver();
  ::IMC_DCCL::Loiter* mutable_loiter_maneuver();
  void set_allocated_loiter_maneuver(::IMC_DCCL::Loiter* loiter_maneuver);
  private:
  const ::IMC_DCCL::Loiter& _internal_loiter_maneuver() const;
  ::IMC_DCCL::Loiter* _internal_mutable_loiter_maneuver();
  public:
  void unsafe_arena_set_allocated_loiter_maneuver(
      ::IMC_DCCL::Loiter* loiter_maneuver);
  ::IMC_DCCL::Loiter* unsafe_arena_release_loiter_maneuver();

  // .IMC_DCCL.StationKeeping stationkeeping_maneuver = 4;
  bool has_stationkeeping_maneuver() const;
  private:
  bool _internal_has_stationkeeping_maneuver() const;
  public:
  void clear_stationkeeping_maneuver();
  const ::IMC_DCCL::StationKeeping& stationkeeping_maneuver() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::StationKeeping* release_stationkeeping_maneuver();
  ::IMC_DCCL::StationKeeping* mutable_stationkeeping_maneuver();
  void set_allocated_stationkeeping_maneuver(::IMC_DCCL::StationKeeping* stationkeeping_maneuver);
  private:
  const ::IMC_DCCL::StationKeeping& _internal_stationkeeping_maneuver() const;
  ::IMC_DCCL::StationKeeping* _internal_mutable_stationkeeping_maneuver();
  public:
  void unsafe_arena_set_allocated_stationkeeping_maneuver(
      ::IMC_DCCL::StationKeeping* stationkeeping_maneuver);
  ::IMC_DCCL::StationKeeping* unsafe_arena_release_stationkeeping_maneuver();

  void clear_ManeuverUnion();
  ManeuverUnionCase ManeuverUnion_case() const;
  // @@protoc_insertion_point(class_scope:IMC_DCCL.Maneuver)
 private:
  class _Internal;
  void set_has_goto_maneuver();
  void set_has_followpath_maneuver();
  void set_has_loiter_maneuver();
  void set_has_stationkeeping_maneuver();

  inline bool has_ManeuverUnion() const;
  inline void clear_has_ManeuverUnion();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ManeuverUnionUnion {
      constexpr ManeuverUnionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::IMC_DCCL::Goto* goto_maneuver_;
      ::IMC_DCCL::FollowPath* followpath_maneuver_;
      ::IMC_DCCL::Loiter* loiter_maneuver_;
      ::IMC_DCCL::StationKeeping* stationkeeping_maneuver_;
    } ManeuverUnion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class ParameterValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.ParameterValue) */ {
 public:
  inline ParameterValue() : ParameterValue(nullptr) {}
  ~ParameterValue() override;
  explicit PROTOBUF_CONSTEXPR ParameterValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParameterValue(const ParameterValue& from);
  ParameterValue(ParameterValue&& from) noexcept
    : ParameterValue() {
    *this = ::std::move(from);
  }

  inline ParameterValue& operator=(const ParameterValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterValue& operator=(ParameterValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParameterValue& default_instance() {
    return *internal_default_instance();
  }
  enum ParameterValueUnionCase {
    kValueNumber = 1,
    kValueString = 2,
    PARAMETERVALUEUNION_NOT_SET = 0,
  };

  static inline const ParameterValue* internal_default_instance() {
    return reinterpret_cast<const ParameterValue*>(
               &_ParameterValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ParameterValue& a, ParameterValue& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ParameterValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ParameterValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ParameterValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ParameterValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ParameterValue& from) {
    ParameterValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.ParameterValue";
  }
  protected:
  explicit ParameterValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueNumberFieldNumber = 1,
    kValueStringFieldNumber = 2,
  };
  // float value_number = 1 [(.dccl.field) = {
  bool has_value_number() const;
  private:
  bool _internal_has_value_number() const;
  public:
  void clear_value_number();
  float value_number() const;
  void set_value_number(float value);
  private:
  float _internal_value_number() const;
  void _internal_set_value_number(float value);
  public:

  // .IMC_DCCL.ParamValue value_string = 2;
  bool has_value_string() const;
  private:
  bool _internal_has_value_string() const;
  public:
  void clear_value_string();
  ::IMC_DCCL::ParamValue value_string() const;
  void set_value_string(::IMC_DCCL::ParamValue value);
  private:
  ::IMC_DCCL::ParamValue _internal_value_string() const;
  void _internal_set_value_string(::IMC_DCCL::ParamValue value);
  public:

  void clear_ParameterValueUnion();
  ParameterValueUnionCase ParameterValueUnion_case() const;
  // @@protoc_insertion_point(class_scope:IMC_DCCL.ParameterValue)
 private:
  class _Internal;
  void set_has_value_number();
  void set_has_value_string();

  inline bool has_ParameterValueUnion() const;
  inline void clear_has_ParameterValueUnion();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ParameterValueUnionUnion {
      constexpr ParameterValueUnionUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float value_number_;
      int value_string_;
    } ParameterValueUnion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class EntityParameter final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.EntityParameter) */ {
 public:
  inline EntityParameter() : EntityParameter(nullptr) {}
  ~EntityParameter() override;
  explicit PROTOBUF_CONSTEXPR EntityParameter(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityParameter(const EntityParameter& from);
  EntityParameter(EntityParameter&& from) noexcept
    : EntityParameter() {
    *this = ::std::move(from);
  }

  inline EntityParameter& operator=(const EntityParameter& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityParameter& operator=(EntityParameter&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityParameter& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityParameter* internal_default_instance() {
    return reinterpret_cast<const EntityParameter*>(
               &_EntityParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EntityParameter& a, EntityParameter& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityParameter* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityParameter* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityParameter* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityParameter>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityParameter& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntityParameter& from) {
    EntityParameter::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityParameter* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.EntityParameter";
  }
  protected:
  explicit EntityParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // .IMC_DCCL.ParameterValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::IMC_DCCL::ParameterValue& value() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::ParameterValue* release_value();
  ::IMC_DCCL::ParameterValue* mutable_value();
  void set_allocated_value(::IMC_DCCL::ParameterValue* value);
  private:
  const ::IMC_DCCL::ParameterValue& _internal_value() const;
  ::IMC_DCCL::ParameterValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::IMC_DCCL::ParameterValue* value);
  ::IMC_DCCL::ParameterValue* unsafe_arena_release_value();

  // .IMC_DCCL.ParameterName name = 1;
  void clear_name();
  ::IMC_DCCL::ParameterName name() const;
  void set_name(::IMC_DCCL::ParameterName value);
  private:
  ::IMC_DCCL::ParameterName _internal_name() const;
  void _internal_set_name(::IMC_DCCL::ParameterName value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.EntityParameter)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::IMC_DCCL::ParameterValue* value_;
    int name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class EntityParameters final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.EntityParameters) */ {
 public:
  inline EntityParameters() : EntityParameters(nullptr) {}
  ~EntityParameters() override;
  explicit PROTOBUF_CONSTEXPR EntityParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EntityParameters(const EntityParameters& from);
  EntityParameters(EntityParameters&& from) noexcept
    : EntityParameters() {
    *this = ::std::move(from);
  }

  inline EntityParameters& operator=(const EntityParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline EntityParameters& operator=(EntityParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EntityParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const EntityParameters* internal_default_instance() {
    return reinterpret_cast<const EntityParameters*>(
               &_EntityParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(EntityParameters& a, EntityParameters& b) {
    a.Swap(&b);
  }
  inline void Swap(EntityParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EntityParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EntityParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EntityParameters>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EntityParameters& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EntityParameters& from) {
    EntityParameters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.EntityParameters";
  }
  protected:
  explicit EntityParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParamsFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
  int params_size() const;
  private:
  int _internal_params_size() const;
  public:
  void clear_params();
  ::IMC_DCCL::EntityParameter* mutable_params(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameter >*
      mutable_params();
  private:
  const ::IMC_DCCL::EntityParameter& _internal_params(int index) const;
  ::IMC_DCCL::EntityParameter* _internal_add_params();
  public:
  const ::IMC_DCCL::EntityParameter& params(int index) const;
  ::IMC_DCCL::EntityParameter* add_params();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameter >&
      params() const;

  // .IMC_DCCL.EntityName name = 1;
  void clear_name();
  ::IMC_DCCL::EntityName name() const;
  void set_name(::IMC_DCCL::EntityName value);
  private:
  ::IMC_DCCL::EntityName _internal_name() const;
  void _internal_set_name(::IMC_DCCL::EntityName value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.EntityParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameter > params_;
    int name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class ManeuverID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.ManeuverID) */ {
 public:
  inline ManeuverID() : ManeuverID(nullptr) {}
  ~ManeuverID() override;
  explicit PROTOBUF_CONSTEXPR ManeuverID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ManeuverID(const ManeuverID& from);
  ManeuverID(ManeuverID&& from) noexcept
    : ManeuverID() {
    *this = ::std::move(from);
  }

  inline ManeuverID& operator=(const ManeuverID& from) {
    CopyFrom(from);
    return *this;
  }
  inline ManeuverID& operator=(ManeuverID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ManeuverID& default_instance() {
    return *internal_default_instance();
  }
  static inline const ManeuverID* internal_default_instance() {
    return reinterpret_cast<const ManeuverID*>(
               &_ManeuverID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ManeuverID& a, ManeuverID& b) {
    a.Swap(&b);
  }
  inline void Swap(ManeuverID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ManeuverID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ManeuverID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ManeuverID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ManeuverID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ManeuverID& from) {
    ManeuverID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManeuverID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.ManeuverID";
  }
  protected:
  explicit ManeuverID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManeuverTypeFieldNumber = 1,
    kManeuverNumberFieldNumber = 2,
  };
  // .IMC_DCCL.ManeuverType maneuver_type = 1;
  void clear_maneuver_type();
  ::IMC_DCCL::ManeuverType maneuver_type() const;
  void set_maneuver_type(::IMC_DCCL::ManeuverType value);
  private:
  ::IMC_DCCL::ManeuverType _internal_maneuver_type() const;
  void _internal_set_maneuver_type(::IMC_DCCL::ManeuverType value);
  public:

  // int32 maneuver_number = 2 [(.dccl.field) = {
  void clear_maneuver_number();
  int32_t maneuver_number() const;
  void set_maneuver_number(int32_t value);
  private:
  int32_t _internal_maneuver_number() const;
  void _internal_set_maneuver_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.ManeuverID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int maneuver_type_;
    int32_t maneuver_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class PlanManeuver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanManeuver) */ {
 public:
  inline PlanManeuver() : PlanManeuver(nullptr) {}
  ~PlanManeuver() override;
  explicit PROTOBUF_CONSTEXPR PlanManeuver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanManeuver(const PlanManeuver& from);
  PlanManeuver(PlanManeuver&& from) noexcept
    : PlanManeuver() {
    *this = ::std::move(from);
  }

  inline PlanManeuver& operator=(const PlanManeuver& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanManeuver& operator=(PlanManeuver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanManeuver& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanManeuver* internal_default_instance() {
    return reinterpret_cast<const PlanManeuver*>(
               &_PlanManeuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(PlanManeuver& a, PlanManeuver& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanManeuver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanManeuver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanManeuver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanManeuver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanManeuver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanManeuver& from) {
    PlanManeuver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanManeuver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.PlanManeuver";
  }
  protected:
  explicit PlanManeuver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartActionsFieldNumber = 3,
    kManeuverIdFieldNumber = 1,
    kDataFieldNumber = 2,
  };
  // repeated .IMC_DCCL.EntityParameters start_actions = 3 [(.dccl.field) = {
  int start_actions_size() const;
  private:
  int _internal_start_actions_size() const;
  public:
  void clear_start_actions();
  ::IMC_DCCL::EntityParameters* mutable_start_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
      mutable_start_actions();
  private:
  const ::IMC_DCCL::EntityParameters& _internal_start_actions(int index) const;
  ::IMC_DCCL::EntityParameters* _internal_add_start_actions();
  public:
  const ::IMC_DCCL::EntityParameters& start_actions(int index) const;
  ::IMC_DCCL::EntityParameters* add_start_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
      start_actions() const;

  // .IMC_DCCL.ManeuverID maneuver_id = 1;
  bool has_maneuver_id() const;
  private:
  bool _internal_has_maneuver_id() const;
  public:
  void clear_maneuver_id();
  const ::IMC_DCCL::ManeuverID& maneuver_id() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::ManeuverID* release_maneuver_id();
  ::IMC_DCCL::ManeuverID* mutable_maneuver_id();
  void set_allocated_maneuver_id(::IMC_DCCL::ManeuverID* maneuver_id);
  private:
  const ::IMC_DCCL::ManeuverID& _internal_maneuver_id() const;
  ::IMC_DCCL::ManeuverID* _internal_mutable_maneuver_id();
  public:
  void unsafe_arena_set_allocated_maneuver_id(
      ::IMC_DCCL::ManeuverID* maneuver_id);
  ::IMC_DCCL::ManeuverID* unsafe_arena_release_maneuver_id();

  // .IMC_DCCL.Maneuver data = 2;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::IMC_DCCL::Maneuver& data() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::Maneuver* release_data();
  ::IMC_DCCL::Maneuver* mutable_data();
  void set_allocated_data(::IMC_DCCL::Maneuver* data);
  private:
  const ::IMC_DCCL::Maneuver& _internal_data() const;
  ::IMC_DCCL::Maneuver* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::IMC_DCCL::Maneuver* data);
  ::IMC_DCCL::Maneuver* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanManeuver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters > start_actions_;
    ::IMC_DCCL::ManeuverID* maneuver_id_;
    ::IMC_DCCL::Maneuver* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class PlanVariable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanVariable) */ {
 public:
  inline PlanVariable() : PlanVariable(nullptr) {}
  ~PlanVariable() override;
  explicit PROTOBUF_CONSTEXPR PlanVariable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanVariable(const PlanVariable& from);
  PlanVariable(PlanVariable&& from) noexcept
    : PlanVariable() {
    *this = ::std::move(from);
  }

  inline PlanVariable& operator=(const PlanVariable& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanVariable& operator=(PlanVariable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanVariable& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanVariable* internal_default_instance() {
    return reinterpret_cast<const PlanVariable*>(
               &_PlanVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(PlanVariable& a, PlanVariable& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanVariable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanVariable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanVariable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanVariable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanVariable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanVariable& from) {
    PlanVariable::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanVariable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.PlanVariable";
  }
  protected:
  explicit PlanVariable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kValueFieldNumber = 2,
    kTypeFieldNumber = 3,
    kAccessFieldNumber = 4,
  };
  // string name = 1 [(.dccl.field) = {
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string value = 2 [(.dccl.field) = {
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // .IMC_DCCL.Type type = 3;
  void clear_type();
  ::IMC_DCCL::Type type() const;
  void set_type(::IMC_DCCL::Type value);
  private:
  ::IMC_DCCL::Type _internal_type() const;
  void _internal_set_type(::IMC_DCCL::Type value);
  public:

  // .IMC_DCCL.AccessType access = 4;
  void clear_access();
  ::IMC_DCCL::AccessType access() const;
  void set_access(::IMC_DCCL::AccessType value);
  private:
  ::IMC_DCCL::AccessType _internal_access() const;
  void _internal_set_access(::IMC_DCCL::AccessType value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanVariable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
    int type_;
    int access_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class PlanTransition final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanTransition) */ {
 public:
  inline PlanTransition() : PlanTransition(nullptr) {}
  ~PlanTransition() override;
  explicit PROTOBUF_CONSTEXPR PlanTransition(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanTransition(const PlanTransition& from);
  PlanTransition(PlanTransition&& from) noexcept
    : PlanTransition() {
    *this = ::std::move(from);
  }

  inline PlanTransition& operator=(const PlanTransition& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanTransition& operator=(PlanTransition&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanTransition& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanTransition* internal_default_instance() {
    return reinterpret_cast<const PlanTransition*>(
               &_PlanTransition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PlanTransition& a, PlanTransition& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanTransition* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanTransition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanTransition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanTransition>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanTransition& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanTransition& from) {
    PlanTransition::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanTransition* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.PlanTransition";
  }
  protected:
  explicit PlanTransition(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceManFieldNumber = 1,
    kDestManFieldNumber = 2,
    kConditionsFieldNumber = 3,
  };
  // .IMC_DCCL.ManeuverID source_man = 1;
  bool has_source_man() const;
  private:
  bool _internal_has_source_man() const;
  public:
  void clear_source_man();
  const ::IMC_DCCL::ManeuverID& source_man() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::ManeuverID* release_source_man();
  ::IMC_DCCL::ManeuverID* mutable_source_man();
  void set_allocated_source_man(::IMC_DCCL::ManeuverID* source_man);
  private:
  const ::IMC_DCCL::ManeuverID& _internal_source_man() const;
  ::IMC_DCCL::ManeuverID* _internal_mutable_source_man();
  public:
  void unsafe_arena_set_allocated_source_man(
      ::IMC_DCCL::ManeuverID* source_man);
  ::IMC_DCCL::ManeuverID* unsafe_arena_release_source_man();

  // .IMC_DCCL.ManeuverID dest_man = 2;
  bool has_dest_man() const;
  private:
  bool _internal_has_dest_man() const;
  public:
  void clear_dest_man();
  const ::IMC_DCCL::ManeuverID& dest_man() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::ManeuverID* release_dest_man();
  ::IMC_DCCL::ManeuverID* mutable_dest_man();
  void set_allocated_dest_man(::IMC_DCCL::ManeuverID* dest_man);
  private:
  const ::IMC_DCCL::ManeuverID& _internal_dest_man() const;
  ::IMC_DCCL::ManeuverID* _internal_mutable_dest_man();
  public:
  void unsafe_arena_set_allocated_dest_man(
      ::IMC_DCCL::ManeuverID* dest_man);
  ::IMC_DCCL::ManeuverID* unsafe_arena_release_dest_man();

  // .IMC_DCCL.TransitionCondition conditions = 3;
  void clear_conditions();
  ::IMC_DCCL::TransitionCondition conditions() const;
  void set_conditions(::IMC_DCCL::TransitionCondition value);
  private:
  ::IMC_DCCL::TransitionCondition _internal_conditions() const;
  void _internal_set_conditions(::IMC_DCCL::TransitionCondition value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanTransition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::IMC_DCCL::ManeuverID* source_man_;
    ::IMC_DCCL::ManeuverID* dest_man_;
    int conditions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class Header final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Header) */ {
 public:
  inline Header() : Header(nullptr) {}
  ~Header() override;
  explicit PROTOBUF_CONSTEXPR Header(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Header(const Header& from);
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  inline Header& operator=(Header&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Header& default_instance() {
    return *internal_default_instance();
  }
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }
  inline void Swap(Header* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Header* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Header* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Header& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Header& from) {
    Header::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.Header";
  }
  protected:
  explicit Header(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kSrcEntFieldNumber = 2,
    kDstFieldNumber = 3,
    kDstEntFieldNumber = 4,
  };
  // int32 src = 1 [(.dccl.field) = {
  void clear_src();
  int32_t src() const;
  void set_src(int32_t value);
  private:
  int32_t _internal_src() const;
  void _internal_set_src(int32_t value);
  public:

  // int32 src_ent = 2 [(.dccl.field) = {
  void clear_src_ent();
  int32_t src_ent() const;
  void set_src_ent(int32_t value);
  private:
  int32_t _internal_src_ent() const;
  void _internal_set_src_ent(int32_t value);
  public:

  // int32 dst = 3 [(.dccl.field) = {
  void clear_dst();
  int32_t dst() const;
  void set_dst(int32_t value);
  private:
  int32_t _internal_dst() const;
  void _internal_set_dst(int32_t value);
  public:

  // int32 dst_ent = 4 [(.dccl.field) = {
  void clear_dst_ent();
  int32_t dst_ent() const;
  void set_dst_ent(int32_t value);
  private:
  int32_t _internal_dst_ent() const;
  void _internal_set_dst_ent(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:IMC_DCCL.Header)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t src_;
    int32_t src_ent_;
    int32_t dst_;
    int32_t dst_ent_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// -------------------------------------------------------------------

class PlanSpecification final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanSpecification) */ {
 public:
  inline PlanSpecification() : PlanSpecification(nullptr) {}
  ~PlanSpecification() override;
  explicit PROTOBUF_CONSTEXPR PlanSpecification(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlanSpecification(const PlanSpecification& from);
  PlanSpecification(PlanSpecification&& from) noexcept
    : PlanSpecification() {
    *this = ::std::move(from);
  }

  inline PlanSpecification& operator=(const PlanSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlanSpecification& operator=(PlanSpecification&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlanSpecification& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlanSpecification* internal_default_instance() {
    return reinterpret_cast<const PlanSpecification*>(
               &_PlanSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PlanSpecification& a, PlanSpecification& b) {
    a.Swap(&b);
  }
  inline void Swap(PlanSpecification* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlanSpecification* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlanSpecification* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlanSpecification>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlanSpecification& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PlanSpecification& from) {
    PlanSpecification::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanSpecification* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "IMC_DCCL.PlanSpecification";
  }
  protected:
  explicit PlanSpecification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kManeuversFieldNumber = 5,
    kTransitionsFieldNumber = 6,
    kStartActionsFieldNumber = 7,
    kVariablesFieldNumber = 8,
    kPlanIdFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kVnamespaceFieldNumber = 3,
    kStartManIdFieldNumber = 4,
    kHeadFieldNumber = 9,
  };
  // repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
  int maneuvers_size() const;
  private:
  int _internal_maneuvers_size() const;
  public:
  void clear_maneuvers();
  ::IMC_DCCL::PlanManeuver* mutable_maneuvers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >*
      mutable_maneuvers();
  private:
  const ::IMC_DCCL::PlanManeuver& _internal_maneuvers(int index) const;
  ::IMC_DCCL::PlanManeuver* _internal_add_maneuvers();
  public:
  const ::IMC_DCCL::PlanManeuver& maneuvers(int index) const;
  ::IMC_DCCL::PlanManeuver* add_maneuvers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >&
      maneuvers() const;

  // repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
  int transitions_size() const;
  private:
  int _internal_transitions_size() const;
  public:
  void clear_transitions();
  ::IMC_DCCL::PlanTransition* mutable_transitions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanTransition >*
      mutable_transitions();
  private:
  const ::IMC_DCCL::PlanTransition& _internal_transitions(int index) const;
  ::IMC_DCCL::PlanTransition* _internal_add_transitions();
  public:
  const ::IMC_DCCL::PlanTransition& transitions(int index) const;
  ::IMC_DCCL::PlanTransition* add_transitions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanTransition >&
      transitions() const;

  // repeated .IMC_DCCL.EntityParameters start_actions = 7 [(.dccl.field) = {
  int start_actions_size() const;
  private:
  int _internal_start_actions_size() const;
  public:
  void clear_start_actions();
  ::IMC_DCCL::EntityParameters* mutable_start_actions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
      mutable_start_actions();
  private:
  const ::IMC_DCCL::EntityParameters& _internal_start_actions(int index) const;
  ::IMC_DCCL::EntityParameters* _internal_add_start_actions();
  public:
  const ::IMC_DCCL::EntityParameters& start_actions(int index) const;
  ::IMC_DCCL::EntityParameters* add_start_actions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
      start_actions() const;

  // repeated .IMC_DCCL.PlanVariable variables = 8 [(.dccl.field) = {
  int variables_size() const;
  private:
  int _internal_variables_size() const;
  public:
  void clear_variables();
  ::IMC_DCCL::PlanVariable* mutable_variables(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanVariable >*
      mutable_variables();
  private:
  const ::IMC_DCCL::PlanVariable& _internal_variables(int index) const;
  ::IMC_DCCL::PlanVariable* _internal_add_variables();
  public:
  const ::IMC_DCCL::PlanVariable& variables(int index) const;
  ::IMC_DCCL::PlanVariable* add_variables();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanVariable >&
      variables() const;

  // string plan_id = 1 [(.dccl.field) = {
  void clear_plan_id();
  const std::string& plan_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_plan_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_plan_id();
  PROTOBUF_NODISCARD std::string* release_plan_id();
  void set_allocated_plan_id(std::string* plan_id);
  private:
  const std::string& _internal_plan_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_plan_id(const std::string& value);
  std::string* _internal_mutable_plan_id();
  public:

  // string description = 2 [(.dccl.field) = {
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // string vnamespace = 3 [(.dccl.field) = {
  void clear_vnamespace();
  const std::string& vnamespace() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_vnamespace(ArgT0&& arg0, ArgT... args);
  std::string* mutable_vnamespace();
  PROTOBUF_NODISCARD std::string* release_vnamespace();
  void set_allocated_vnamespace(std::string* vnamespace);
  private:
  const std::string& _internal_vnamespace() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_vnamespace(const std::string& value);
  std::string* _internal_mutable_vnamespace();
  public:

  // .IMC_DCCL.ManeuverID start_man_id = 4;
  bool has_start_man_id() const;
  private:
  bool _internal_has_start_man_id() const;
  public:
  void clear_start_man_id();
  const ::IMC_DCCL::ManeuverID& start_man_id() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::ManeuverID* release_start_man_id();
  ::IMC_DCCL::ManeuverID* mutable_start_man_id();
  void set_allocated_start_man_id(::IMC_DCCL::ManeuverID* start_man_id);
  private:
  const ::IMC_DCCL::ManeuverID& _internal_start_man_id() const;
  ::IMC_DCCL::ManeuverID* _internal_mutable_start_man_id();
  public:
  void unsafe_arena_set_allocated_start_man_id(
      ::IMC_DCCL::ManeuverID* start_man_id);
  ::IMC_DCCL::ManeuverID* unsafe_arena_release_start_man_id();

  // .IMC_DCCL.Header head = 9;
  bool has_head() const;
  private:
  bool _internal_has_head() const;
  public:
  void clear_head();
  const ::IMC_DCCL::Header& head() const;
  PROTOBUF_NODISCARD ::IMC_DCCL::Header* release_head();
  ::IMC_DCCL::Header* mutable_head();
  void set_allocated_head(::IMC_DCCL::Header* head);
  private:
  const ::IMC_DCCL::Header& _internal_head() const;
  ::IMC_DCCL::Header* _internal_mutable_head();
  public:
  void unsafe_arena_set_allocated_head(
      ::IMC_DCCL::Header* head);
  ::IMC_DCCL::Header* unsafe_arena_release_head();

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanSpecification)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanManeuver > maneuvers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanTransition > transitions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters > start_actions_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanVariable > variables_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr plan_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vnamespace_;
    ::IMC_DCCL::ManeuverID* start_man_id_;
    ::IMC_DCCL::Header* head_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_IMC_5fDCCL_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EstimatedState

// float lat = 1 [(.dccl.field) = {
inline void EstimatedState::clear_lat() {
  _impl_.lat_ = 0;
}
inline float EstimatedState::_internal_lat() const {
  return _impl_.lat_;
}
inline float EstimatedState::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.lat)
  return _internal_lat();
}
inline void EstimatedState::_internal_set_lat(float value) {
  
  _impl_.lat_ = value;
}
inline void EstimatedState::set_lat(float value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.lat)
}

// float lon = 2 [(.dccl.field) = {
inline void EstimatedState::clear_lon() {
  _impl_.lon_ = 0;
}
inline float EstimatedState::_internal_lon() const {
  return _impl_.lon_;
}
inline float EstimatedState::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.lon)
  return _internal_lon();
}
inline void EstimatedState::_internal_set_lon(float value) {
  
  _impl_.lon_ = value;
}
inline void EstimatedState::set_lon(float value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.lon)
}

// float height = 3 [(.dccl.field) = {
inline void EstimatedState::clear_height() {
  _impl_.height_ = 0;
}
inline float EstimatedState::_internal_height() const {
  return _impl_.height_;
}
inline float EstimatedState::height() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.height)
  return _internal_height();
}
inline void EstimatedState::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void EstimatedState::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.height)
}

// float x = 4 [(.dccl.field) = {
inline void EstimatedState::clear_x() {
  _impl_.x_ = 0;
}
inline float EstimatedState::_internal_x() const {
  return _impl_.x_;
}
inline float EstimatedState::x() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.x)
  return _internal_x();
}
inline void EstimatedState::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void EstimatedState::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.x)
}

// float y = 5 [(.dccl.field) = {
inline void EstimatedState::clear_y() {
  _impl_.y_ = 0;
}
inline float EstimatedState::_internal_y() const {
  return _impl_.y_;
}
inline float EstimatedState::y() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.y)
  return _internal_y();
}
inline void EstimatedState::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void EstimatedState::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.y)
}

// float z = 6 [(.dccl.field) = {
inline void EstimatedState::clear_z() {
  _impl_.z_ = 0;
}
inline float EstimatedState::_internal_z() const {
  return _impl_.z_;
}
inline float EstimatedState::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.z)
  return _internal_z();
}
inline void EstimatedState::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void EstimatedState::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.z)
}

// float phi = 7 [(.dccl.field) = {
inline void EstimatedState::clear_phi() {
  _impl_.phi_ = 0;
}
inline float EstimatedState::_internal_phi() const {
  return _impl_.phi_;
}
inline float EstimatedState::phi() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.phi)
  return _internal_phi();
}
inline void EstimatedState::_internal_set_phi(float value) {
  
  _impl_.phi_ = value;
}
inline void EstimatedState::set_phi(float value) {
  _internal_set_phi(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.phi)
}

// float theta = 8 [(.dccl.field) = {
inline void EstimatedState::clear_theta() {
  _impl_.theta_ = 0;
}
inline float EstimatedState::_internal_theta() const {
  return _impl_.theta_;
}
inline float EstimatedState::theta() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.theta)
  return _internal_theta();
}
inline void EstimatedState::_internal_set_theta(float value) {
  
  _impl_.theta_ = value;
}
inline void EstimatedState::set_theta(float value) {
  _internal_set_theta(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.theta)
}

// float psi = 9 [(.dccl.field) = {
inline void EstimatedState::clear_psi() {
  _impl_.psi_ = 0;
}
inline float EstimatedState::_internal_psi() const {
  return _impl_.psi_;
}
inline float EstimatedState::psi() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.psi)
  return _internal_psi();
}
inline void EstimatedState::_internal_set_psi(float value) {
  
  _impl_.psi_ = value;
}
inline void EstimatedState::set_psi(float value) {
  _internal_set_psi(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.psi)
}

// float u = 10 [(.dccl.field) = {
inline void EstimatedState::clear_u() {
  _impl_.u_ = 0;
}
inline float EstimatedState::_internal_u() const {
  return _impl_.u_;
}
inline float EstimatedState::u() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.u)
  return _internal_u();
}
inline void EstimatedState::_internal_set_u(float value) {
  
  _impl_.u_ = value;
}
inline void EstimatedState::set_u(float value) {
  _internal_set_u(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.u)
}

// float v = 11 [(.dccl.field) = {
inline void EstimatedState::clear_v() {
  _impl_.v_ = 0;
}
inline float EstimatedState::_internal_v() const {
  return _impl_.v_;
}
inline float EstimatedState::v() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.v)
  return _internal_v();
}
inline void EstimatedState::_internal_set_v(float value) {
  
  _impl_.v_ = value;
}
inline void EstimatedState::set_v(float value) {
  _internal_set_v(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.v)
}

// float w = 12 [(.dccl.field) = {
inline void EstimatedState::clear_w() {
  _impl_.w_ = 0;
}
inline float EstimatedState::_internal_w() const {
  return _impl_.w_;
}
inline float EstimatedState::w() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.w)
  return _internal_w();
}
inline void EstimatedState::_internal_set_w(float value) {
  
  _impl_.w_ = value;
}
inline void EstimatedState::set_w(float value) {
  _internal_set_w(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.w)
}

// float vx = 13 [(.dccl.field) = {
inline void EstimatedState::clear_vx() {
  _impl_.vx_ = 0;
}
inline float EstimatedState::_internal_vx() const {
  return _impl_.vx_;
}
inline float EstimatedState::vx() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.vx)
  return _internal_vx();
}
inline void EstimatedState::_internal_set_vx(float value) {
  
  _impl_.vx_ = value;
}
inline void EstimatedState::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.vx)
}

// float vy = 14 [(.dccl.field) = {
inline void EstimatedState::clear_vy() {
  _impl_.vy_ = 0;
}
inline float EstimatedState::_internal_vy() const {
  return _impl_.vy_;
}
inline float EstimatedState::vy() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.vy)
  return _internal_vy();
}
inline void EstimatedState::_internal_set_vy(float value) {
  
  _impl_.vy_ = value;
}
inline void EstimatedState::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.vy)
}

// float vz = 15 [(.dccl.field) = {
inline void EstimatedState::clear_vz() {
  _impl_.vz_ = 0;
}
inline float EstimatedState::_internal_vz() const {
  return _impl_.vz_;
}
inline float EstimatedState::vz() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.vz)
  return _internal_vz();
}
inline void EstimatedState::_internal_set_vz(float value) {
  
  _impl_.vz_ = value;
}
inline void EstimatedState::set_vz(float value) {
  _internal_set_vz(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.vz)
}

// float p = 16 [(.dccl.field) = {
inline void EstimatedState::clear_p() {
  _impl_.p_ = 0;
}
inline float EstimatedState::_internal_p() const {
  return _impl_.p_;
}
inline float EstimatedState::p() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.p)
  return _internal_p();
}
inline void EstimatedState::_internal_set_p(float value) {
  
  _impl_.p_ = value;
}
inline void EstimatedState::set_p(float value) {
  _internal_set_p(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.p)
}

// float q = 17 [(.dccl.field) = {
inline void EstimatedState::clear_q() {
  _impl_.q_ = 0;
}
inline float EstimatedState::_internal_q() const {
  return _impl_.q_;
}
inline float EstimatedState::q() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.q)
  return _internal_q();
}
inline void EstimatedState::_internal_set_q(float value) {
  
  _impl_.q_ = value;
}
inline void EstimatedState::set_q(float value) {
  _internal_set_q(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.q)
}

// float r = 18 [(.dccl.field) = {
inline void EstimatedState::clear_r() {
  _impl_.r_ = 0;
}
inline float EstimatedState::_internal_r() const {
  return _impl_.r_;
}
inline float EstimatedState::r() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.r)
  return _internal_r();
}
inline void EstimatedState::_internal_set_r(float value) {
  
  _impl_.r_ = value;
}
inline void EstimatedState::set_r(float value) {
  _internal_set_r(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.r)
}

// float depth = 19 [(.dccl.field) = {
inline void EstimatedState::clear_depth() {
  _impl_.depth_ = 0;
}
inline float EstimatedState::_internal_depth() const {
  return _impl_.depth_;
}
inline float EstimatedState::depth() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.depth)
  return _internal_depth();
}
inline void EstimatedState::_internal_set_depth(float value) {
  
  _impl_.depth_ = value;
}
inline void EstimatedState::set_depth(float value) {
  _internal_set_depth(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.depth)
}

// float altitude = 20 [(.dccl.field) = {
inline void EstimatedState::clear_altitude() {
  _impl_.altitude_ = 0;
}
inline float EstimatedState::_internal_altitude() const {
  return _impl_.altitude_;
}
inline float EstimatedState::altitude() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.altitude)
  return _internal_altitude();
}
inline void EstimatedState::_internal_set_altitude(float value) {
  
  _impl_.altitude_ = value;
}
inline void EstimatedState::set_altitude(float value) {
  _internal_set_altitude(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.altitude)
}

// -------------------------------------------------------------------

// Goto

// int32 timeout = 1 [(.dccl.field) = {
inline void Goto::clear_timeout() {
  _impl_.timeout_ = 0;
}
inline int32_t Goto::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int32_t Goto::timeout() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.timeout)
  return _internal_timeout();
}
inline void Goto::_internal_set_timeout(int32_t value) {
  
  _impl_.timeout_ = value;
}
inline void Goto::set_timeout(int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.timeout)
}

// float lat = 2 [(.dccl.field) = {
inline void Goto::clear_lat() {
  _impl_.lat_ = 0;
}
inline float Goto::_internal_lat() const {
  return _impl_.lat_;
}
inline float Goto::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.lat)
  return _internal_lat();
}
inline void Goto::_internal_set_lat(float value) {
  
  _impl_.lat_ = value;
}
inline void Goto::set_lat(float value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.lat)
}

// float lon = 3 [(.dccl.field) = {
inline void Goto::clear_lon() {
  _impl_.lon_ = 0;
}
inline float Goto::_internal_lon() const {
  return _impl_.lon_;
}
inline float Goto::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.lon)
  return _internal_lon();
}
inline void Goto::_internal_set_lon(float value) {
  
  _impl_.lon_ = value;
}
inline void Goto::set_lon(float value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.lon)
}

// float z = 4 [(.dccl.field) = {
inline void Goto::clear_z() {
  _impl_.z_ = 0;
}
inline float Goto::_internal_z() const {
  return _impl_.z_;
}
inline float Goto::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.z)
  return _internal_z();
}
inline void Goto::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Goto::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.z)
}

// .IMC_DCCL.ZUnits z_units = 5;
inline void Goto::clear_z_units() {
  _impl_.z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits Goto::_internal_z_units() const {
  return static_cast< ::IMC_DCCL::ZUnits >(_impl_.z_units_);
}
inline ::IMC_DCCL::ZUnits Goto::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.z_units)
  return _internal_z_units();
}
inline void Goto::_internal_set_z_units(::IMC_DCCL::ZUnits value) {
  
  _impl_.z_units_ = value;
}
inline void Goto::set_z_units(::IMC_DCCL::ZUnits value) {
  _internal_set_z_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.z_units)
}

// float speed = 6 [(.dccl.field) = {
inline void Goto::clear_speed() {
  _impl_.speed_ = 0;
}
inline float Goto::_internal_speed() const {
  return _impl_.speed_;
}
inline float Goto::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.speed)
  return _internal_speed();
}
inline void Goto::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void Goto::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 7;
inline void Goto::clear_speed_units() {
  _impl_.speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits Goto::_internal_speed_units() const {
  return static_cast< ::IMC_DCCL::SpeedUnits >(_impl_.speed_units_);
}
inline ::IMC_DCCL::SpeedUnits Goto::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.speed_units)
  return _internal_speed_units();
}
inline void Goto::_internal_set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  _impl_.speed_units_ = value;
}
inline void Goto::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  _internal_set_speed_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.speed_units)
}

// float roll = 8 [(.dccl.field) = {
inline void Goto::clear_roll() {
  _impl_.roll_ = 0;
}
inline float Goto::_internal_roll() const {
  return _impl_.roll_;
}
inline float Goto::roll() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.roll)
  return _internal_roll();
}
inline void Goto::_internal_set_roll(float value) {
  
  _impl_.roll_ = value;
}
inline void Goto::set_roll(float value) {
  _internal_set_roll(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.roll)
}

// float pitch = 9 [(.dccl.field) = {
inline void Goto::clear_pitch() {
  _impl_.pitch_ = 0;
}
inline float Goto::_internal_pitch() const {
  return _impl_.pitch_;
}
inline float Goto::pitch() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.pitch)
  return _internal_pitch();
}
inline void Goto::_internal_set_pitch(float value) {
  
  _impl_.pitch_ = value;
}
inline void Goto::set_pitch(float value) {
  _internal_set_pitch(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.pitch)
}

// float yaw = 10 [(.dccl.field) = {
inline void Goto::clear_yaw() {
  _impl_.yaw_ = 0;
}
inline float Goto::_internal_yaw() const {
  return _impl_.yaw_;
}
inline float Goto::yaw() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.yaw)
  return _internal_yaw();
}
inline void Goto::_internal_set_yaw(float value) {
  
  _impl_.yaw_ = value;
}
inline void Goto::set_yaw(float value) {
  _internal_set_yaw(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.yaw)
}

// -------------------------------------------------------------------

// StationKeeping

// float lat = 1 [(.dccl.field) = {
inline void StationKeeping::clear_lat() {
  _impl_.lat_ = 0;
}
inline float StationKeeping::_internal_lat() const {
  return _impl_.lat_;
}
inline float StationKeeping::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.lat)
  return _internal_lat();
}
inline void StationKeeping::_internal_set_lat(float value) {
  
  _impl_.lat_ = value;
}
inline void StationKeeping::set_lat(float value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.lat)
}

// float lon = 2 [(.dccl.field) = {
inline void StationKeeping::clear_lon() {
  _impl_.lon_ = 0;
}
inline float StationKeeping::_internal_lon() const {
  return _impl_.lon_;
}
inline float StationKeeping::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.lon)
  return _internal_lon();
}
inline void StationKeeping::_internal_set_lon(float value) {
  
  _impl_.lon_ = value;
}
inline void StationKeeping::set_lon(float value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.lon)
}

// float z = 3 [(.dccl.field) = {
inline void StationKeeping::clear_z() {
  _impl_.z_ = 0;
}
inline float StationKeeping::_internal_z() const {
  return _impl_.z_;
}
inline float StationKeeping::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.z)
  return _internal_z();
}
inline void StationKeeping::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void StationKeeping::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.z)
}

// .IMC_DCCL.ZUnits z_units = 4;
inline void StationKeeping::clear_z_units() {
  _impl_.z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits StationKeeping::_internal_z_units() const {
  return static_cast< ::IMC_DCCL::ZUnits >(_impl_.z_units_);
}
inline ::IMC_DCCL::ZUnits StationKeeping::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.z_units)
  return _internal_z_units();
}
inline void StationKeeping::_internal_set_z_units(::IMC_DCCL::ZUnits value) {
  
  _impl_.z_units_ = value;
}
inline void StationKeeping::set_z_units(::IMC_DCCL::ZUnits value) {
  _internal_set_z_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.z_units)
}

// float radius = 5 [(.dccl.field) = {
inline void StationKeeping::clear_radius() {
  _impl_.radius_ = 0;
}
inline float StationKeeping::_internal_radius() const {
  return _impl_.radius_;
}
inline float StationKeeping::radius() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.radius)
  return _internal_radius();
}
inline void StationKeeping::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void StationKeeping::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.radius)
}

// int32 duration = 6 [(.dccl.field) = {
inline void StationKeeping::clear_duration() {
  _impl_.duration_ = 0;
}
inline int32_t StationKeeping::_internal_duration() const {
  return _impl_.duration_;
}
inline int32_t StationKeeping::duration() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.duration)
  return _internal_duration();
}
inline void StationKeeping::_internal_set_duration(int32_t value) {
  
  _impl_.duration_ = value;
}
inline void StationKeeping::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.duration)
}

// float speed = 7 [(.dccl.field) = {
inline void StationKeeping::clear_speed() {
  _impl_.speed_ = 0;
}
inline float StationKeeping::_internal_speed() const {
  return _impl_.speed_;
}
inline float StationKeeping::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.speed)
  return _internal_speed();
}
inline void StationKeeping::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void StationKeeping::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 8;
inline void StationKeeping::clear_speed_units() {
  _impl_.speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits StationKeeping::_internal_speed_units() const {
  return static_cast< ::IMC_DCCL::SpeedUnits >(_impl_.speed_units_);
}
inline ::IMC_DCCL::SpeedUnits StationKeeping::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.StationKeeping.speed_units)
  return _internal_speed_units();
}
inline void StationKeeping::_internal_set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  _impl_.speed_units_ = value;
}
inline void StationKeeping::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  _internal_set_speed_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.StationKeeping.speed_units)
}

// -------------------------------------------------------------------

// FollowPath

// int32 timeout = 1 [(.dccl.field) = {
inline void FollowPath::clear_timeout() {
  _impl_.timeout_ = 0;
}
inline int32_t FollowPath::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int32_t FollowPath::timeout() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.timeout)
  return _internal_timeout();
}
inline void FollowPath::_internal_set_timeout(int32_t value) {
  
  _impl_.timeout_ = value;
}
inline void FollowPath::set_timeout(int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.timeout)
}

// float lat = 2 [(.dccl.field) = {
inline void FollowPath::clear_lat() {
  _impl_.lat_ = 0;
}
inline float FollowPath::_internal_lat() const {
  return _impl_.lat_;
}
inline float FollowPath::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.lat)
  return _internal_lat();
}
inline void FollowPath::_internal_set_lat(float value) {
  
  _impl_.lat_ = value;
}
inline void FollowPath::set_lat(float value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.lat)
}

// float lon = 3 [(.dccl.field) = {
inline void FollowPath::clear_lon() {
  _impl_.lon_ = 0;
}
inline float FollowPath::_internal_lon() const {
  return _impl_.lon_;
}
inline float FollowPath::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.lon)
  return _internal_lon();
}
inline void FollowPath::_internal_set_lon(float value) {
  
  _impl_.lon_ = value;
}
inline void FollowPath::set_lon(float value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.lon)
}

// float z = 4 [(.dccl.field) = {
inline void FollowPath::clear_z() {
  _impl_.z_ = 0;
}
inline float FollowPath::_internal_z() const {
  return _impl_.z_;
}
inline float FollowPath::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.z)
  return _internal_z();
}
inline void FollowPath::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void FollowPath::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.z)
}

// .IMC_DCCL.ZUnits z_units = 5;
inline void FollowPath::clear_z_units() {
  _impl_.z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits FollowPath::_internal_z_units() const {
  return static_cast< ::IMC_DCCL::ZUnits >(_impl_.z_units_);
}
inline ::IMC_DCCL::ZUnits FollowPath::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.z_units)
  return _internal_z_units();
}
inline void FollowPath::_internal_set_z_units(::IMC_DCCL::ZUnits value) {
  
  _impl_.z_units_ = value;
}
inline void FollowPath::set_z_units(::IMC_DCCL::ZUnits value) {
  _internal_set_z_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.z_units)
}

// float speed = 6 [(.dccl.field) = {
inline void FollowPath::clear_speed() {
  _impl_.speed_ = 0;
}
inline float FollowPath::_internal_speed() const {
  return _impl_.speed_;
}
inline float FollowPath::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.speed)
  return _internal_speed();
}
inline void FollowPath::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void FollowPath::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 7;
inline void FollowPath::clear_speed_units() {
  _impl_.speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits FollowPath::_internal_speed_units() const {
  return static_cast< ::IMC_DCCL::SpeedUnits >(_impl_.speed_units_);
}
inline ::IMC_DCCL::SpeedUnits FollowPath::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.speed_units)
  return _internal_speed_units();
}
inline void FollowPath::_internal_set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  _impl_.speed_units_ = value;
}
inline void FollowPath::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  _internal_set_speed_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.speed_units)
}

// repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
inline int FollowPath::_internal_points_size() const {
  return _impl_.points_.size();
}
inline int FollowPath::points_size() const {
  return _internal_points_size();
}
inline void FollowPath::clear_points() {
  _impl_.points_.Clear();
}
inline ::IMC_DCCL::PathPoint* FollowPath::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.FollowPath.points)
  return _impl_.points_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PathPoint >*
FollowPath::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.FollowPath.points)
  return &_impl_.points_;
}
inline const ::IMC_DCCL::PathPoint& FollowPath::_internal_points(int index) const {
  return _impl_.points_.Get(index);
}
inline const ::IMC_DCCL::PathPoint& FollowPath::points(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.points)
  return _internal_points(index);
}
inline ::IMC_DCCL::PathPoint* FollowPath::_internal_add_points() {
  return _impl_.points_.Add();
}
inline ::IMC_DCCL::PathPoint* FollowPath::add_points() {
  ::IMC_DCCL::PathPoint* _add = _internal_add_points();
  // @@protoc_insertion_point(field_add:IMC_DCCL.FollowPath.points)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PathPoint >&
FollowPath::points() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.FollowPath.points)
  return _impl_.points_;
}

// -------------------------------------------------------------------

// Loiter

// int32 timeout = 1 [(.dccl.field) = {
inline void Loiter::clear_timeout() {
  _impl_.timeout_ = 0;
}
inline int32_t Loiter::_internal_timeout() const {
  return _impl_.timeout_;
}
inline int32_t Loiter::timeout() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.timeout)
  return _internal_timeout();
}
inline void Loiter::_internal_set_timeout(int32_t value) {
  
  _impl_.timeout_ = value;
}
inline void Loiter::set_timeout(int32_t value) {
  _internal_set_timeout(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.timeout)
}

// float lat = 2 [(.dccl.field) = {
inline void Loiter::clear_lat() {
  _impl_.lat_ = 0;
}
inline float Loiter::_internal_lat() const {
  return _impl_.lat_;
}
inline float Loiter::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.lat)
  return _internal_lat();
}
inline void Loiter::_internal_set_lat(float value) {
  
  _impl_.lat_ = value;
}
inline void Loiter::set_lat(float value) {
  _internal_set_lat(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.lat)
}

// float lon = 3 [(.dccl.field) = {
inline void Loiter::clear_lon() {
  _impl_.lon_ = 0;
}
inline float Loiter::_internal_lon() const {
  return _impl_.lon_;
}
inline float Loiter::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.lon)
  return _internal_lon();
}
inline void Loiter::_internal_set_lon(float value) {
  
  _impl_.lon_ = value;
}
inline void Loiter::set_lon(float value) {
  _internal_set_lon(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.lon)
}

// float z = 4 [(.dccl.field) = {
inline void Loiter::clear_z() {
  _impl_.z_ = 0;
}
inline float Loiter::_internal_z() const {
  return _impl_.z_;
}
inline float Loiter::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.z)
  return _internal_z();
}
inline void Loiter::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void Loiter::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.z)
}

// .IMC_DCCL.ZUnits z_units = 5;
inline void Loiter::clear_z_units() {
  _impl_.z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits Loiter::_internal_z_units() const {
  return static_cast< ::IMC_DCCL::ZUnits >(_impl_.z_units_);
}
inline ::IMC_DCCL::ZUnits Loiter::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.z_units)
  return _internal_z_units();
}
inline void Loiter::_internal_set_z_units(::IMC_DCCL::ZUnits value) {
  
  _impl_.z_units_ = value;
}
inline void Loiter::set_z_units(::IMC_DCCL::ZUnits value) {
  _internal_set_z_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.z_units)
}

// int32 duration = 6 [(.dccl.field) = {
inline void Loiter::clear_duration() {
  _impl_.duration_ = 0;
}
inline int32_t Loiter::_internal_duration() const {
  return _impl_.duration_;
}
inline int32_t Loiter::duration() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.duration)
  return _internal_duration();
}
inline void Loiter::_internal_set_duration(int32_t value) {
  
  _impl_.duration_ = value;
}
inline void Loiter::set_duration(int32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.duration)
}

// float speed = 7 [(.dccl.field) = {
inline void Loiter::clear_speed() {
  _impl_.speed_ = 0;
}
inline float Loiter::_internal_speed() const {
  return _impl_.speed_;
}
inline float Loiter::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.speed)
  return _internal_speed();
}
inline void Loiter::_internal_set_speed(float value) {
  
  _impl_.speed_ = value;
}
inline void Loiter::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 8;
inline void Loiter::clear_speed_units() {
  _impl_.speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits Loiter::_internal_speed_units() const {
  return static_cast< ::IMC_DCCL::SpeedUnits >(_impl_.speed_units_);
}
inline ::IMC_DCCL::SpeedUnits Loiter::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.speed_units)
  return _internal_speed_units();
}
inline void Loiter::_internal_set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  _impl_.speed_units_ = value;
}
inline void Loiter::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  _internal_set_speed_units(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.speed_units)
}

// .IMC_DCCL.LoiterType type = 9;
inline void Loiter::clear_type() {
  _impl_.type_ = 0;
}
inline ::IMC_DCCL::LoiterType Loiter::_internal_type() const {
  return static_cast< ::IMC_DCCL::LoiterType >(_impl_.type_);
}
inline ::IMC_DCCL::LoiterType Loiter::type() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.type)
  return _internal_type();
}
inline void Loiter::_internal_set_type(::IMC_DCCL::LoiterType value) {
  
  _impl_.type_ = value;
}
inline void Loiter::set_type(::IMC_DCCL::LoiterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.type)
}

// float radius = 10 [(.dccl.field) = {
inline void Loiter::clear_radius() {
  _impl_.radius_ = 0;
}
inline float Loiter::_internal_radius() const {
  return _impl_.radius_;
}
inline float Loiter::radius() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.radius)
  return _internal_radius();
}
inline void Loiter::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void Loiter::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.radius)
}

// float length = 11 [(.dccl.field) = {
inline void Loiter::clear_length() {
  _impl_.length_ = 0;
}
inline float Loiter::_internal_length() const {
  return _impl_.length_;
}
inline float Loiter::length() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.length)
  return _internal_length();
}
inline void Loiter::_internal_set_length(float value) {
  
  _impl_.length_ = value;
}
inline void Loiter::set_length(float value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.length)
}

// float bearing = 12 [(.dccl.field) = {
inline void Loiter::clear_bearing() {
  _impl_.bearing_ = 0;
}
inline float Loiter::_internal_bearing() const {
  return _impl_.bearing_;
}
inline float Loiter::bearing() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.bearing)
  return _internal_bearing();
}
inline void Loiter::_internal_set_bearing(float value) {
  
  _impl_.bearing_ = value;
}
inline void Loiter::set_bearing(float value) {
  _internal_set_bearing(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.bearing)
}

// .IMC_DCCL.DirectionType direction = 13;
inline void Loiter::clear_direction() {
  _impl_.direction_ = 0;
}
inline ::IMC_DCCL::DirectionType Loiter::_internal_direction() const {
  return static_cast< ::IMC_DCCL::DirectionType >(_impl_.direction_);
}
inline ::IMC_DCCL::DirectionType Loiter::direction() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.direction)
  return _internal_direction();
}
inline void Loiter::_internal_set_direction(::IMC_DCCL::DirectionType value) {
  
  _impl_.direction_ = value;
}
inline void Loiter::set_direction(::IMC_DCCL::DirectionType value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.direction)
}

// -------------------------------------------------------------------

// PathPoint

// float x = 1 [(.dccl.field) = {
inline void PathPoint::clear_x() {
  _impl_.x_ = 0;
}
inline float PathPoint::_internal_x() const {
  return _impl_.x_;
}
inline float PathPoint::x() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PathPoint.x)
  return _internal_x();
}
inline void PathPoint::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void PathPoint::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PathPoint.x)
}

// float y = 2 [(.dccl.field) = {
inline void PathPoint::clear_y() {
  _impl_.y_ = 0;
}
inline float PathPoint::_internal_y() const {
  return _impl_.y_;
}
inline float PathPoint::y() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PathPoint.y)
  return _internal_y();
}
inline void PathPoint::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void PathPoint::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PathPoint.y)
}

// float z = 3 [(.dccl.field) = {
inline void PathPoint::clear_z() {
  _impl_.z_ = 0;
}
inline float PathPoint::_internal_z() const {
  return _impl_.z_;
}
inline float PathPoint::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PathPoint.z)
  return _internal_z();
}
inline void PathPoint::_internal_set_z(float value) {
  
  _impl_.z_ = value;
}
inline void PathPoint::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PathPoint.z)
}

// -------------------------------------------------------------------

// Maneuver

// .IMC_DCCL.Goto goto_maneuver = 1;
inline bool Maneuver::_internal_has_goto_maneuver() const {
  return ManeuverUnion_case() == kGotoManeuver;
}
inline bool Maneuver::has_goto_maneuver() const {
  return _internal_has_goto_maneuver();
}
inline void Maneuver::set_has_goto_maneuver() {
  _impl_._oneof_case_[0] = kGotoManeuver;
}
inline void Maneuver::clear_goto_maneuver() {
  if (_internal_has_goto_maneuver()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ManeuverUnion_.goto_maneuver_;
    }
    clear_has_ManeuverUnion();
  }
}
inline ::IMC_DCCL::Goto* Maneuver::release_goto_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.goto_maneuver)
  if (_internal_has_goto_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::Goto* temp = _impl_.ManeuverUnion_.goto_maneuver_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ManeuverUnion_.goto_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IMC_DCCL::Goto& Maneuver::_internal_goto_maneuver() const {
  return _internal_has_goto_maneuver()
      ? *_impl_.ManeuverUnion_.goto_maneuver_
      : reinterpret_cast< ::IMC_DCCL::Goto&>(::IMC_DCCL::_Goto_default_instance_);
}
inline const ::IMC_DCCL::Goto& Maneuver::goto_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.goto_maneuver)
  return _internal_goto_maneuver();
}
inline ::IMC_DCCL::Goto* Maneuver::unsafe_arena_release_goto_maneuver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IMC_DCCL.Maneuver.goto_maneuver)
  if (_internal_has_goto_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::Goto* temp = _impl_.ManeuverUnion_.goto_maneuver_;
    _impl_.ManeuverUnion_.goto_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Maneuver::unsafe_arena_set_allocated_goto_maneuver(::IMC_DCCL::Goto* goto_maneuver) {
  clear_ManeuverUnion();
  if (goto_maneuver) {
    set_has_goto_maneuver();
    _impl_.ManeuverUnion_.goto_maneuver_ = goto_maneuver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.Maneuver.goto_maneuver)
}
inline ::IMC_DCCL::Goto* Maneuver::_internal_mutable_goto_maneuver() {
  if (!_internal_has_goto_maneuver()) {
    clear_ManeuverUnion();
    set_has_goto_maneuver();
    _impl_.ManeuverUnion_.goto_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::Goto >(GetArenaForAllocation());
  }
  return _impl_.ManeuverUnion_.goto_maneuver_;
}
inline ::IMC_DCCL::Goto* Maneuver::mutable_goto_maneuver() {
  ::IMC_DCCL::Goto* _msg = _internal_mutable_goto_maneuver();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.goto_maneuver)
  return _msg;
}

// .IMC_DCCL.FollowPath followpath_maneuver = 2;
inline bool Maneuver::_internal_has_followpath_maneuver() const {
  return ManeuverUnion_case() == kFollowpathManeuver;
}
inline bool Maneuver::has_followpath_maneuver() const {
  return _internal_has_followpath_maneuver();
}
inline void Maneuver::set_has_followpath_maneuver() {
  _impl_._oneof_case_[0] = kFollowpathManeuver;
}
inline void Maneuver::clear_followpath_maneuver() {
  if (_internal_has_followpath_maneuver()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ManeuverUnion_.followpath_maneuver_;
    }
    clear_has_ManeuverUnion();
  }
}
inline ::IMC_DCCL::FollowPath* Maneuver::release_followpath_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.followpath_maneuver)
  if (_internal_has_followpath_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::FollowPath* temp = _impl_.ManeuverUnion_.followpath_maneuver_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ManeuverUnion_.followpath_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IMC_DCCL::FollowPath& Maneuver::_internal_followpath_maneuver() const {
  return _internal_has_followpath_maneuver()
      ? *_impl_.ManeuverUnion_.followpath_maneuver_
      : reinterpret_cast< ::IMC_DCCL::FollowPath&>(::IMC_DCCL::_FollowPath_default_instance_);
}
inline const ::IMC_DCCL::FollowPath& Maneuver::followpath_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.followpath_maneuver)
  return _internal_followpath_maneuver();
}
inline ::IMC_DCCL::FollowPath* Maneuver::unsafe_arena_release_followpath_maneuver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IMC_DCCL.Maneuver.followpath_maneuver)
  if (_internal_has_followpath_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::FollowPath* temp = _impl_.ManeuverUnion_.followpath_maneuver_;
    _impl_.ManeuverUnion_.followpath_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Maneuver::unsafe_arena_set_allocated_followpath_maneuver(::IMC_DCCL::FollowPath* followpath_maneuver) {
  clear_ManeuverUnion();
  if (followpath_maneuver) {
    set_has_followpath_maneuver();
    _impl_.ManeuverUnion_.followpath_maneuver_ = followpath_maneuver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.Maneuver.followpath_maneuver)
}
inline ::IMC_DCCL::FollowPath* Maneuver::_internal_mutable_followpath_maneuver() {
  if (!_internal_has_followpath_maneuver()) {
    clear_ManeuverUnion();
    set_has_followpath_maneuver();
    _impl_.ManeuverUnion_.followpath_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::FollowPath >(GetArenaForAllocation());
  }
  return _impl_.ManeuverUnion_.followpath_maneuver_;
}
inline ::IMC_DCCL::FollowPath* Maneuver::mutable_followpath_maneuver() {
  ::IMC_DCCL::FollowPath* _msg = _internal_mutable_followpath_maneuver();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.followpath_maneuver)
  return _msg;
}

// .IMC_DCCL.Loiter loiter_maneuver = 3;
inline bool Maneuver::_internal_has_loiter_maneuver() const {
  return ManeuverUnion_case() == kLoiterManeuver;
}
inline bool Maneuver::has_loiter_maneuver() const {
  return _internal_has_loiter_maneuver();
}
inline void Maneuver::set_has_loiter_maneuver() {
  _impl_._oneof_case_[0] = kLoiterManeuver;
}
inline void Maneuver::clear_loiter_maneuver() {
  if (_internal_has_loiter_maneuver()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ManeuverUnion_.loiter_maneuver_;
    }
    clear_has_ManeuverUnion();
  }
}
inline ::IMC_DCCL::Loiter* Maneuver::release_loiter_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.loiter_maneuver)
  if (_internal_has_loiter_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::Loiter* temp = _impl_.ManeuverUnion_.loiter_maneuver_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ManeuverUnion_.loiter_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IMC_DCCL::Loiter& Maneuver::_internal_loiter_maneuver() const {
  return _internal_has_loiter_maneuver()
      ? *_impl_.ManeuverUnion_.loiter_maneuver_
      : reinterpret_cast< ::IMC_DCCL::Loiter&>(::IMC_DCCL::_Loiter_default_instance_);
}
inline const ::IMC_DCCL::Loiter& Maneuver::loiter_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.loiter_maneuver)
  return _internal_loiter_maneuver();
}
inline ::IMC_DCCL::Loiter* Maneuver::unsafe_arena_release_loiter_maneuver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IMC_DCCL.Maneuver.loiter_maneuver)
  if (_internal_has_loiter_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::Loiter* temp = _impl_.ManeuverUnion_.loiter_maneuver_;
    _impl_.ManeuverUnion_.loiter_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Maneuver::unsafe_arena_set_allocated_loiter_maneuver(::IMC_DCCL::Loiter* loiter_maneuver) {
  clear_ManeuverUnion();
  if (loiter_maneuver) {
    set_has_loiter_maneuver();
    _impl_.ManeuverUnion_.loiter_maneuver_ = loiter_maneuver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.Maneuver.loiter_maneuver)
}
inline ::IMC_DCCL::Loiter* Maneuver::_internal_mutable_loiter_maneuver() {
  if (!_internal_has_loiter_maneuver()) {
    clear_ManeuverUnion();
    set_has_loiter_maneuver();
    _impl_.ManeuverUnion_.loiter_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::Loiter >(GetArenaForAllocation());
  }
  return _impl_.ManeuverUnion_.loiter_maneuver_;
}
inline ::IMC_DCCL::Loiter* Maneuver::mutable_loiter_maneuver() {
  ::IMC_DCCL::Loiter* _msg = _internal_mutable_loiter_maneuver();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.loiter_maneuver)
  return _msg;
}

// .IMC_DCCL.StationKeeping stationkeeping_maneuver = 4;
inline bool Maneuver::_internal_has_stationkeeping_maneuver() const {
  return ManeuverUnion_case() == kStationkeepingManeuver;
}
inline bool Maneuver::has_stationkeeping_maneuver() const {
  return _internal_has_stationkeeping_maneuver();
}
inline void Maneuver::set_has_stationkeeping_maneuver() {
  _impl_._oneof_case_[0] = kStationkeepingManeuver;
}
inline void Maneuver::clear_stationkeeping_maneuver() {
  if (_internal_has_stationkeeping_maneuver()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.ManeuverUnion_.stationkeeping_maneuver_;
    }
    clear_has_ManeuverUnion();
  }
}
inline ::IMC_DCCL::StationKeeping* Maneuver::release_stationkeeping_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.stationkeeping_maneuver)
  if (_internal_has_stationkeeping_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::StationKeeping* temp = _impl_.ManeuverUnion_.stationkeeping_maneuver_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.ManeuverUnion_.stationkeeping_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::IMC_DCCL::StationKeeping& Maneuver::_internal_stationkeeping_maneuver() const {
  return _internal_has_stationkeeping_maneuver()
      ? *_impl_.ManeuverUnion_.stationkeeping_maneuver_
      : reinterpret_cast< ::IMC_DCCL::StationKeeping&>(::IMC_DCCL::_StationKeeping_default_instance_);
}
inline const ::IMC_DCCL::StationKeeping& Maneuver::stationkeeping_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.stationkeeping_maneuver)
  return _internal_stationkeeping_maneuver();
}
inline ::IMC_DCCL::StationKeeping* Maneuver::unsafe_arena_release_stationkeeping_maneuver() {
  // @@protoc_insertion_point(field_unsafe_arena_release:IMC_DCCL.Maneuver.stationkeeping_maneuver)
  if (_internal_has_stationkeeping_maneuver()) {
    clear_has_ManeuverUnion();
    ::IMC_DCCL::StationKeeping* temp = _impl_.ManeuverUnion_.stationkeeping_maneuver_;
    _impl_.ManeuverUnion_.stationkeeping_maneuver_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Maneuver::unsafe_arena_set_allocated_stationkeeping_maneuver(::IMC_DCCL::StationKeeping* stationkeeping_maneuver) {
  clear_ManeuverUnion();
  if (stationkeeping_maneuver) {
    set_has_stationkeeping_maneuver();
    _impl_.ManeuverUnion_.stationkeeping_maneuver_ = stationkeeping_maneuver;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.Maneuver.stationkeeping_maneuver)
}
inline ::IMC_DCCL::StationKeeping* Maneuver::_internal_mutable_stationkeeping_maneuver() {
  if (!_internal_has_stationkeeping_maneuver()) {
    clear_ManeuverUnion();
    set_has_stationkeeping_maneuver();
    _impl_.ManeuverUnion_.stationkeeping_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::StationKeeping >(GetArenaForAllocation());
  }
  return _impl_.ManeuverUnion_.stationkeeping_maneuver_;
}
inline ::IMC_DCCL::StationKeeping* Maneuver::mutable_stationkeeping_maneuver() {
  ::IMC_DCCL::StationKeeping* _msg = _internal_mutable_stationkeeping_maneuver();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.stationkeeping_maneuver)
  return _msg;
}

inline bool Maneuver::has_ManeuverUnion() const {
  return ManeuverUnion_case() != MANEUVERUNION_NOT_SET;
}
inline void Maneuver::clear_has_ManeuverUnion() {
  _impl_._oneof_case_[0] = MANEUVERUNION_NOT_SET;
}
inline Maneuver::ManeuverUnionCase Maneuver::ManeuverUnion_case() const {
  return Maneuver::ManeuverUnionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// ParameterValue

// float value_number = 1 [(.dccl.field) = {
inline bool ParameterValue::_internal_has_value_number() const {
  return ParameterValueUnion_case() == kValueNumber;
}
inline bool ParameterValue::has_value_number() const {
  return _internal_has_value_number();
}
inline void ParameterValue::set_has_value_number() {
  _impl_._oneof_case_[0] = kValueNumber;
}
inline void ParameterValue::clear_value_number() {
  if (_internal_has_value_number()) {
    _impl_.ParameterValueUnion_.value_number_ = 0;
    clear_has_ParameterValueUnion();
  }
}
inline float ParameterValue::_internal_value_number() const {
  if (_internal_has_value_number()) {
    return _impl_.ParameterValueUnion_.value_number_;
  }
  return 0;
}
inline void ParameterValue::_internal_set_value_number(float value) {
  if (!_internal_has_value_number()) {
    clear_ParameterValueUnion();
    set_has_value_number();
  }
  _impl_.ParameterValueUnion_.value_number_ = value;
}
inline float ParameterValue::value_number() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ParameterValue.value_number)
  return _internal_value_number();
}
inline void ParameterValue::set_value_number(float value) {
  _internal_set_value_number(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.ParameterValue.value_number)
}

// .IMC_DCCL.ParamValue value_string = 2;
inline bool ParameterValue::_internal_has_value_string() const {
  return ParameterValueUnion_case() == kValueString;
}
inline bool ParameterValue::has_value_string() const {
  return _internal_has_value_string();
}
inline void ParameterValue::set_has_value_string() {
  _impl_._oneof_case_[0] = kValueString;
}
inline void ParameterValue::clear_value_string() {
  if (_internal_has_value_string()) {
    _impl_.ParameterValueUnion_.value_string_ = 0;
    clear_has_ParameterValueUnion();
  }
}
inline ::IMC_DCCL::ParamValue ParameterValue::_internal_value_string() const {
  if (_internal_has_value_string()) {
    return static_cast< ::IMC_DCCL::ParamValue >(_impl_.ParameterValueUnion_.value_string_);
  }
  return static_cast< ::IMC_DCCL::ParamValue >(0);
}
inline ::IMC_DCCL::ParamValue ParameterValue::value_string() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ParameterValue.value_string)
  return _internal_value_string();
}
inline void ParameterValue::_internal_set_value_string(::IMC_DCCL::ParamValue value) {
  if (!_internal_has_value_string()) {
    clear_ParameterValueUnion();
    set_has_value_string();
  }
  _impl_.ParameterValueUnion_.value_string_ = value;
}
inline void ParameterValue::set_value_string(::IMC_DCCL::ParamValue value) {
  _internal_set_value_string(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.ParameterValue.value_string)
}

inline bool ParameterValue::has_ParameterValueUnion() const {
  return ParameterValueUnion_case() != PARAMETERVALUEUNION_NOT_SET;
}
inline void ParameterValue::clear_has_ParameterValueUnion() {
  _impl_._oneof_case_[0] = PARAMETERVALUEUNION_NOT_SET;
}
inline ParameterValue::ParameterValueUnionCase ParameterValue::ParameterValueUnion_case() const {
  return ParameterValue::ParameterValueUnionCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityParameter

// .IMC_DCCL.ParameterName name = 1;
inline void EntityParameter::clear_name() {
  _impl_.name_ = 0;
}
inline ::IMC_DCCL::ParameterName EntityParameter::_internal_name() const {
  return static_cast< ::IMC_DCCL::ParameterName >(_impl_.name_);
}
inline ::IMC_DCCL::ParameterName EntityParameter::name() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameter.name)
  return _internal_name();
}
inline void EntityParameter::_internal_set_name(::IMC_DCCL::ParameterName value) {
  
  _impl_.name_ = value;
}
inline void EntityParameter::set_name(::IMC_DCCL::ParameterName value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EntityParameter.name)
}

// .IMC_DCCL.ParameterValue value = 2;
inline bool EntityParameter::_internal_has_value() const {
  return this != internal_default_instance() && _impl_.value_ != nullptr;
}
inline bool EntityParameter::has_value() const {
  return _internal_has_value();
}
inline void EntityParameter::clear_value() {
  if (GetArenaForAllocation() == nullptr && _impl_.value_ != nullptr) {
    delete _impl_.value_;
  }
  _impl_.value_ = nullptr;
}
inline const ::IMC_DCCL::ParameterValue& EntityParameter::_internal_value() const {
  const ::IMC_DCCL::ParameterValue* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::ParameterValue&>(
      ::IMC_DCCL::_ParameterValue_default_instance_);
}
inline const ::IMC_DCCL::ParameterValue& EntityParameter::value() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameter.value)
  return _internal_value();
}
inline void EntityParameter::unsafe_arena_set_allocated_value(
    ::IMC_DCCL::ParameterValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.EntityParameter.value)
}
inline ::IMC_DCCL::ParameterValue* EntityParameter::release_value() {
  
  ::IMC_DCCL::ParameterValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::ParameterValue* EntityParameter::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.EntityParameter.value)
  
  ::IMC_DCCL::ParameterValue* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::ParameterValue* EntityParameter::_internal_mutable_value() {
  
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ParameterValue>(GetArenaForAllocation());
    _impl_.value_ = p;
  }
  return _impl_.value_;
}
inline ::IMC_DCCL::ParameterValue* EntityParameter::mutable_value() {
  ::IMC_DCCL::ParameterValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.EntityParameter.value)
  return _msg;
}
inline void EntityParameter::set_allocated_value(::IMC_DCCL::ParameterValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.value_;
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(value);
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.value_ = value;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.EntityParameter.value)
}

// -------------------------------------------------------------------

// EntityParameters

// .IMC_DCCL.EntityName name = 1;
inline void EntityParameters::clear_name() {
  _impl_.name_ = 0;
}
inline ::IMC_DCCL::EntityName EntityParameters::_internal_name() const {
  return static_cast< ::IMC_DCCL::EntityName >(_impl_.name_);
}
inline ::IMC_DCCL::EntityName EntityParameters::name() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameters.name)
  return _internal_name();
}
inline void EntityParameters::_internal_set_name(::IMC_DCCL::EntityName value) {
  
  _impl_.name_ = value;
}
inline void EntityParameters::set_name(::IMC_DCCL::EntityName value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.EntityParameters.name)
}

// repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
inline int EntityParameters::_internal_params_size() const {
  return _impl_.params_.size();
}
inline int EntityParameters::params_size() const {
  return _internal_params_size();
}
inline void EntityParameters::clear_params() {
  _impl_.params_.Clear();
}
inline ::IMC_DCCL::EntityParameter* EntityParameters::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.EntityParameters.params)
  return _impl_.params_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameter >*
EntityParameters::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.EntityParameters.params)
  return &_impl_.params_;
}
inline const ::IMC_DCCL::EntityParameter& EntityParameters::_internal_params(int index) const {
  return _impl_.params_.Get(index);
}
inline const ::IMC_DCCL::EntityParameter& EntityParameters::params(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameters.params)
  return _internal_params(index);
}
inline ::IMC_DCCL::EntityParameter* EntityParameters::_internal_add_params() {
  return _impl_.params_.Add();
}
inline ::IMC_DCCL::EntityParameter* EntityParameters::add_params() {
  ::IMC_DCCL::EntityParameter* _add = _internal_add_params();
  // @@protoc_insertion_point(field_add:IMC_DCCL.EntityParameters.params)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameter >&
EntityParameters::params() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.EntityParameters.params)
  return _impl_.params_;
}

// -------------------------------------------------------------------

// ManeuverID

// .IMC_DCCL.ManeuverType maneuver_type = 1;
inline void ManeuverID::clear_maneuver_type() {
  _impl_.maneuver_type_ = 0;
}
inline ::IMC_DCCL::ManeuverType ManeuverID::_internal_maneuver_type() const {
  return static_cast< ::IMC_DCCL::ManeuverType >(_impl_.maneuver_type_);
}
inline ::IMC_DCCL::ManeuverType ManeuverID::maneuver_type() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ManeuverID.maneuver_type)
  return _internal_maneuver_type();
}
inline void ManeuverID::_internal_set_maneuver_type(::IMC_DCCL::ManeuverType value) {
  
  _impl_.maneuver_type_ = value;
}
inline void ManeuverID::set_maneuver_type(::IMC_DCCL::ManeuverType value) {
  _internal_set_maneuver_type(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.ManeuverID.maneuver_type)
}

// int32 maneuver_number = 2 [(.dccl.field) = {
inline void ManeuverID::clear_maneuver_number() {
  _impl_.maneuver_number_ = 0;
}
inline int32_t ManeuverID::_internal_maneuver_number() const {
  return _impl_.maneuver_number_;
}
inline int32_t ManeuverID::maneuver_number() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ManeuverID.maneuver_number)
  return _internal_maneuver_number();
}
inline void ManeuverID::_internal_set_maneuver_number(int32_t value) {
  
  _impl_.maneuver_number_ = value;
}
inline void ManeuverID::set_maneuver_number(int32_t value) {
  _internal_set_maneuver_number(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.ManeuverID.maneuver_number)
}

// -------------------------------------------------------------------

// PlanManeuver

// .IMC_DCCL.ManeuverID maneuver_id = 1;
inline bool PlanManeuver::_internal_has_maneuver_id() const {
  return this != internal_default_instance() && _impl_.maneuver_id_ != nullptr;
}
inline bool PlanManeuver::has_maneuver_id() const {
  return _internal_has_maneuver_id();
}
inline void PlanManeuver::clear_maneuver_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.maneuver_id_ != nullptr) {
    delete _impl_.maneuver_id_;
  }
  _impl_.maneuver_id_ = nullptr;
}
inline const ::IMC_DCCL::ManeuverID& PlanManeuver::_internal_maneuver_id() const {
  const ::IMC_DCCL::ManeuverID* p = _impl_.maneuver_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::ManeuverID&>(
      ::IMC_DCCL::_ManeuverID_default_instance_);
}
inline const ::IMC_DCCL::ManeuverID& PlanManeuver::maneuver_id() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanManeuver.maneuver_id)
  return _internal_maneuver_id();
}
inline void PlanManeuver::unsafe_arena_set_allocated_maneuver_id(
    ::IMC_DCCL::ManeuverID* maneuver_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.maneuver_id_);
  }
  _impl_.maneuver_id_ = maneuver_id;
  if (maneuver_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.PlanManeuver.maneuver_id)
}
inline ::IMC_DCCL::ManeuverID* PlanManeuver::release_maneuver_id() {
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.maneuver_id_;
  _impl_.maneuver_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanManeuver::unsafe_arena_release_maneuver_id() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanManeuver.maneuver_id)
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.maneuver_id_;
  _impl_.maneuver_id_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanManeuver::_internal_mutable_maneuver_id() {
  
  if (_impl_.maneuver_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaForAllocation());
    _impl_.maneuver_id_ = p;
  }
  return _impl_.maneuver_id_;
}
inline ::IMC_DCCL::ManeuverID* PlanManeuver::mutable_maneuver_id() {
  ::IMC_DCCL::ManeuverID* _msg = _internal_mutable_maneuver_id();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanManeuver.maneuver_id)
  return _msg;
}
inline void PlanManeuver::set_allocated_maneuver_id(::IMC_DCCL::ManeuverID* maneuver_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.maneuver_id_;
  }
  if (maneuver_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(maneuver_id);
    if (message_arena != submessage_arena) {
      maneuver_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maneuver_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.maneuver_id_ = maneuver_id;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanManeuver.maneuver_id)
}

// .IMC_DCCL.Maneuver data = 2;
inline bool PlanManeuver::_internal_has_data() const {
  return this != internal_default_instance() && _impl_.data_ != nullptr;
}
inline bool PlanManeuver::has_data() const {
  return _internal_has_data();
}
inline void PlanManeuver::clear_data() {
  if (GetArenaForAllocation() == nullptr && _impl_.data_ != nullptr) {
    delete _impl_.data_;
  }
  _impl_.data_ = nullptr;
}
inline const ::IMC_DCCL::Maneuver& PlanManeuver::_internal_data() const {
  const ::IMC_DCCL::Maneuver* p = _impl_.data_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::Maneuver&>(
      ::IMC_DCCL::_Maneuver_default_instance_);
}
inline const ::IMC_DCCL::Maneuver& PlanManeuver::data() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanManeuver.data)
  return _internal_data();
}
inline void PlanManeuver::unsafe_arena_set_allocated_data(
    ::IMC_DCCL::Maneuver* data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.data_);
  }
  _impl_.data_ = data;
  if (data) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.PlanManeuver.data)
}
inline ::IMC_DCCL::Maneuver* PlanManeuver::release_data() {
  
  ::IMC_DCCL::Maneuver* temp = _impl_.data_;
  _impl_.data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::Maneuver* PlanManeuver::unsafe_arena_release_data() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanManeuver.data)
  
  ::IMC_DCCL::Maneuver* temp = _impl_.data_;
  _impl_.data_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::Maneuver* PlanManeuver::_internal_mutable_data() {
  
  if (_impl_.data_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::Maneuver>(GetArenaForAllocation());
    _impl_.data_ = p;
  }
  return _impl_.data_;
}
inline ::IMC_DCCL::Maneuver* PlanManeuver::mutable_data() {
  ::IMC_DCCL::Maneuver* _msg = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanManeuver.data)
  return _msg;
}
inline void PlanManeuver::set_allocated_data(::IMC_DCCL::Maneuver* data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.data_;
  }
  if (data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(data);
    if (message_arena != submessage_arena) {
      data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.data_ = data;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanManeuver.data)
}

// repeated .IMC_DCCL.EntityParameters start_actions = 3 [(.dccl.field) = {
inline int PlanManeuver::_internal_start_actions_size() const {
  return _impl_.start_actions_.size();
}
inline int PlanManeuver::start_actions_size() const {
  return _internal_start_actions_size();
}
inline void PlanManeuver::clear_start_actions() {
  _impl_.start_actions_.Clear();
}
inline ::IMC_DCCL::EntityParameters* PlanManeuver::mutable_start_actions(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanManeuver.start_actions)
  return _impl_.start_actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
PlanManeuver::mutable_start_actions() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanManeuver.start_actions)
  return &_impl_.start_actions_;
}
inline const ::IMC_DCCL::EntityParameters& PlanManeuver::_internal_start_actions(int index) const {
  return _impl_.start_actions_.Get(index);
}
inline const ::IMC_DCCL::EntityParameters& PlanManeuver::start_actions(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanManeuver.start_actions)
  return _internal_start_actions(index);
}
inline ::IMC_DCCL::EntityParameters* PlanManeuver::_internal_add_start_actions() {
  return _impl_.start_actions_.Add();
}
inline ::IMC_DCCL::EntityParameters* PlanManeuver::add_start_actions() {
  ::IMC_DCCL::EntityParameters* _add = _internal_add_start_actions();
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanManeuver.start_actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
PlanManeuver::start_actions() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanManeuver.start_actions)
  return _impl_.start_actions_;
}

// -------------------------------------------------------------------

// PlanVariable

// string name = 1 [(.dccl.field) = {
inline void PlanVariable::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& PlanVariable::name() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanVariable::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.name)
}
inline std::string* PlanVariable::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanVariable.name)
  return _s;
}
inline const std::string& PlanVariable::_internal_name() const {
  return _impl_.name_.Get();
}
inline void PlanVariable::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanVariable::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanVariable::release_name() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanVariable.name)
  return _impl_.name_.Release();
}
inline void PlanVariable::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanVariable.name)
}

// string value = 2 [(.dccl.field) = {
inline void PlanVariable::clear_value() {
  _impl_.value_.ClearToEmpty();
}
inline const std::string& PlanVariable::value() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanVariable::set_value(ArgT0&& arg0, ArgT... args) {
 
 _impl_.value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.value)
}
inline std::string* PlanVariable::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanVariable.value)
  return _s;
}
inline const std::string& PlanVariable::_internal_value() const {
  return _impl_.value_.Get();
}
inline void PlanVariable::_internal_set_value(const std::string& value) {
  
  _impl_.value_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanVariable::_internal_mutable_value() {
  
  return _impl_.value_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanVariable::release_value() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanVariable.value)
  return _impl_.value_.Release();
}
inline void PlanVariable::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  _impl_.value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.value_.IsDefault()) {
    _impl_.value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanVariable.value)
}

// .IMC_DCCL.Type type = 3;
inline void PlanVariable::clear_type() {
  _impl_.type_ = 0;
}
inline ::IMC_DCCL::Type PlanVariable::_internal_type() const {
  return static_cast< ::IMC_DCCL::Type >(_impl_.type_);
}
inline ::IMC_DCCL::Type PlanVariable::type() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.type)
  return _internal_type();
}
inline void PlanVariable::_internal_set_type(::IMC_DCCL::Type value) {
  
  _impl_.type_ = value;
}
inline void PlanVariable::set_type(::IMC_DCCL::Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.type)
}

// .IMC_DCCL.AccessType access = 4;
inline void PlanVariable::clear_access() {
  _impl_.access_ = 0;
}
inline ::IMC_DCCL::AccessType PlanVariable::_internal_access() const {
  return static_cast< ::IMC_DCCL::AccessType >(_impl_.access_);
}
inline ::IMC_DCCL::AccessType PlanVariable::access() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.access)
  return _internal_access();
}
inline void PlanVariable::_internal_set_access(::IMC_DCCL::AccessType value) {
  
  _impl_.access_ = value;
}
inline void PlanVariable::set_access(::IMC_DCCL::AccessType value) {
  _internal_set_access(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.access)
}

// -------------------------------------------------------------------

// PlanTransition

// .IMC_DCCL.ManeuverID source_man = 1;
inline bool PlanTransition::_internal_has_source_man() const {
  return this != internal_default_instance() && _impl_.source_man_ != nullptr;
}
inline bool PlanTransition::has_source_man() const {
  return _internal_has_source_man();
}
inline void PlanTransition::clear_source_man() {
  if (GetArenaForAllocation() == nullptr && _impl_.source_man_ != nullptr) {
    delete _impl_.source_man_;
  }
  _impl_.source_man_ = nullptr;
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::_internal_source_man() const {
  const ::IMC_DCCL::ManeuverID* p = _impl_.source_man_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::ManeuverID&>(
      ::IMC_DCCL::_ManeuverID_default_instance_);
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::source_man() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanTransition.source_man)
  return _internal_source_man();
}
inline void PlanTransition::unsafe_arena_set_allocated_source_man(
    ::IMC_DCCL::ManeuverID* source_man) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.source_man_);
  }
  _impl_.source_man_ = source_man;
  if (source_man) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.PlanTransition.source_man)
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::release_source_man() {
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.source_man_;
  _impl_.source_man_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::unsafe_arena_release_source_man() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanTransition.source_man)
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.source_man_;
  _impl_.source_man_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::_internal_mutable_source_man() {
  
  if (_impl_.source_man_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaForAllocation());
    _impl_.source_man_ = p;
  }
  return _impl_.source_man_;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::mutable_source_man() {
  ::IMC_DCCL::ManeuverID* _msg = _internal_mutable_source_man();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanTransition.source_man)
  return _msg;
}
inline void PlanTransition::set_allocated_source_man(::IMC_DCCL::ManeuverID* source_man) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.source_man_;
  }
  if (source_man) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(source_man);
    if (message_arena != submessage_arena) {
      source_man = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source_man, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.source_man_ = source_man;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanTransition.source_man)
}

// .IMC_DCCL.ManeuverID dest_man = 2;
inline bool PlanTransition::_internal_has_dest_man() const {
  return this != internal_default_instance() && _impl_.dest_man_ != nullptr;
}
inline bool PlanTransition::has_dest_man() const {
  return _internal_has_dest_man();
}
inline void PlanTransition::clear_dest_man() {
  if (GetArenaForAllocation() == nullptr && _impl_.dest_man_ != nullptr) {
    delete _impl_.dest_man_;
  }
  _impl_.dest_man_ = nullptr;
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::_internal_dest_man() const {
  const ::IMC_DCCL::ManeuverID* p = _impl_.dest_man_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::ManeuverID&>(
      ::IMC_DCCL::_ManeuverID_default_instance_);
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::dest_man() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanTransition.dest_man)
  return _internal_dest_man();
}
inline void PlanTransition::unsafe_arena_set_allocated_dest_man(
    ::IMC_DCCL::ManeuverID* dest_man) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.dest_man_);
  }
  _impl_.dest_man_ = dest_man;
  if (dest_man) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.PlanTransition.dest_man)
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::release_dest_man() {
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.dest_man_;
  _impl_.dest_man_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::unsafe_arena_release_dest_man() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanTransition.dest_man)
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.dest_man_;
  _impl_.dest_man_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::_internal_mutable_dest_man() {
  
  if (_impl_.dest_man_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaForAllocation());
    _impl_.dest_man_ = p;
  }
  return _impl_.dest_man_;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::mutable_dest_man() {
  ::IMC_DCCL::ManeuverID* _msg = _internal_mutable_dest_man();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanTransition.dest_man)
  return _msg;
}
inline void PlanTransition::set_allocated_dest_man(::IMC_DCCL::ManeuverID* dest_man) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.dest_man_;
  }
  if (dest_man) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(dest_man);
    if (message_arena != submessage_arena) {
      dest_man = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest_man, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.dest_man_ = dest_man;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanTransition.dest_man)
}

// .IMC_DCCL.TransitionCondition conditions = 3;
inline void PlanTransition::clear_conditions() {
  _impl_.conditions_ = 0;
}
inline ::IMC_DCCL::TransitionCondition PlanTransition::_internal_conditions() const {
  return static_cast< ::IMC_DCCL::TransitionCondition >(_impl_.conditions_);
}
inline ::IMC_DCCL::TransitionCondition PlanTransition::conditions() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanTransition.conditions)
  return _internal_conditions();
}
inline void PlanTransition::_internal_set_conditions(::IMC_DCCL::TransitionCondition value) {
  
  _impl_.conditions_ = value;
}
inline void PlanTransition::set_conditions(::IMC_DCCL::TransitionCondition value) {
  _internal_set_conditions(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanTransition.conditions)
}

// -------------------------------------------------------------------

// Header

// int32 src = 1 [(.dccl.field) = {
inline void Header::clear_src() {
  _impl_.src_ = 0;
}
inline int32_t Header::_internal_src() const {
  return _impl_.src_;
}
inline int32_t Header::src() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.src)
  return _internal_src();
}
inline void Header::_internal_set_src(int32_t value) {
  
  _impl_.src_ = value;
}
inline void Header::set_src(int32_t value) {
  _internal_set_src(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.src)
}

// int32 src_ent = 2 [(.dccl.field) = {
inline void Header::clear_src_ent() {
  _impl_.src_ent_ = 0;
}
inline int32_t Header::_internal_src_ent() const {
  return _impl_.src_ent_;
}
inline int32_t Header::src_ent() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.src_ent)
  return _internal_src_ent();
}
inline void Header::_internal_set_src_ent(int32_t value) {
  
  _impl_.src_ent_ = value;
}
inline void Header::set_src_ent(int32_t value) {
  _internal_set_src_ent(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.src_ent)
}

// int32 dst = 3 [(.dccl.field) = {
inline void Header::clear_dst() {
  _impl_.dst_ = 0;
}
inline int32_t Header::_internal_dst() const {
  return _impl_.dst_;
}
inline int32_t Header::dst() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.dst)
  return _internal_dst();
}
inline void Header::_internal_set_dst(int32_t value) {
  
  _impl_.dst_ = value;
}
inline void Header::set_dst(int32_t value) {
  _internal_set_dst(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.dst)
}

// int32 dst_ent = 4 [(.dccl.field) = {
inline void Header::clear_dst_ent() {
  _impl_.dst_ent_ = 0;
}
inline int32_t Header::_internal_dst_ent() const {
  return _impl_.dst_ent_;
}
inline int32_t Header::dst_ent() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.dst_ent)
  return _internal_dst_ent();
}
inline void Header::_internal_set_dst_ent(int32_t value) {
  
  _impl_.dst_ent_ = value;
}
inline void Header::set_dst_ent(int32_t value) {
  _internal_set_dst_ent(value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.dst_ent)
}

// -------------------------------------------------------------------

// PlanSpecification

// string plan_id = 1 [(.dccl.field) = {
inline void PlanSpecification::clear_plan_id() {
  _impl_.plan_id_.ClearToEmpty();
}
inline const std::string& PlanSpecification::plan_id() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.plan_id)
  return _internal_plan_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanSpecification::set_plan_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.plan_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanSpecification.plan_id)
}
inline std::string* PlanSpecification::mutable_plan_id() {
  std::string* _s = _internal_mutable_plan_id();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.plan_id)
  return _s;
}
inline const std::string& PlanSpecification::_internal_plan_id() const {
  return _impl_.plan_id_.Get();
}
inline void PlanSpecification::_internal_set_plan_id(const std::string& value) {
  
  _impl_.plan_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanSpecification::_internal_mutable_plan_id() {
  
  return _impl_.plan_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanSpecification::release_plan_id() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.plan_id)
  return _impl_.plan_id_.Release();
}
inline void PlanSpecification::set_allocated_plan_id(std::string* plan_id) {
  if (plan_id != nullptr) {
    
  } else {
    
  }
  _impl_.plan_id_.SetAllocated(plan_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.plan_id_.IsDefault()) {
    _impl_.plan_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.plan_id)
}

// string description = 2 [(.dccl.field) = {
inline void PlanSpecification::clear_description() {
  _impl_.description_.ClearToEmpty();
}
inline const std::string& PlanSpecification::description() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanSpecification::set_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanSpecification.description)
}
inline std::string* PlanSpecification::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.description)
  return _s;
}
inline const std::string& PlanSpecification::_internal_description() const {
  return _impl_.description_.Get();
}
inline void PlanSpecification::_internal_set_description(const std::string& value) {
  
  _impl_.description_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanSpecification::_internal_mutable_description() {
  
  return _impl_.description_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanSpecification::release_description() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.description)
  return _impl_.description_.Release();
}
inline void PlanSpecification::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  _impl_.description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.description_.IsDefault()) {
    _impl_.description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.description)
}

// string vnamespace = 3 [(.dccl.field) = {
inline void PlanSpecification::clear_vnamespace() {
  _impl_.vnamespace_.ClearToEmpty();
}
inline const std::string& PlanSpecification::vnamespace() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.vnamespace)
  return _internal_vnamespace();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlanSpecification::set_vnamespace(ArgT0&& arg0, ArgT... args) {
 
 _impl_.vnamespace_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanSpecification.vnamespace)
}
inline std::string* PlanSpecification::mutable_vnamespace() {
  std::string* _s = _internal_mutable_vnamespace();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.vnamespace)
  return _s;
}
inline const std::string& PlanSpecification::_internal_vnamespace() const {
  return _impl_.vnamespace_.Get();
}
inline void PlanSpecification::_internal_set_vnamespace(const std::string& value) {
  
  _impl_.vnamespace_.Set(value, GetArenaForAllocation());
}
inline std::string* PlanSpecification::_internal_mutable_vnamespace() {
  
  return _impl_.vnamespace_.Mutable(GetArenaForAllocation());
}
inline std::string* PlanSpecification::release_vnamespace() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.vnamespace)
  return _impl_.vnamespace_.Release();
}
inline void PlanSpecification::set_allocated_vnamespace(std::string* vnamespace) {
  if (vnamespace != nullptr) {
    
  } else {
    
  }
  _impl_.vnamespace_.SetAllocated(vnamespace, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.vnamespace_.IsDefault()) {
    _impl_.vnamespace_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.vnamespace)
}

// .IMC_DCCL.ManeuverID start_man_id = 4;
inline bool PlanSpecification::_internal_has_start_man_id() const {
  return this != internal_default_instance() && _impl_.start_man_id_ != nullptr;
}
inline bool PlanSpecification::has_start_man_id() const {
  return _internal_has_start_man_id();
}
inline void PlanSpecification::clear_start_man_id() {
  if (GetArenaForAllocation() == nullptr && _impl_.start_man_id_ != nullptr) {
    delete _impl_.start_man_id_;
  }
  _impl_.start_man_id_ = nullptr;
}
inline const ::IMC_DCCL::ManeuverID& PlanSpecification::_internal_start_man_id() const {
  const ::IMC_DCCL::ManeuverID* p = _impl_.start_man_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::ManeuverID&>(
      ::IMC_DCCL::_ManeuverID_default_instance_);
}
inline const ::IMC_DCCL::ManeuverID& PlanSpecification::start_man_id() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.start_man_id)
  return _internal_start_man_id();
}
inline void PlanSpecification::unsafe_arena_set_allocated_start_man_id(
    ::IMC_DCCL::ManeuverID* start_man_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.start_man_id_);
  }
  _impl_.start_man_id_ = start_man_id;
  if (start_man_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.PlanSpecification.start_man_id)
}
inline ::IMC_DCCL::ManeuverID* PlanSpecification::release_start_man_id() {
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.start_man_id_;
  _impl_.start_man_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanSpecification::unsafe_arena_release_start_man_id() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.start_man_id)
  
  ::IMC_DCCL::ManeuverID* temp = _impl_.start_man_id_;
  _impl_.start_man_id_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanSpecification::_internal_mutable_start_man_id() {
  
  if (_impl_.start_man_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaForAllocation());
    _impl_.start_man_id_ = p;
  }
  return _impl_.start_man_id_;
}
inline ::IMC_DCCL::ManeuverID* PlanSpecification::mutable_start_man_id() {
  ::IMC_DCCL::ManeuverID* _msg = _internal_mutable_start_man_id();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.start_man_id)
  return _msg;
}
inline void PlanSpecification::set_allocated_start_man_id(::IMC_DCCL::ManeuverID* start_man_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.start_man_id_;
  }
  if (start_man_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(start_man_id);
    if (message_arena != submessage_arena) {
      start_man_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, start_man_id, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.start_man_id_ = start_man_id;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.start_man_id)
}

// repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
inline int PlanSpecification::_internal_maneuvers_size() const {
  return _impl_.maneuvers_.size();
}
inline int PlanSpecification::maneuvers_size() const {
  return _internal_maneuvers_size();
}
inline void PlanSpecification::clear_maneuvers() {
  _impl_.maneuvers_.Clear();
}
inline ::IMC_DCCL::PlanManeuver* PlanSpecification::mutable_maneuvers(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.maneuvers)
  return _impl_.maneuvers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >*
PlanSpecification::mutable_maneuvers() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.maneuvers)
  return &_impl_.maneuvers_;
}
inline const ::IMC_DCCL::PlanManeuver& PlanSpecification::_internal_maneuvers(int index) const {
  return _impl_.maneuvers_.Get(index);
}
inline const ::IMC_DCCL::PlanManeuver& PlanSpecification::maneuvers(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.maneuvers)
  return _internal_maneuvers(index);
}
inline ::IMC_DCCL::PlanManeuver* PlanSpecification::_internal_add_maneuvers() {
  return _impl_.maneuvers_.Add();
}
inline ::IMC_DCCL::PlanManeuver* PlanSpecification::add_maneuvers() {
  ::IMC_DCCL::PlanManeuver* _add = _internal_add_maneuvers();
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.maneuvers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >&
PlanSpecification::maneuvers() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.maneuvers)
  return _impl_.maneuvers_;
}

// repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
inline int PlanSpecification::_internal_transitions_size() const {
  return _impl_.transitions_.size();
}
inline int PlanSpecification::transitions_size() const {
  return _internal_transitions_size();
}
inline void PlanSpecification::clear_transitions() {
  _impl_.transitions_.Clear();
}
inline ::IMC_DCCL::PlanTransition* PlanSpecification::mutable_transitions(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.transitions)
  return _impl_.transitions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanTransition >*
PlanSpecification::mutable_transitions() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.transitions)
  return &_impl_.transitions_;
}
inline const ::IMC_DCCL::PlanTransition& PlanSpecification::_internal_transitions(int index) const {
  return _impl_.transitions_.Get(index);
}
inline const ::IMC_DCCL::PlanTransition& PlanSpecification::transitions(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.transitions)
  return _internal_transitions(index);
}
inline ::IMC_DCCL::PlanTransition* PlanSpecification::_internal_add_transitions() {
  return _impl_.transitions_.Add();
}
inline ::IMC_DCCL::PlanTransition* PlanSpecification::add_transitions() {
  ::IMC_DCCL::PlanTransition* _add = _internal_add_transitions();
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.transitions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanTransition >&
PlanSpecification::transitions() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.transitions)
  return _impl_.transitions_;
}

// repeated .IMC_DCCL.EntityParameters start_actions = 7 [(.dccl.field) = {
inline int PlanSpecification::_internal_start_actions_size() const {
  return _impl_.start_actions_.size();
}
inline int PlanSpecification::start_actions_size() const {
  return _internal_start_actions_size();
}
inline void PlanSpecification::clear_start_actions() {
  _impl_.start_actions_.Clear();
}
inline ::IMC_DCCL::EntityParameters* PlanSpecification::mutable_start_actions(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.start_actions)
  return _impl_.start_actions_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
PlanSpecification::mutable_start_actions() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.start_actions)
  return &_impl_.start_actions_;
}
inline const ::IMC_DCCL::EntityParameters& PlanSpecification::_internal_start_actions(int index) const {
  return _impl_.start_actions_.Get(index);
}
inline const ::IMC_DCCL::EntityParameters& PlanSpecification::start_actions(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.start_actions)
  return _internal_start_actions(index);
}
inline ::IMC_DCCL::EntityParameters* PlanSpecification::_internal_add_start_actions() {
  return _impl_.start_actions_.Add();
}
inline ::IMC_DCCL::EntityParameters* PlanSpecification::add_start_actions() {
  ::IMC_DCCL::EntityParameters* _add = _internal_add_start_actions();
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.start_actions)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
PlanSpecification::start_actions() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.start_actions)
  return _impl_.start_actions_;
}

// repeated .IMC_DCCL.PlanVariable variables = 8 [(.dccl.field) = {
inline int PlanSpecification::_internal_variables_size() const {
  return _impl_.variables_.size();
}
inline int PlanSpecification::variables_size() const {
  return _internal_variables_size();
}
inline void PlanSpecification::clear_variables() {
  _impl_.variables_.Clear();
}
inline ::IMC_DCCL::PlanVariable* PlanSpecification::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.variables)
  return _impl_.variables_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanVariable >*
PlanSpecification::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.variables)
  return &_impl_.variables_;
}
inline const ::IMC_DCCL::PlanVariable& PlanSpecification::_internal_variables(int index) const {
  return _impl_.variables_.Get(index);
}
inline const ::IMC_DCCL::PlanVariable& PlanSpecification::variables(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.variables)
  return _internal_variables(index);
}
inline ::IMC_DCCL::PlanVariable* PlanSpecification::_internal_add_variables() {
  return _impl_.variables_.Add();
}
inline ::IMC_DCCL::PlanVariable* PlanSpecification::add_variables() {
  ::IMC_DCCL::PlanVariable* _add = _internal_add_variables();
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.variables)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::IMC_DCCL::PlanVariable >&
PlanSpecification::variables() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.variables)
  return _impl_.variables_;
}

// .IMC_DCCL.Header head = 9;
inline bool PlanSpecification::_internal_has_head() const {
  return this != internal_default_instance() && _impl_.head_ != nullptr;
}
inline bool PlanSpecification::has_head() const {
  return _internal_has_head();
}
inline void PlanSpecification::clear_head() {
  if (GetArenaForAllocation() == nullptr && _impl_.head_ != nullptr) {
    delete _impl_.head_;
  }
  _impl_.head_ = nullptr;
}
inline const ::IMC_DCCL::Header& PlanSpecification::_internal_head() const {
  const ::IMC_DCCL::Header* p = _impl_.head_;
  return p != nullptr ? *p : reinterpret_cast<const ::IMC_DCCL::Header&>(
      ::IMC_DCCL::_Header_default_instance_);
}
inline const ::IMC_DCCL::Header& PlanSpecification::head() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.head)
  return _internal_head();
}
inline void PlanSpecification::unsafe_arena_set_allocated_head(
    ::IMC_DCCL::Header* head) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.head_);
  }
  _impl_.head_ = head;
  if (head) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:IMC_DCCL.PlanSpecification.head)
}
inline ::IMC_DCCL::Header* PlanSpecification::release_head() {
  
  ::IMC_DCCL::Header* temp = _impl_.head_;
  _impl_.head_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::IMC_DCCL::Header* PlanSpecification::unsafe_arena_release_head() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.head)
  
  ::IMC_DCCL::Header* temp = _impl_.head_;
  _impl_.head_ = nullptr;
  return temp;
}
inline ::IMC_DCCL::Header* PlanSpecification::_internal_mutable_head() {
  
  if (_impl_.head_ == nullptr) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::Header>(GetArenaForAllocation());
    _impl_.head_ = p;
  }
  return _impl_.head_;
}
inline ::IMC_DCCL::Header* PlanSpecification::mutable_head() {
  ::IMC_DCCL::Header* _msg = _internal_mutable_head();
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.head)
  return _msg;
}
inline void PlanSpecification::set_allocated_head(::IMC_DCCL::Header* head) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.head_;
  }
  if (head) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(head);
    if (message_arena != submessage_arena) {
      head = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.head_ = head;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.head)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IMC_DCCL

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::IMC_DCCL::ZUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ZUnits>() {
  return ::IMC_DCCL::ZUnits_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::SpeedUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::SpeedUnits>() {
  return ::IMC_DCCL::SpeedUnits_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::LoiterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::LoiterType>() {
  return ::IMC_DCCL::LoiterType_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::DirectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::DirectionType>() {
  return ::IMC_DCCL::DirectionType_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::ManeuverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ManeuverType>() {
  return ::IMC_DCCL::ManeuverType_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::ParameterName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ParameterName>() {
  return ::IMC_DCCL::ParameterName_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::ParamValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ParamValue>() {
  return ::IMC_DCCL::ParamValue_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::EntityName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::EntityName>() {
  return ::IMC_DCCL::EntityName_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::TransitionCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::TransitionCondition>() {
  return ::IMC_DCCL::TransitionCondition_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::Type>() {
  return ::IMC_DCCL::Type_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::AccessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::AccessType>() {
  return ::IMC_DCCL::AccessType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_IMC_5fDCCL_2eproto
