// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: IMC_DCCL.proto

#ifndef PROTOBUF_INCLUDED_IMC_5fDCCL_2eproto
#define PROTOBUF_INCLUDED_IMC_5fDCCL_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "dccl/option_extensions.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_IMC_5fDCCL_2eproto 

namespace protobuf_IMC_5fDCCL_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[15];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_IMC_5fDCCL_2eproto
namespace IMC_DCCL {
class EntityParameter;
class EntityParameterDefaultTypeInternal;
extern EntityParameterDefaultTypeInternal _EntityParameter_default_instance_;
class EntityParameters;
class EntityParametersDefaultTypeInternal;
extern EntityParametersDefaultTypeInternal _EntityParameters_default_instance_;
class EstimatedState;
class EstimatedStateDefaultTypeInternal;
extern EstimatedStateDefaultTypeInternal _EstimatedState_default_instance_;
class FollowPath;
class FollowPathDefaultTypeInternal;
extern FollowPathDefaultTypeInternal _FollowPath_default_instance_;
class Goto;
class GotoDefaultTypeInternal;
extern GotoDefaultTypeInternal _Goto_default_instance_;
class Header;
class HeaderDefaultTypeInternal;
extern HeaderDefaultTypeInternal _Header_default_instance_;
class Loiter;
class LoiterDefaultTypeInternal;
extern LoiterDefaultTypeInternal _Loiter_default_instance_;
class Maneuver;
class ManeuverDefaultTypeInternal;
extern ManeuverDefaultTypeInternal _Maneuver_default_instance_;
class ManeuverID;
class ManeuverIDDefaultTypeInternal;
extern ManeuverIDDefaultTypeInternal _ManeuverID_default_instance_;
class ParameterValue;
class ParameterValueDefaultTypeInternal;
extern ParameterValueDefaultTypeInternal _ParameterValue_default_instance_;
class PathPoint;
class PathPointDefaultTypeInternal;
extern PathPointDefaultTypeInternal _PathPoint_default_instance_;
class PlanManeuver;
class PlanManeuverDefaultTypeInternal;
extern PlanManeuverDefaultTypeInternal _PlanManeuver_default_instance_;
class PlanSpecification;
class PlanSpecificationDefaultTypeInternal;
extern PlanSpecificationDefaultTypeInternal _PlanSpecification_default_instance_;
class PlanTransition;
class PlanTransitionDefaultTypeInternal;
extern PlanTransitionDefaultTypeInternal _PlanTransition_default_instance_;
class PlanVariable;
class PlanVariableDefaultTypeInternal;
extern PlanVariableDefaultTypeInternal _PlanVariable_default_instance_;
}  // namespace IMC_DCCL
namespace google {
namespace protobuf {
template<> ::IMC_DCCL::EntityParameter* Arena::CreateMaybeMessage<::IMC_DCCL::EntityParameter>(Arena*);
template<> ::IMC_DCCL::EntityParameters* Arena::CreateMaybeMessage<::IMC_DCCL::EntityParameters>(Arena*);
template<> ::IMC_DCCL::EstimatedState* Arena::CreateMaybeMessage<::IMC_DCCL::EstimatedState>(Arena*);
template<> ::IMC_DCCL::FollowPath* Arena::CreateMaybeMessage<::IMC_DCCL::FollowPath>(Arena*);
template<> ::IMC_DCCL::Goto* Arena::CreateMaybeMessage<::IMC_DCCL::Goto>(Arena*);
template<> ::IMC_DCCL::Header* Arena::CreateMaybeMessage<::IMC_DCCL::Header>(Arena*);
template<> ::IMC_DCCL::Loiter* Arena::CreateMaybeMessage<::IMC_DCCL::Loiter>(Arena*);
template<> ::IMC_DCCL::Maneuver* Arena::CreateMaybeMessage<::IMC_DCCL::Maneuver>(Arena*);
template<> ::IMC_DCCL::ManeuverID* Arena::CreateMaybeMessage<::IMC_DCCL::ManeuverID>(Arena*);
template<> ::IMC_DCCL::ParameterValue* Arena::CreateMaybeMessage<::IMC_DCCL::ParameterValue>(Arena*);
template<> ::IMC_DCCL::PathPoint* Arena::CreateMaybeMessage<::IMC_DCCL::PathPoint>(Arena*);
template<> ::IMC_DCCL::PlanManeuver* Arena::CreateMaybeMessage<::IMC_DCCL::PlanManeuver>(Arena*);
template<> ::IMC_DCCL::PlanSpecification* Arena::CreateMaybeMessage<::IMC_DCCL::PlanSpecification>(Arena*);
template<> ::IMC_DCCL::PlanTransition* Arena::CreateMaybeMessage<::IMC_DCCL::PlanTransition>(Arena*);
template<> ::IMC_DCCL::PlanVariable* Arena::CreateMaybeMessage<::IMC_DCCL::PlanVariable>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace IMC_DCCL {

enum ZUnits {
  NONE_ZU = 0,
  DEPTH = 1,
  ALTITUDE = 2,
  HEIGHT = 3,
  ZUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ZUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ZUnits_IsValid(int value);
const ZUnits ZUnits_MIN = NONE_ZU;
const ZUnits ZUnits_MAX = HEIGHT;
const int ZUnits_ARRAYSIZE = ZUnits_MAX + 1;

const ::google::protobuf::EnumDescriptor* ZUnits_descriptor();
inline const ::std::string& ZUnits_Name(ZUnits value) {
  return ::google::protobuf::internal::NameOfEnum(
    ZUnits_descriptor(), value);
}
inline bool ZUnits_Parse(
    const ::std::string& name, ZUnits* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ZUnits>(
    ZUnits_descriptor(), name, value);
}
enum SpeedUnits {
  METERS_PS = 0,
  RPM = 1,
  PERCENTAGE = 2,
  SpeedUnits_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SpeedUnits_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SpeedUnits_IsValid(int value);
const SpeedUnits SpeedUnits_MIN = METERS_PS;
const SpeedUnits SpeedUnits_MAX = PERCENTAGE;
const int SpeedUnits_ARRAYSIZE = SpeedUnits_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeedUnits_descriptor();
inline const ::std::string& SpeedUnits_Name(SpeedUnits value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeedUnits_descriptor(), value);
}
inline bool SpeedUnits_Parse(
    const ::std::string& name, SpeedUnits* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeedUnits>(
    SpeedUnits_descriptor(), name, value);
}
enum LoiterType {
  DEFAULT = 0,
  CIRCULAR = 1,
  RACETRACK = 2,
  EIGHT = 3,
  HOVER = 4,
  LoiterType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LoiterType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LoiterType_IsValid(int value);
const LoiterType LoiterType_MIN = DEFAULT;
const LoiterType LoiterType_MAX = HOVER;
const int LoiterType_ARRAYSIZE = LoiterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoiterType_descriptor();
inline const ::std::string& LoiterType_Name(LoiterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoiterType_descriptor(), value);
}
inline bool LoiterType_Parse(
    const ::std::string& name, LoiterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoiterType>(
    LoiterType_descriptor(), name, value);
}
enum DirectionType {
  VDEP = 0,
  CLOCKW = 1,
  CCLOCKW = 2,
  IWINDCURR = 3,
  DirectionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  DirectionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool DirectionType_IsValid(int value);
const DirectionType DirectionType_MIN = VDEP;
const DirectionType DirectionType_MAX = IWINDCURR;
const int DirectionType_ARRAYSIZE = DirectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DirectionType_descriptor();
inline const ::std::string& DirectionType_Name(DirectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DirectionType_descriptor(), value);
}
inline bool DirectionType_Parse(
    const ::std::string& name, DirectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DirectionType>(
    DirectionType_descriptor(), name, value);
}
enum ManeuverType {
  GOTO = 0,
  FOLLOWPATH = 1,
  LOITER = 2,
  ManeuverType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ManeuverType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ManeuverType_IsValid(int value);
const ManeuverType ManeuverType_MIN = GOTO;
const ManeuverType ManeuverType_MAX = LOITER;
const int ManeuverType_ARRAYSIZE = ManeuverType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ManeuverType_descriptor();
inline const ::std::string& ManeuverType_Name(ManeuverType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ManeuverType_descriptor(), value);
}
inline bool ManeuverType_Parse(
    const ::std::string& name, ManeuverType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ManeuverType>(
    ManeuverType_descriptor(), name, value);
}
enum ParameterName {
  NONE_PN = 0,
  ACTIVE = 1,
  BOTTOM_TRACK_MINIMUM_DEPTH = 2,
  HIGH_FREQ_CHANNELS = 3,
  HIGH_FREQ_RANGE = 4,
  LOW_FREQ_CHANNELS = 5,
  LOW_FREQ_RANGE = 6,
  RANGE_MULTIPLIER = 7,
  STROBE_DELAY = 8,
  SHUTTER_VALUE = 9,
  ParameterName_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParameterName_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParameterName_IsValid(int value);
const ParameterName ParameterName_MIN = NONE_PN;
const ParameterName ParameterName_MAX = SHUTTER_VALUE;
const int ParameterName_ARRAYSIZE = ParameterName_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParameterName_descriptor();
inline const ::std::string& ParameterName_Name(ParameterName value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParameterName_descriptor(), value);
}
inline bool ParameterName_Parse(
    const ::std::string& name, ParameterName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParameterName>(
    ParameterName_descriptor(), name, value);
}
enum ParamValue {
  NONE_PV = 0,
  TRUE = 1,
  FALSE = 2,
  BOTH = 3,
  ParamValue_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ParamValue_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ParamValue_IsValid(int value);
const ParamValue ParamValue_MIN = NONE_PV;
const ParamValue ParamValue_MAX = BOTH;
const int ParamValue_ARRAYSIZE = ParamValue_MAX + 1;

const ::google::protobuf::EnumDescriptor* ParamValue_descriptor();
inline const ::std::string& ParamValue_Name(ParamValue value) {
  return ::google::protobuf::internal::NameOfEnum(
    ParamValue_descriptor(), value);
}
inline bool ParamValue_Parse(
    const ::std::string& name, ParamValue* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ParamValue>(
    ParamValue_descriptor(), name, value);
}
enum EntityName {
  NONE_EN = 0,
  PATH_CONTROL = 1,
  RANGER = 2,
  ACOUSTIC_MODEM = 3,
  SIDESCAN = 4,
  CAMERA = 5,
  EntityName_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  EntityName_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool EntityName_IsValid(int value);
const EntityName EntityName_MIN = NONE_EN;
const EntityName EntityName_MAX = CAMERA;
const int EntityName_ARRAYSIZE = EntityName_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityName_descriptor();
inline const ::std::string& EntityName_Name(EntityName value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityName_descriptor(), value);
}
inline bool EntityName_Parse(
    const ::std::string& name, EntityName* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityName>(
    EntityName_descriptor(), name, value);
}
enum TransitionCondition {
  NONE_TC = 0,
  MANEUVERISDONE = 1,
  TransitionCondition_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TransitionCondition_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TransitionCondition_IsValid(int value);
const TransitionCondition TransitionCondition_MIN = NONE_TC;
const TransitionCondition TransitionCondition_MAX = MANEUVERISDONE;
const int TransitionCondition_ARRAYSIZE = TransitionCondition_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransitionCondition_descriptor();
inline const ::std::string& TransitionCondition_Name(TransitionCondition value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransitionCondition_descriptor(), value);
}
inline bool TransitionCondition_Parse(
    const ::std::string& name, TransitionCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransitionCondition>(
    TransitionCondition_descriptor(), name, value);
}
enum Type {
  BOOLEAN = 0,
  NUMBER = 1,
  TEXT = 2,
  MESSAGE = 3,
  Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Type_IsValid(int value);
const Type Type_MIN = BOOLEAN;
const Type Type_MAX = MESSAGE;
const int Type_ARRAYSIZE = Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Type_descriptor();
inline const ::std::string& Type_Name(Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Type_descriptor(), value);
}
inline bool Type_Parse(
    const ::std::string& name, Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Type>(
    Type_descriptor(), name, value);
}
enum AccessType {
  INPUT = 0,
  OUTPUT = 1,
  LOCAL = 2,
  AccessType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AccessType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AccessType_IsValid(int value);
const AccessType AccessType_MIN = INPUT;
const AccessType AccessType_MAX = LOCAL;
const int AccessType_ARRAYSIZE = AccessType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccessType_descriptor();
inline const ::std::string& AccessType_Name(AccessType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccessType_descriptor(), value);
}
inline bool AccessType_Parse(
    const ::std::string& name, AccessType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessType>(
    AccessType_descriptor(), name, value);
}
// ===================================================================

class EstimatedState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.EstimatedState) */ {
 public:
  EstimatedState();
  virtual ~EstimatedState();

  EstimatedState(const EstimatedState& from);

  inline EstimatedState& operator=(const EstimatedState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EstimatedState(EstimatedState&& from) noexcept
    : EstimatedState() {
    *this = ::std::move(from);
  }

  inline EstimatedState& operator=(EstimatedState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EstimatedState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EstimatedState* internal_default_instance() {
    return reinterpret_cast<const EstimatedState*>(
               &_EstimatedState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(EstimatedState* other);
  friend void swap(EstimatedState& a, EstimatedState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EstimatedState* New() const final {
    return CreateMaybeMessage<EstimatedState>(NULL);
  }

  EstimatedState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EstimatedState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EstimatedState& from);
  void MergeFrom(const EstimatedState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EstimatedState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float lat = 1 [(.dccl.field) = {
  void clear_lat();
  static const int kLatFieldNumber = 1;
  float lat() const;
  void set_lat(float value);

  // float lon = 2 [(.dccl.field) = {
  void clear_lon();
  static const int kLonFieldNumber = 2;
  float lon() const;
  void set_lon(float value);

  // float height = 3 [(.dccl.field) = {
  void clear_height();
  static const int kHeightFieldNumber = 3;
  float height() const;
  void set_height(float value);

  // float x = 4 [(.dccl.field) = {
  void clear_x();
  static const int kXFieldNumber = 4;
  float x() const;
  void set_x(float value);

  // float y = 5 [(.dccl.field) = {
  void clear_y();
  static const int kYFieldNumber = 5;
  float y() const;
  void set_y(float value);

  // float z = 6 [(.dccl.field) = {
  void clear_z();
  static const int kZFieldNumber = 6;
  float z() const;
  void set_z(float value);

  // float phi = 7 [(.dccl.field) = {
  void clear_phi();
  static const int kPhiFieldNumber = 7;
  float phi() const;
  void set_phi(float value);

  // float theta = 8 [(.dccl.field) = {
  void clear_theta();
  static const int kThetaFieldNumber = 8;
  float theta() const;
  void set_theta(float value);

  // float psi = 9 [(.dccl.field) = {
  void clear_psi();
  static const int kPsiFieldNumber = 9;
  float psi() const;
  void set_psi(float value);

  // float u = 10 [(.dccl.field) = {
  void clear_u();
  static const int kUFieldNumber = 10;
  float u() const;
  void set_u(float value);

  // float v = 11 [(.dccl.field) = {
  void clear_v();
  static const int kVFieldNumber = 11;
  float v() const;
  void set_v(float value);

  // float w = 12 [(.dccl.field) = {
  void clear_w();
  static const int kWFieldNumber = 12;
  float w() const;
  void set_w(float value);

  // float vx = 13 [(.dccl.field) = {
  void clear_vx();
  static const int kVxFieldNumber = 13;
  float vx() const;
  void set_vx(float value);

  // float vy = 14 [(.dccl.field) = {
  void clear_vy();
  static const int kVyFieldNumber = 14;
  float vy() const;
  void set_vy(float value);

  // float vz = 15 [(.dccl.field) = {
  void clear_vz();
  static const int kVzFieldNumber = 15;
  float vz() const;
  void set_vz(float value);

  // float p = 16 [(.dccl.field) = {
  void clear_p();
  static const int kPFieldNumber = 16;
  float p() const;
  void set_p(float value);

  // float q = 17 [(.dccl.field) = {
  void clear_q();
  static const int kQFieldNumber = 17;
  float q() const;
  void set_q(float value);

  // float r = 18 [(.dccl.field) = {
  void clear_r();
  static const int kRFieldNumber = 18;
  float r() const;
  void set_r(float value);

  // float depth = 19 [(.dccl.field) = {
  void clear_depth();
  static const int kDepthFieldNumber = 19;
  float depth() const;
  void set_depth(float value);

  // float altitude = 20 [(.dccl.field) = {
  void clear_altitude();
  static const int kAltitudeFieldNumber = 20;
  float altitude() const;
  void set_altitude(float value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.EstimatedState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float lat_;
  float lon_;
  float height_;
  float x_;
  float y_;
  float z_;
  float phi_;
  float theta_;
  float psi_;
  float u_;
  float v_;
  float w_;
  float vx_;
  float vy_;
  float vz_;
  float p_;
  float q_;
  float r_;
  float depth_;
  float altitude_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Goto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Goto) */ {
 public:
  Goto();
  virtual ~Goto();

  Goto(const Goto& from);

  inline Goto& operator=(const Goto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Goto(Goto&& from) noexcept
    : Goto() {
    *this = ::std::move(from);
  }

  inline Goto& operator=(Goto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Goto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Goto* internal_default_instance() {
    return reinterpret_cast<const Goto*>(
               &_Goto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Goto* other);
  friend void swap(Goto& a, Goto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Goto* New() const final {
    return CreateMaybeMessage<Goto>(NULL);
  }

  Goto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Goto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Goto& from);
  void MergeFrom(const Goto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Goto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 timeout = 1 [(.dccl.field) = {
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  ::google::protobuf::int32 timeout() const;
  void set_timeout(::google::protobuf::int32 value);

  // float lat = 2 [(.dccl.field) = {
  void clear_lat();
  static const int kLatFieldNumber = 2;
  float lat() const;
  void set_lat(float value);

  // float lon = 3 [(.dccl.field) = {
  void clear_lon();
  static const int kLonFieldNumber = 3;
  float lon() const;
  void set_lon(float value);

  // float z = 4 [(.dccl.field) = {
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // .IMC_DCCL.ZUnits z_units = 5;
  void clear_z_units();
  static const int kZUnitsFieldNumber = 5;
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);

  // float speed = 6 [(.dccl.field) = {
  void clear_speed();
  static const int kSpeedFieldNumber = 6;
  float speed() const;
  void set_speed(float value);

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  void clear_speed_units();
  static const int kSpeedUnitsFieldNumber = 7;
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);

  // float roll = 8 [(.dccl.field) = {
  void clear_roll();
  static const int kRollFieldNumber = 8;
  float roll() const;
  void set_roll(float value);

  // float pitch = 9 [(.dccl.field) = {
  void clear_pitch();
  static const int kPitchFieldNumber = 9;
  float pitch() const;
  void set_pitch(float value);

  // float yaw = 10 [(.dccl.field) = {
  void clear_yaw();
  static const int kYawFieldNumber = 10;
  float yaw() const;
  void set_yaw(float value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.Goto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 timeout_;
  float lat_;
  float lon_;
  float z_;
  int z_units_;
  float speed_;
  int speed_units_;
  float roll_;
  float pitch_;
  float yaw_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FollowPath : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.FollowPath) */ {
 public:
  FollowPath();
  virtual ~FollowPath();

  FollowPath(const FollowPath& from);

  inline FollowPath& operator=(const FollowPath& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowPath(FollowPath&& from) noexcept
    : FollowPath() {
    *this = ::std::move(from);
  }

  inline FollowPath& operator=(FollowPath&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowPath& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowPath* internal_default_instance() {
    return reinterpret_cast<const FollowPath*>(
               &_FollowPath_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FollowPath* other);
  friend void swap(FollowPath& a, FollowPath& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowPath* New() const final {
    return CreateMaybeMessage<FollowPath>(NULL);
  }

  FollowPath* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FollowPath>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FollowPath& from);
  void MergeFrom(const FollowPath& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FollowPath* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 8;
  ::IMC_DCCL::PathPoint* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PathPoint >*
      mutable_points();
  const ::IMC_DCCL::PathPoint& points(int index) const;
  ::IMC_DCCL::PathPoint* add_points();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PathPoint >&
      points() const;

  // int32 timeout = 1 [(.dccl.field) = {
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  ::google::protobuf::int32 timeout() const;
  void set_timeout(::google::protobuf::int32 value);

  // float lat = 2 [(.dccl.field) = {
  void clear_lat();
  static const int kLatFieldNumber = 2;
  float lat() const;
  void set_lat(float value);

  // float lon = 3 [(.dccl.field) = {
  void clear_lon();
  static const int kLonFieldNumber = 3;
  float lon() const;
  void set_lon(float value);

  // float z = 4 [(.dccl.field) = {
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // .IMC_DCCL.ZUnits z_units = 5;
  void clear_z_units();
  static const int kZUnitsFieldNumber = 5;
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);

  // float speed = 6 [(.dccl.field) = {
  void clear_speed();
  static const int kSpeedFieldNumber = 6;
  float speed() const;
  void set_speed(float value);

  // .IMC_DCCL.SpeedUnits speed_units = 7;
  void clear_speed_units();
  static const int kSpeedUnitsFieldNumber = 7;
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.FollowPath)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PathPoint > points_;
  ::google::protobuf::int32 timeout_;
  float lat_;
  float lon_;
  float z_;
  int z_units_;
  float speed_;
  int speed_units_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Loiter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Loiter) */ {
 public:
  Loiter();
  virtual ~Loiter();

  Loiter(const Loiter& from);

  inline Loiter& operator=(const Loiter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Loiter(Loiter&& from) noexcept
    : Loiter() {
    *this = ::std::move(from);
  }

  inline Loiter& operator=(Loiter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Loiter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Loiter* internal_default_instance() {
    return reinterpret_cast<const Loiter*>(
               &_Loiter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Loiter* other);
  friend void swap(Loiter& a, Loiter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Loiter* New() const final {
    return CreateMaybeMessage<Loiter>(NULL);
  }

  Loiter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Loiter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Loiter& from);
  void MergeFrom(const Loiter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Loiter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 timeout = 1 [(.dccl.field) = {
  void clear_timeout();
  static const int kTimeoutFieldNumber = 1;
  ::google::protobuf::int32 timeout() const;
  void set_timeout(::google::protobuf::int32 value);

  // float lat = 2 [(.dccl.field) = {
  void clear_lat();
  static const int kLatFieldNumber = 2;
  float lat() const;
  void set_lat(float value);

  // float lon = 3 [(.dccl.field) = {
  void clear_lon();
  static const int kLonFieldNumber = 3;
  float lon() const;
  void set_lon(float value);

  // float z = 4 [(.dccl.field) = {
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // .IMC_DCCL.ZUnits z_units = 5;
  void clear_z_units();
  static const int kZUnitsFieldNumber = 5;
  ::IMC_DCCL::ZUnits z_units() const;
  void set_z_units(::IMC_DCCL::ZUnits value);

  // int32 duration = 6 [(.dccl.field) = {
  void clear_duration();
  static const int kDurationFieldNumber = 6;
  ::google::protobuf::int32 duration() const;
  void set_duration(::google::protobuf::int32 value);

  // float speed = 7 [(.dccl.field) = {
  void clear_speed();
  static const int kSpeedFieldNumber = 7;
  float speed() const;
  void set_speed(float value);

  // .IMC_DCCL.SpeedUnits speed_units = 8;
  void clear_speed_units();
  static const int kSpeedUnitsFieldNumber = 8;
  ::IMC_DCCL::SpeedUnits speed_units() const;
  void set_speed_units(::IMC_DCCL::SpeedUnits value);

  // .IMC_DCCL.LoiterType type = 9;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  ::IMC_DCCL::LoiterType type() const;
  void set_type(::IMC_DCCL::LoiterType value);

  // float radius = 10 [(.dccl.field) = {
  void clear_radius();
  static const int kRadiusFieldNumber = 10;
  float radius() const;
  void set_radius(float value);

  // float length = 11 [(.dccl.field) = {
  void clear_length();
  static const int kLengthFieldNumber = 11;
  float length() const;
  void set_length(float value);

  // float bearing = 12 [(.dccl.field) = {
  void clear_bearing();
  static const int kBearingFieldNumber = 12;
  float bearing() const;
  void set_bearing(float value);

  // .IMC_DCCL.DirectionType direction = 13;
  void clear_direction();
  static const int kDirectionFieldNumber = 13;
  ::IMC_DCCL::DirectionType direction() const;
  void set_direction(::IMC_DCCL::DirectionType value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.Loiter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 timeout_;
  float lat_;
  float lon_;
  float z_;
  int z_units_;
  ::google::protobuf::int32 duration_;
  float speed_;
  int speed_units_;
  int type_;
  float radius_;
  float length_;
  float bearing_;
  int direction_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PathPoint) */ {
 public:
  PathPoint();
  virtual ~PathPoint();

  PathPoint(const PathPoint& from);

  inline PathPoint& operator=(const PathPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathPoint(PathPoint&& from) noexcept
    : PathPoint() {
    *this = ::std::move(from);
  }

  inline PathPoint& operator=(PathPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PathPoint& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathPoint* internal_default_instance() {
    return reinterpret_cast<const PathPoint*>(
               &_PathPoint_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(PathPoint* other);
  friend void swap(PathPoint& a, PathPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathPoint* New() const final {
    return CreateMaybeMessage<PathPoint>(NULL);
  }

  PathPoint* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathPoint>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathPoint& from);
  void MergeFrom(const PathPoint& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float x = 1 [(.dccl.field) = {
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // float y = 2 [(.dccl.field) = {
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // float z = 3 [(.dccl.field) = {
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PathPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Maneuver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Maneuver) */ {
 public:
  Maneuver();
  virtual ~Maneuver();

  Maneuver(const Maneuver& from);

  inline Maneuver& operator=(const Maneuver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Maneuver(Maneuver&& from) noexcept
    : Maneuver() {
    *this = ::std::move(from);
  }

  inline Maneuver& operator=(Maneuver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Maneuver& default_instance();

  enum ManeuverUnionCase {
    kGotoManeuver = 1,
    kFollowpathManeuver = 2,
    kLoiterManeuver = 3,
    MANEUVERUNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Maneuver* internal_default_instance() {
    return reinterpret_cast<const Maneuver*>(
               &_Maneuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Maneuver* other);
  friend void swap(Maneuver& a, Maneuver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Maneuver* New() const final {
    return CreateMaybeMessage<Maneuver>(NULL);
  }

  Maneuver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Maneuver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Maneuver& from);
  void MergeFrom(const Maneuver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Maneuver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .IMC_DCCL.Goto goto_maneuver = 1;
  bool has_goto_maneuver() const;
  void clear_goto_maneuver();
  static const int kGotoManeuverFieldNumber = 1;
  private:
  const ::IMC_DCCL::Goto& _internal_goto_maneuver() const;
  public:
  const ::IMC_DCCL::Goto& goto_maneuver() const;
  ::IMC_DCCL::Goto* release_goto_maneuver();
  ::IMC_DCCL::Goto* mutable_goto_maneuver();
  void set_allocated_goto_maneuver(::IMC_DCCL::Goto* goto_maneuver);

  // .IMC_DCCL.FollowPath followpath_maneuver = 2;
  bool has_followpath_maneuver() const;
  void clear_followpath_maneuver();
  static const int kFollowpathManeuverFieldNumber = 2;
  private:
  const ::IMC_DCCL::FollowPath& _internal_followpath_maneuver() const;
  public:
  const ::IMC_DCCL::FollowPath& followpath_maneuver() const;
  ::IMC_DCCL::FollowPath* release_followpath_maneuver();
  ::IMC_DCCL::FollowPath* mutable_followpath_maneuver();
  void set_allocated_followpath_maneuver(::IMC_DCCL::FollowPath* followpath_maneuver);

  // .IMC_DCCL.Loiter loiter_maneuver = 3;
  bool has_loiter_maneuver() const;
  void clear_loiter_maneuver();
  static const int kLoiterManeuverFieldNumber = 3;
  private:
  const ::IMC_DCCL::Loiter& _internal_loiter_maneuver() const;
  public:
  const ::IMC_DCCL::Loiter& loiter_maneuver() const;
  ::IMC_DCCL::Loiter* release_loiter_maneuver();
  ::IMC_DCCL::Loiter* mutable_loiter_maneuver();
  void set_allocated_loiter_maneuver(::IMC_DCCL::Loiter* loiter_maneuver);

  void clear_ManeuverUnion();
  ManeuverUnionCase ManeuverUnion_case() const;
  // @@protoc_insertion_point(class_scope:IMC_DCCL.Maneuver)
 private:
  void set_has_goto_maneuver();
  void set_has_followpath_maneuver();
  void set_has_loiter_maneuver();

  inline bool has_ManeuverUnion() const;
  inline void clear_has_ManeuverUnion();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ManeuverUnionUnion {
    ManeuverUnionUnion() {}
    ::IMC_DCCL::Goto* goto_maneuver_;
    ::IMC_DCCL::FollowPath* followpath_maneuver_;
    ::IMC_DCCL::Loiter* loiter_maneuver_;
  } ManeuverUnion_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParameterValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.ParameterValue) */ {
 public:
  ParameterValue();
  virtual ~ParameterValue();

  ParameterValue(const ParameterValue& from);

  inline ParameterValue& operator=(const ParameterValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParameterValue(ParameterValue&& from) noexcept
    : ParameterValue() {
    *this = ::std::move(from);
  }

  inline ParameterValue& operator=(ParameterValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ParameterValue& default_instance();

  enum ParameterValueUnionCase {
    kValueNumber = 1,
    kValueString = 2,
    PARAMETERVALUEUNION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParameterValue* internal_default_instance() {
    return reinterpret_cast<const ParameterValue*>(
               &_ParameterValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ParameterValue* other);
  friend void swap(ParameterValue& a, ParameterValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParameterValue* New() const final {
    return CreateMaybeMessage<ParameterValue>(NULL);
  }

  ParameterValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ParameterValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ParameterValue& from);
  void MergeFrom(const ParameterValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // float value_number = 1 [(.dccl.field) = {
  private:
  bool has_value_number() const;
  public:
  void clear_value_number();
  static const int kValueNumberFieldNumber = 1;
  float value_number() const;
  void set_value_number(float value);

  // .IMC_DCCL.ParamValue value_string = 2;
  private:
  bool has_value_string() const;
  public:
  void clear_value_string();
  static const int kValueStringFieldNumber = 2;
  ::IMC_DCCL::ParamValue value_string() const;
  void set_value_string(::IMC_DCCL::ParamValue value);

  void clear_ParameterValueUnion();
  ParameterValueUnionCase ParameterValueUnion_case() const;
  // @@protoc_insertion_point(class_scope:IMC_DCCL.ParameterValue)
 private:
  void set_has_value_number();
  void set_has_value_string();

  inline bool has_ParameterValueUnion() const;
  inline void clear_has_ParameterValueUnion();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ParameterValueUnionUnion {
    ParameterValueUnionUnion() {}
    float value_number_;
    int value_string_;
  } ParameterValueUnion_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntityParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.EntityParameter) */ {
 public:
  EntityParameter();
  virtual ~EntityParameter();

  EntityParameter(const EntityParameter& from);

  inline EntityParameter& operator=(const EntityParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityParameter(EntityParameter&& from) noexcept
    : EntityParameter() {
    *this = ::std::move(from);
  }

  inline EntityParameter& operator=(EntityParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityParameter* internal_default_instance() {
    return reinterpret_cast<const EntityParameter*>(
               &_EntityParameter_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(EntityParameter* other);
  friend void swap(EntityParameter& a, EntityParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityParameter* New() const final {
    return CreateMaybeMessage<EntityParameter>(NULL);
  }

  EntityParameter* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityParameter>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityParameter& from);
  void MergeFrom(const EntityParameter& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .IMC_DCCL.ParameterValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::IMC_DCCL::ParameterValue& _internal_value() const;
  public:
  const ::IMC_DCCL::ParameterValue& value() const;
  ::IMC_DCCL::ParameterValue* release_value();
  ::IMC_DCCL::ParameterValue* mutable_value();
  void set_allocated_value(::IMC_DCCL::ParameterValue* value);

  // .IMC_DCCL.ParameterName name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  ::IMC_DCCL::ParameterName name() const;
  void set_name(::IMC_DCCL::ParameterName value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.EntityParameter)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::IMC_DCCL::ParameterValue* value_;
  int name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EntityParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.EntityParameters) */ {
 public:
  EntityParameters();
  virtual ~EntityParameters();

  EntityParameters(const EntityParameters& from);

  inline EntityParameters& operator=(const EntityParameters& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EntityParameters(EntityParameters&& from) noexcept
    : EntityParameters() {
    *this = ::std::move(from);
  }

  inline EntityParameters& operator=(EntityParameters&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntityParameters& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EntityParameters* internal_default_instance() {
    return reinterpret_cast<const EntityParameters*>(
               &_EntityParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(EntityParameters* other);
  friend void swap(EntityParameters& a, EntityParameters& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EntityParameters* New() const final {
    return CreateMaybeMessage<EntityParameters>(NULL);
  }

  EntityParameters* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EntityParameters>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EntityParameters& from);
  void MergeFrom(const EntityParameters& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EntityParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  ::IMC_DCCL::EntityParameter* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameter >*
      mutable_params();
  const ::IMC_DCCL::EntityParameter& params(int index) const;
  ::IMC_DCCL::EntityParameter* add_params();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameter >&
      params() const;

  // .IMC_DCCL.EntityName name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  ::IMC_DCCL::EntityName name() const;
  void set_name(::IMC_DCCL::EntityName value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.EntityParameters)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameter > params_;
  int name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ManeuverID : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.ManeuverID) */ {
 public:
  ManeuverID();
  virtual ~ManeuverID();

  ManeuverID(const ManeuverID& from);

  inline ManeuverID& operator=(const ManeuverID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ManeuverID(ManeuverID&& from) noexcept
    : ManeuverID() {
    *this = ::std::move(from);
  }

  inline ManeuverID& operator=(ManeuverID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ManeuverID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ManeuverID* internal_default_instance() {
    return reinterpret_cast<const ManeuverID*>(
               &_ManeuverID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ManeuverID* other);
  friend void swap(ManeuverID& a, ManeuverID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ManeuverID* New() const final {
    return CreateMaybeMessage<ManeuverID>(NULL);
  }

  ManeuverID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ManeuverID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ManeuverID& from);
  void MergeFrom(const ManeuverID& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ManeuverID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .IMC_DCCL.ManeuverType maneuver_type = 1;
  void clear_maneuver_type();
  static const int kManeuverTypeFieldNumber = 1;
  ::IMC_DCCL::ManeuverType maneuver_type() const;
  void set_maneuver_type(::IMC_DCCL::ManeuverType value);

  // int32 maneuver_number = 2 [(.dccl.field) = {
  void clear_maneuver_number();
  static const int kManeuverNumberFieldNumber = 2;
  ::google::protobuf::int32 maneuver_number() const;
  void set_maneuver_number(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.ManeuverID)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int maneuver_type_;
  ::google::protobuf::int32 maneuver_number_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanManeuver : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanManeuver) */ {
 public:
  PlanManeuver();
  virtual ~PlanManeuver();

  PlanManeuver(const PlanManeuver& from);

  inline PlanManeuver& operator=(const PlanManeuver& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanManeuver(PlanManeuver&& from) noexcept
    : PlanManeuver() {
    *this = ::std::move(from);
  }

  inline PlanManeuver& operator=(PlanManeuver&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanManeuver& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanManeuver* internal_default_instance() {
    return reinterpret_cast<const PlanManeuver*>(
               &_PlanManeuver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(PlanManeuver* other);
  friend void swap(PlanManeuver& a, PlanManeuver& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanManeuver* New() const final {
    return CreateMaybeMessage<PlanManeuver>(NULL);
  }

  PlanManeuver* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanManeuver>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanManeuver& from);
  void MergeFrom(const PlanManeuver& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanManeuver* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IMC_DCCL.EntityParameters start_actions = 3 [(.dccl.field) = {
  int start_actions_size() const;
  void clear_start_actions();
  static const int kStartActionsFieldNumber = 3;
  ::IMC_DCCL::EntityParameters* mutable_start_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
      mutable_start_actions();
  const ::IMC_DCCL::EntityParameters& start_actions(int index) const;
  ::IMC_DCCL::EntityParameters* add_start_actions();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
      start_actions() const;

  // .IMC_DCCL.ManeuverID maneuver_id = 1;
  bool has_maneuver_id() const;
  void clear_maneuver_id();
  static const int kManeuverIdFieldNumber = 1;
  private:
  const ::IMC_DCCL::ManeuverID& _internal_maneuver_id() const;
  public:
  const ::IMC_DCCL::ManeuverID& maneuver_id() const;
  ::IMC_DCCL::ManeuverID* release_maneuver_id();
  ::IMC_DCCL::ManeuverID* mutable_maneuver_id();
  void set_allocated_maneuver_id(::IMC_DCCL::ManeuverID* maneuver_id);

  // .IMC_DCCL.Maneuver data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  const ::IMC_DCCL::Maneuver& _internal_data() const;
  public:
  const ::IMC_DCCL::Maneuver& data() const;
  ::IMC_DCCL::Maneuver* release_data();
  ::IMC_DCCL::Maneuver* mutable_data();
  void set_allocated_data(::IMC_DCCL::Maneuver* data);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanManeuver)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters > start_actions_;
  ::IMC_DCCL::ManeuverID* maneuver_id_;
  ::IMC_DCCL::Maneuver* data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanVariable : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanVariable) */ {
 public:
  PlanVariable();
  virtual ~PlanVariable();

  PlanVariable(const PlanVariable& from);

  inline PlanVariable& operator=(const PlanVariable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanVariable(PlanVariable&& from) noexcept
    : PlanVariable() {
    *this = ::std::move(from);
  }

  inline PlanVariable& operator=(PlanVariable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanVariable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanVariable* internal_default_instance() {
    return reinterpret_cast<const PlanVariable*>(
               &_PlanVariable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(PlanVariable* other);
  friend void swap(PlanVariable& a, PlanVariable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanVariable* New() const final {
    return CreateMaybeMessage<PlanVariable>(NULL);
  }

  PlanVariable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanVariable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanVariable& from);
  void MergeFrom(const PlanVariable& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanVariable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1 [(.dccl.field) = {
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string value = 2 [(.dccl.field) = {
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .IMC_DCCL.Type type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::IMC_DCCL::Type type() const;
  void set_type(::IMC_DCCL::Type value);

  // .IMC_DCCL.AccessType access = 4;
  void clear_access();
  static const int kAccessFieldNumber = 4;
  ::IMC_DCCL::AccessType access() const;
  void set_access(::IMC_DCCL::AccessType value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanVariable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  int type_;
  int access_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanTransition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanTransition) */ {
 public:
  PlanTransition();
  virtual ~PlanTransition();

  PlanTransition(const PlanTransition& from);

  inline PlanTransition& operator=(const PlanTransition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanTransition(PlanTransition&& from) noexcept
    : PlanTransition() {
    *this = ::std::move(from);
  }

  inline PlanTransition& operator=(PlanTransition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanTransition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanTransition* internal_default_instance() {
    return reinterpret_cast<const PlanTransition*>(
               &_PlanTransition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(PlanTransition* other);
  friend void swap(PlanTransition& a, PlanTransition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanTransition* New() const final {
    return CreateMaybeMessage<PlanTransition>(NULL);
  }

  PlanTransition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanTransition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanTransition& from);
  void MergeFrom(const PlanTransition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanTransition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .IMC_DCCL.ManeuverID source_man = 1;
  bool has_source_man() const;
  void clear_source_man();
  static const int kSourceManFieldNumber = 1;
  private:
  const ::IMC_DCCL::ManeuverID& _internal_source_man() const;
  public:
  const ::IMC_DCCL::ManeuverID& source_man() const;
  ::IMC_DCCL::ManeuverID* release_source_man();
  ::IMC_DCCL::ManeuverID* mutable_source_man();
  void set_allocated_source_man(::IMC_DCCL::ManeuverID* source_man);

  // .IMC_DCCL.ManeuverID dest_man = 2;
  bool has_dest_man() const;
  void clear_dest_man();
  static const int kDestManFieldNumber = 2;
  private:
  const ::IMC_DCCL::ManeuverID& _internal_dest_man() const;
  public:
  const ::IMC_DCCL::ManeuverID& dest_man() const;
  ::IMC_DCCL::ManeuverID* release_dest_man();
  ::IMC_DCCL::ManeuverID* mutable_dest_man();
  void set_allocated_dest_man(::IMC_DCCL::ManeuverID* dest_man);

  // .IMC_DCCL.TransitionCondition conditions = 3;
  void clear_conditions();
  static const int kConditionsFieldNumber = 3;
  ::IMC_DCCL::TransitionCondition conditions() const;
  void set_conditions(::IMC_DCCL::TransitionCondition value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanTransition)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::IMC_DCCL::ManeuverID* source_man_;
  ::IMC_DCCL::ManeuverID* dest_man_;
  int conditions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Header : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.Header) */ {
 public:
  Header();
  virtual ~Header();

  Header(const Header& from);

  inline Header& operator=(const Header& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Header(Header&& from) noexcept
    : Header() {
    *this = ::std::move(from);
  }

  inline Header& operator=(Header&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Header& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Header* internal_default_instance() {
    return reinterpret_cast<const Header*>(
               &_Header_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Header* other);
  friend void swap(Header& a, Header& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Header* New() const final {
    return CreateMaybeMessage<Header>(NULL);
  }

  Header* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Header>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Header& from);
  void MergeFrom(const Header& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Header* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 src = 1 [(.dccl.field) = {
  void clear_src();
  static const int kSrcFieldNumber = 1;
  ::google::protobuf::int32 src() const;
  void set_src(::google::protobuf::int32 value);

  // int32 src_ent = 2 [(.dccl.field) = {
  void clear_src_ent();
  static const int kSrcEntFieldNumber = 2;
  ::google::protobuf::int32 src_ent() const;
  void set_src_ent(::google::protobuf::int32 value);

  // int32 dst = 3 [(.dccl.field) = {
  void clear_dst();
  static const int kDstFieldNumber = 3;
  ::google::protobuf::int32 dst() const;
  void set_dst(::google::protobuf::int32 value);

  // int32 dst_ent = 4 [(.dccl.field) = {
  void clear_dst_ent();
  static const int kDstEntFieldNumber = 4;
  ::google::protobuf::int32 dst_ent() const;
  void set_dst_ent(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.Header)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 src_ent_;
  ::google::protobuf::int32 dst_;
  ::google::protobuf::int32 dst_ent_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PlanSpecification : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:IMC_DCCL.PlanSpecification) */ {
 public:
  PlanSpecification();
  virtual ~PlanSpecification();

  PlanSpecification(const PlanSpecification& from);

  inline PlanSpecification& operator=(const PlanSpecification& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PlanSpecification(PlanSpecification&& from) noexcept
    : PlanSpecification() {
    *this = ::std::move(from);
  }

  inline PlanSpecification& operator=(PlanSpecification&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlanSpecification& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PlanSpecification* internal_default_instance() {
    return reinterpret_cast<const PlanSpecification*>(
               &_PlanSpecification_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PlanSpecification* other);
  friend void swap(PlanSpecification& a, PlanSpecification& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PlanSpecification* New() const final {
    return CreateMaybeMessage<PlanSpecification>(NULL);
  }

  PlanSpecification* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PlanSpecification>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PlanSpecification& from);
  void MergeFrom(const PlanSpecification& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlanSpecification* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
  int maneuvers_size() const;
  void clear_maneuvers();
  static const int kManeuversFieldNumber = 5;
  ::IMC_DCCL::PlanManeuver* mutable_maneuvers(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >*
      mutable_maneuvers();
  const ::IMC_DCCL::PlanManeuver& maneuvers(int index) const;
  ::IMC_DCCL::PlanManeuver* add_maneuvers();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >&
      maneuvers() const;

  // repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
  int transitions_size() const;
  void clear_transitions();
  static const int kTransitionsFieldNumber = 6;
  ::IMC_DCCL::PlanTransition* mutable_transitions(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanTransition >*
      mutable_transitions();
  const ::IMC_DCCL::PlanTransition& transitions(int index) const;
  ::IMC_DCCL::PlanTransition* add_transitions();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanTransition >&
      transitions() const;

  // repeated .IMC_DCCL.EntityParameters start_actions = 7 [(.dccl.field) = {
  int start_actions_size() const;
  void clear_start_actions();
  static const int kStartActionsFieldNumber = 7;
  ::IMC_DCCL::EntityParameters* mutable_start_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
      mutable_start_actions();
  const ::IMC_DCCL::EntityParameters& start_actions(int index) const;
  ::IMC_DCCL::EntityParameters* add_start_actions();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
      start_actions() const;

  // repeated .IMC_DCCL.PlanVariable variables = 8 [(.dccl.field) = {
  int variables_size() const;
  void clear_variables();
  static const int kVariablesFieldNumber = 8;
  ::IMC_DCCL::PlanVariable* mutable_variables(int index);
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanVariable >*
      mutable_variables();
  const ::IMC_DCCL::PlanVariable& variables(int index) const;
  ::IMC_DCCL::PlanVariable* add_variables();
  const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanVariable >&
      variables() const;

  // string plan_id = 1 [(.dccl.field) = {
  void clear_plan_id();
  static const int kPlanIdFieldNumber = 1;
  const ::std::string& plan_id() const;
  void set_plan_id(const ::std::string& value);
  #if LANG_CXX11
  void set_plan_id(::std::string&& value);
  #endif
  void set_plan_id(const char* value);
  void set_plan_id(const char* value, size_t size);
  ::std::string* mutable_plan_id();
  ::std::string* release_plan_id();
  void set_allocated_plan_id(::std::string* plan_id);

  // string description = 2 [(.dccl.field) = {
  void clear_description();
  static const int kDescriptionFieldNumber = 2;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string vnamespace = 3 [(.dccl.field) = {
  void clear_vnamespace();
  static const int kVnamespaceFieldNumber = 3;
  const ::std::string& vnamespace() const;
  void set_vnamespace(const ::std::string& value);
  #if LANG_CXX11
  void set_vnamespace(::std::string&& value);
  #endif
  void set_vnamespace(const char* value);
  void set_vnamespace(const char* value, size_t size);
  ::std::string* mutable_vnamespace();
  ::std::string* release_vnamespace();
  void set_allocated_vnamespace(::std::string* vnamespace);

  // .IMC_DCCL.ManeuverID start_man_id = 4;
  bool has_start_man_id() const;
  void clear_start_man_id();
  static const int kStartManIdFieldNumber = 4;
  private:
  const ::IMC_DCCL::ManeuverID& _internal_start_man_id() const;
  public:
  const ::IMC_DCCL::ManeuverID& start_man_id() const;
  ::IMC_DCCL::ManeuverID* release_start_man_id();
  ::IMC_DCCL::ManeuverID* mutable_start_man_id();
  void set_allocated_start_man_id(::IMC_DCCL::ManeuverID* start_man_id);

  // .IMC_DCCL.Header head = 9;
  bool has_head() const;
  void clear_head();
  static const int kHeadFieldNumber = 9;
  private:
  const ::IMC_DCCL::Header& _internal_head() const;
  public:
  const ::IMC_DCCL::Header& head() const;
  ::IMC_DCCL::Header* release_head();
  ::IMC_DCCL::Header* mutable_head();
  void set_allocated_head(::IMC_DCCL::Header* head);

  // @@protoc_insertion_point(class_scope:IMC_DCCL.PlanSpecification)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanManeuver > maneuvers_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanTransition > transitions_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters > start_actions_;
  ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanVariable > variables_;
  ::google::protobuf::internal::ArenaStringPtr plan_id_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr vnamespace_;
  ::IMC_DCCL::ManeuverID* start_man_id_;
  ::IMC_DCCL::Header* head_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_IMC_5fDCCL_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// EstimatedState

// float lat = 1 [(.dccl.field) = {
inline void EstimatedState::clear_lat() {
  lat_ = 0;
}
inline float EstimatedState::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.lat)
  return lat_;
}
inline void EstimatedState::set_lat(float value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.lat)
}

// float lon = 2 [(.dccl.field) = {
inline void EstimatedState::clear_lon() {
  lon_ = 0;
}
inline float EstimatedState::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.lon)
  return lon_;
}
inline void EstimatedState::set_lon(float value) {
  
  lon_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.lon)
}

// float height = 3 [(.dccl.field) = {
inline void EstimatedState::clear_height() {
  height_ = 0;
}
inline float EstimatedState::height() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.height)
  return height_;
}
inline void EstimatedState::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.height)
}

// float x = 4 [(.dccl.field) = {
inline void EstimatedState::clear_x() {
  x_ = 0;
}
inline float EstimatedState::x() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.x)
  return x_;
}
inline void EstimatedState::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.x)
}

// float y = 5 [(.dccl.field) = {
inline void EstimatedState::clear_y() {
  y_ = 0;
}
inline float EstimatedState::y() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.y)
  return y_;
}
inline void EstimatedState::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.y)
}

// float z = 6 [(.dccl.field) = {
inline void EstimatedState::clear_z() {
  z_ = 0;
}
inline float EstimatedState::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.z)
  return z_;
}
inline void EstimatedState::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.z)
}

// float phi = 7 [(.dccl.field) = {
inline void EstimatedState::clear_phi() {
  phi_ = 0;
}
inline float EstimatedState::phi() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.phi)
  return phi_;
}
inline void EstimatedState::set_phi(float value) {
  
  phi_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.phi)
}

// float theta = 8 [(.dccl.field) = {
inline void EstimatedState::clear_theta() {
  theta_ = 0;
}
inline float EstimatedState::theta() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.theta)
  return theta_;
}
inline void EstimatedState::set_theta(float value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.theta)
}

// float psi = 9 [(.dccl.field) = {
inline void EstimatedState::clear_psi() {
  psi_ = 0;
}
inline float EstimatedState::psi() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.psi)
  return psi_;
}
inline void EstimatedState::set_psi(float value) {
  
  psi_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.psi)
}

// float u = 10 [(.dccl.field) = {
inline void EstimatedState::clear_u() {
  u_ = 0;
}
inline float EstimatedState::u() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.u)
  return u_;
}
inline void EstimatedState::set_u(float value) {
  
  u_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.u)
}

// float v = 11 [(.dccl.field) = {
inline void EstimatedState::clear_v() {
  v_ = 0;
}
inline float EstimatedState::v() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.v)
  return v_;
}
inline void EstimatedState::set_v(float value) {
  
  v_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.v)
}

// float w = 12 [(.dccl.field) = {
inline void EstimatedState::clear_w() {
  w_ = 0;
}
inline float EstimatedState::w() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.w)
  return w_;
}
inline void EstimatedState::set_w(float value) {
  
  w_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.w)
}

// float vx = 13 [(.dccl.field) = {
inline void EstimatedState::clear_vx() {
  vx_ = 0;
}
inline float EstimatedState::vx() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.vx)
  return vx_;
}
inline void EstimatedState::set_vx(float value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.vx)
}

// float vy = 14 [(.dccl.field) = {
inline void EstimatedState::clear_vy() {
  vy_ = 0;
}
inline float EstimatedState::vy() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.vy)
  return vy_;
}
inline void EstimatedState::set_vy(float value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.vy)
}

// float vz = 15 [(.dccl.field) = {
inline void EstimatedState::clear_vz() {
  vz_ = 0;
}
inline float EstimatedState::vz() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.vz)
  return vz_;
}
inline void EstimatedState::set_vz(float value) {
  
  vz_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.vz)
}

// float p = 16 [(.dccl.field) = {
inline void EstimatedState::clear_p() {
  p_ = 0;
}
inline float EstimatedState::p() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.p)
  return p_;
}
inline void EstimatedState::set_p(float value) {
  
  p_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.p)
}

// float q = 17 [(.dccl.field) = {
inline void EstimatedState::clear_q() {
  q_ = 0;
}
inline float EstimatedState::q() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.q)
  return q_;
}
inline void EstimatedState::set_q(float value) {
  
  q_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.q)
}

// float r = 18 [(.dccl.field) = {
inline void EstimatedState::clear_r() {
  r_ = 0;
}
inline float EstimatedState::r() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.r)
  return r_;
}
inline void EstimatedState::set_r(float value) {
  
  r_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.r)
}

// float depth = 19 [(.dccl.field) = {
inline void EstimatedState::clear_depth() {
  depth_ = 0;
}
inline float EstimatedState::depth() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.depth)
  return depth_;
}
inline void EstimatedState::set_depth(float value) {
  
  depth_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.depth)
}

// float altitude = 20 [(.dccl.field) = {
inline void EstimatedState::clear_altitude() {
  altitude_ = 0;
}
inline float EstimatedState::altitude() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EstimatedState.altitude)
  return altitude_;
}
inline void EstimatedState::set_altitude(float value) {
  
  altitude_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EstimatedState.altitude)
}

// -------------------------------------------------------------------

// Goto

// int32 timeout = 1 [(.dccl.field) = {
inline void Goto::clear_timeout() {
  timeout_ = 0;
}
inline ::google::protobuf::int32 Goto::timeout() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.timeout)
  return timeout_;
}
inline void Goto::set_timeout(::google::protobuf::int32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.timeout)
}

// float lat = 2 [(.dccl.field) = {
inline void Goto::clear_lat() {
  lat_ = 0;
}
inline float Goto::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.lat)
  return lat_;
}
inline void Goto::set_lat(float value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.lat)
}

// float lon = 3 [(.dccl.field) = {
inline void Goto::clear_lon() {
  lon_ = 0;
}
inline float Goto::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.lon)
  return lon_;
}
inline void Goto::set_lon(float value) {
  
  lon_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.lon)
}

// float z = 4 [(.dccl.field) = {
inline void Goto::clear_z() {
  z_ = 0;
}
inline float Goto::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.z)
  return z_;
}
inline void Goto::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.z)
}

// .IMC_DCCL.ZUnits z_units = 5;
inline void Goto::clear_z_units() {
  z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits Goto::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.z_units)
  return static_cast< ::IMC_DCCL::ZUnits >(z_units_);
}
inline void Goto::set_z_units(::IMC_DCCL::ZUnits value) {
  
  z_units_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.z_units)
}

// float speed = 6 [(.dccl.field) = {
inline void Goto::clear_speed() {
  speed_ = 0;
}
inline float Goto::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.speed)
  return speed_;
}
inline void Goto::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 7;
inline void Goto::clear_speed_units() {
  speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits Goto::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.speed_units)
  return static_cast< ::IMC_DCCL::SpeedUnits >(speed_units_);
}
inline void Goto::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  speed_units_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.speed_units)
}

// float roll = 8 [(.dccl.field) = {
inline void Goto::clear_roll() {
  roll_ = 0;
}
inline float Goto::roll() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.roll)
  return roll_;
}
inline void Goto::set_roll(float value) {
  
  roll_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.roll)
}

// float pitch = 9 [(.dccl.field) = {
inline void Goto::clear_pitch() {
  pitch_ = 0;
}
inline float Goto::pitch() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.pitch)
  return pitch_;
}
inline void Goto::set_pitch(float value) {
  
  pitch_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.pitch)
}

// float yaw = 10 [(.dccl.field) = {
inline void Goto::clear_yaw() {
  yaw_ = 0;
}
inline float Goto::yaw() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Goto.yaw)
  return yaw_;
}
inline void Goto::set_yaw(float value) {
  
  yaw_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Goto.yaw)
}

// -------------------------------------------------------------------

// FollowPath

// int32 timeout = 1 [(.dccl.field) = {
inline void FollowPath::clear_timeout() {
  timeout_ = 0;
}
inline ::google::protobuf::int32 FollowPath::timeout() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.timeout)
  return timeout_;
}
inline void FollowPath::set_timeout(::google::protobuf::int32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.timeout)
}

// float lat = 2 [(.dccl.field) = {
inline void FollowPath::clear_lat() {
  lat_ = 0;
}
inline float FollowPath::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.lat)
  return lat_;
}
inline void FollowPath::set_lat(float value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.lat)
}

// float lon = 3 [(.dccl.field) = {
inline void FollowPath::clear_lon() {
  lon_ = 0;
}
inline float FollowPath::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.lon)
  return lon_;
}
inline void FollowPath::set_lon(float value) {
  
  lon_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.lon)
}

// float z = 4 [(.dccl.field) = {
inline void FollowPath::clear_z() {
  z_ = 0;
}
inline float FollowPath::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.z)
  return z_;
}
inline void FollowPath::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.z)
}

// .IMC_DCCL.ZUnits z_units = 5;
inline void FollowPath::clear_z_units() {
  z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits FollowPath::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.z_units)
  return static_cast< ::IMC_DCCL::ZUnits >(z_units_);
}
inline void FollowPath::set_z_units(::IMC_DCCL::ZUnits value) {
  
  z_units_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.z_units)
}

// float speed = 6 [(.dccl.field) = {
inline void FollowPath::clear_speed() {
  speed_ = 0;
}
inline float FollowPath::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.speed)
  return speed_;
}
inline void FollowPath::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 7;
inline void FollowPath::clear_speed_units() {
  speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits FollowPath::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.speed_units)
  return static_cast< ::IMC_DCCL::SpeedUnits >(speed_units_);
}
inline void FollowPath::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  speed_units_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.FollowPath.speed_units)
}

// repeated .IMC_DCCL.PathPoint points = 8 [(.dccl.field) = {
inline int FollowPath::points_size() const {
  return points_.size();
}
inline void FollowPath::clear_points() {
  points_.Clear();
}
inline ::IMC_DCCL::PathPoint* FollowPath::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.FollowPath.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PathPoint >*
FollowPath::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.FollowPath.points)
  return &points_;
}
inline const ::IMC_DCCL::PathPoint& FollowPath::points(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.FollowPath.points)
  return points_.Get(index);
}
inline ::IMC_DCCL::PathPoint* FollowPath::add_points() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.FollowPath.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PathPoint >&
FollowPath::points() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.FollowPath.points)
  return points_;
}

// -------------------------------------------------------------------

// Loiter

// int32 timeout = 1 [(.dccl.field) = {
inline void Loiter::clear_timeout() {
  timeout_ = 0;
}
inline ::google::protobuf::int32 Loiter::timeout() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.timeout)
  return timeout_;
}
inline void Loiter::set_timeout(::google::protobuf::int32 value) {
  
  timeout_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.timeout)
}

// float lat = 2 [(.dccl.field) = {
inline void Loiter::clear_lat() {
  lat_ = 0;
}
inline float Loiter::lat() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.lat)
  return lat_;
}
inline void Loiter::set_lat(float value) {
  
  lat_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.lat)
}

// float lon = 3 [(.dccl.field) = {
inline void Loiter::clear_lon() {
  lon_ = 0;
}
inline float Loiter::lon() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.lon)
  return lon_;
}
inline void Loiter::set_lon(float value) {
  
  lon_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.lon)
}

// float z = 4 [(.dccl.field) = {
inline void Loiter::clear_z() {
  z_ = 0;
}
inline float Loiter::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.z)
  return z_;
}
inline void Loiter::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.z)
}

// .IMC_DCCL.ZUnits z_units = 5;
inline void Loiter::clear_z_units() {
  z_units_ = 0;
}
inline ::IMC_DCCL::ZUnits Loiter::z_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.z_units)
  return static_cast< ::IMC_DCCL::ZUnits >(z_units_);
}
inline void Loiter::set_z_units(::IMC_DCCL::ZUnits value) {
  
  z_units_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.z_units)
}

// int32 duration = 6 [(.dccl.field) = {
inline void Loiter::clear_duration() {
  duration_ = 0;
}
inline ::google::protobuf::int32 Loiter::duration() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.duration)
  return duration_;
}
inline void Loiter::set_duration(::google::protobuf::int32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.duration)
}

// float speed = 7 [(.dccl.field) = {
inline void Loiter::clear_speed() {
  speed_ = 0;
}
inline float Loiter::speed() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.speed)
  return speed_;
}
inline void Loiter::set_speed(float value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.speed)
}

// .IMC_DCCL.SpeedUnits speed_units = 8;
inline void Loiter::clear_speed_units() {
  speed_units_ = 0;
}
inline ::IMC_DCCL::SpeedUnits Loiter::speed_units() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.speed_units)
  return static_cast< ::IMC_DCCL::SpeedUnits >(speed_units_);
}
inline void Loiter::set_speed_units(::IMC_DCCL::SpeedUnits value) {
  
  speed_units_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.speed_units)
}

// .IMC_DCCL.LoiterType type = 9;
inline void Loiter::clear_type() {
  type_ = 0;
}
inline ::IMC_DCCL::LoiterType Loiter::type() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.type)
  return static_cast< ::IMC_DCCL::LoiterType >(type_);
}
inline void Loiter::set_type(::IMC_DCCL::LoiterType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.type)
}

// float radius = 10 [(.dccl.field) = {
inline void Loiter::clear_radius() {
  radius_ = 0;
}
inline float Loiter::radius() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.radius)
  return radius_;
}
inline void Loiter::set_radius(float value) {
  
  radius_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.radius)
}

// float length = 11 [(.dccl.field) = {
inline void Loiter::clear_length() {
  length_ = 0;
}
inline float Loiter::length() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.length)
  return length_;
}
inline void Loiter::set_length(float value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.length)
}

// float bearing = 12 [(.dccl.field) = {
inline void Loiter::clear_bearing() {
  bearing_ = 0;
}
inline float Loiter::bearing() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.bearing)
  return bearing_;
}
inline void Loiter::set_bearing(float value) {
  
  bearing_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.bearing)
}

// .IMC_DCCL.DirectionType direction = 13;
inline void Loiter::clear_direction() {
  direction_ = 0;
}
inline ::IMC_DCCL::DirectionType Loiter::direction() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Loiter.direction)
  return static_cast< ::IMC_DCCL::DirectionType >(direction_);
}
inline void Loiter::set_direction(::IMC_DCCL::DirectionType value) {
  
  direction_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Loiter.direction)
}

// -------------------------------------------------------------------

// PathPoint

// float x = 1 [(.dccl.field) = {
inline void PathPoint::clear_x() {
  x_ = 0;
}
inline float PathPoint::x() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PathPoint.x)
  return x_;
}
inline void PathPoint::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.PathPoint.x)
}

// float y = 2 [(.dccl.field) = {
inline void PathPoint::clear_y() {
  y_ = 0;
}
inline float PathPoint::y() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PathPoint.y)
  return y_;
}
inline void PathPoint::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.PathPoint.y)
}

// float z = 3 [(.dccl.field) = {
inline void PathPoint::clear_z() {
  z_ = 0;
}
inline float PathPoint::z() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PathPoint.z)
  return z_;
}
inline void PathPoint::set_z(float value) {
  
  z_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.PathPoint.z)
}

// -------------------------------------------------------------------

// Maneuver

// .IMC_DCCL.Goto goto_maneuver = 1;
inline bool Maneuver::has_goto_maneuver() const {
  return ManeuverUnion_case() == kGotoManeuver;
}
inline void Maneuver::set_has_goto_maneuver() {
  _oneof_case_[0] = kGotoManeuver;
}
inline void Maneuver::clear_goto_maneuver() {
  if (has_goto_maneuver()) {
    delete ManeuverUnion_.goto_maneuver_;
    clear_has_ManeuverUnion();
  }
}
inline const ::IMC_DCCL::Goto& Maneuver::_internal_goto_maneuver() const {
  return *ManeuverUnion_.goto_maneuver_;
}
inline ::IMC_DCCL::Goto* Maneuver::release_goto_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.goto_maneuver)
  if (has_goto_maneuver()) {
    clear_has_ManeuverUnion();
      ::IMC_DCCL::Goto* temp = ManeuverUnion_.goto_maneuver_;
    ManeuverUnion_.goto_maneuver_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::IMC_DCCL::Goto& Maneuver::goto_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.goto_maneuver)
  return has_goto_maneuver()
      ? *ManeuverUnion_.goto_maneuver_
      : *reinterpret_cast< ::IMC_DCCL::Goto*>(&::IMC_DCCL::_Goto_default_instance_);
}
inline ::IMC_DCCL::Goto* Maneuver::mutable_goto_maneuver() {
  if (!has_goto_maneuver()) {
    clear_ManeuverUnion();
    set_has_goto_maneuver();
    ManeuverUnion_.goto_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::Goto >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.goto_maneuver)
  return ManeuverUnion_.goto_maneuver_;
}

// .IMC_DCCL.FollowPath followpath_maneuver = 2;
inline bool Maneuver::has_followpath_maneuver() const {
  return ManeuverUnion_case() == kFollowpathManeuver;
}
inline void Maneuver::set_has_followpath_maneuver() {
  _oneof_case_[0] = kFollowpathManeuver;
}
inline void Maneuver::clear_followpath_maneuver() {
  if (has_followpath_maneuver()) {
    delete ManeuverUnion_.followpath_maneuver_;
    clear_has_ManeuverUnion();
  }
}
inline const ::IMC_DCCL::FollowPath& Maneuver::_internal_followpath_maneuver() const {
  return *ManeuverUnion_.followpath_maneuver_;
}
inline ::IMC_DCCL::FollowPath* Maneuver::release_followpath_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.followpath_maneuver)
  if (has_followpath_maneuver()) {
    clear_has_ManeuverUnion();
      ::IMC_DCCL::FollowPath* temp = ManeuverUnion_.followpath_maneuver_;
    ManeuverUnion_.followpath_maneuver_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::IMC_DCCL::FollowPath& Maneuver::followpath_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.followpath_maneuver)
  return has_followpath_maneuver()
      ? *ManeuverUnion_.followpath_maneuver_
      : *reinterpret_cast< ::IMC_DCCL::FollowPath*>(&::IMC_DCCL::_FollowPath_default_instance_);
}
inline ::IMC_DCCL::FollowPath* Maneuver::mutable_followpath_maneuver() {
  if (!has_followpath_maneuver()) {
    clear_ManeuverUnion();
    set_has_followpath_maneuver();
    ManeuverUnion_.followpath_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::FollowPath >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.followpath_maneuver)
  return ManeuverUnion_.followpath_maneuver_;
}

// .IMC_DCCL.Loiter loiter_maneuver = 3;
inline bool Maneuver::has_loiter_maneuver() const {
  return ManeuverUnion_case() == kLoiterManeuver;
}
inline void Maneuver::set_has_loiter_maneuver() {
  _oneof_case_[0] = kLoiterManeuver;
}
inline void Maneuver::clear_loiter_maneuver() {
  if (has_loiter_maneuver()) {
    delete ManeuverUnion_.loiter_maneuver_;
    clear_has_ManeuverUnion();
  }
}
inline const ::IMC_DCCL::Loiter& Maneuver::_internal_loiter_maneuver() const {
  return *ManeuverUnion_.loiter_maneuver_;
}
inline ::IMC_DCCL::Loiter* Maneuver::release_loiter_maneuver() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.Maneuver.loiter_maneuver)
  if (has_loiter_maneuver()) {
    clear_has_ManeuverUnion();
      ::IMC_DCCL::Loiter* temp = ManeuverUnion_.loiter_maneuver_;
    ManeuverUnion_.loiter_maneuver_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::IMC_DCCL::Loiter& Maneuver::loiter_maneuver() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Maneuver.loiter_maneuver)
  return has_loiter_maneuver()
      ? *ManeuverUnion_.loiter_maneuver_
      : *reinterpret_cast< ::IMC_DCCL::Loiter*>(&::IMC_DCCL::_Loiter_default_instance_);
}
inline ::IMC_DCCL::Loiter* Maneuver::mutable_loiter_maneuver() {
  if (!has_loiter_maneuver()) {
    clear_ManeuverUnion();
    set_has_loiter_maneuver();
    ManeuverUnion_.loiter_maneuver_ = CreateMaybeMessage< ::IMC_DCCL::Loiter >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.Maneuver.loiter_maneuver)
  return ManeuverUnion_.loiter_maneuver_;
}

inline bool Maneuver::has_ManeuverUnion() const {
  return ManeuverUnion_case() != MANEUVERUNION_NOT_SET;
}
inline void Maneuver::clear_has_ManeuverUnion() {
  _oneof_case_[0] = MANEUVERUNION_NOT_SET;
}
inline Maneuver::ManeuverUnionCase Maneuver::ManeuverUnion_case() const {
  return Maneuver::ManeuverUnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ParameterValue

// float value_number = 1 [(.dccl.field) = {
inline bool ParameterValue::has_value_number() const {
  return ParameterValueUnion_case() == kValueNumber;
}
inline void ParameterValue::set_has_value_number() {
  _oneof_case_[0] = kValueNumber;
}
inline void ParameterValue::clear_value_number() {
  if (has_value_number()) {
    ParameterValueUnion_.value_number_ = 0;
    clear_has_ParameterValueUnion();
  }
}
inline float ParameterValue::value_number() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ParameterValue.value_number)
  if (has_value_number()) {
    return ParameterValueUnion_.value_number_;
  }
  return 0;
}
inline void ParameterValue::set_value_number(float value) {
  if (!has_value_number()) {
    clear_ParameterValueUnion();
    set_has_value_number();
  }
  ParameterValueUnion_.value_number_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.ParameterValue.value_number)
}

// .IMC_DCCL.ParamValue value_string = 2;
inline bool ParameterValue::has_value_string() const {
  return ParameterValueUnion_case() == kValueString;
}
inline void ParameterValue::set_has_value_string() {
  _oneof_case_[0] = kValueString;
}
inline void ParameterValue::clear_value_string() {
  if (has_value_string()) {
    ParameterValueUnion_.value_string_ = 0;
    clear_has_ParameterValueUnion();
  }
}
inline ::IMC_DCCL::ParamValue ParameterValue::value_string() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ParameterValue.value_string)
  if (has_value_string()) {
    return static_cast< ::IMC_DCCL::ParamValue >(ParameterValueUnion_.value_string_);
  }
  return static_cast< ::IMC_DCCL::ParamValue >(0);
}
inline void ParameterValue::set_value_string(::IMC_DCCL::ParamValue value) {
  if (!has_value_string()) {
    clear_ParameterValueUnion();
    set_has_value_string();
  }
  ParameterValueUnion_.value_string_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.ParameterValue.value_string)
}

inline bool ParameterValue::has_ParameterValueUnion() const {
  return ParameterValueUnion_case() != PARAMETERVALUEUNION_NOT_SET;
}
inline void ParameterValue::clear_has_ParameterValueUnion() {
  _oneof_case_[0] = PARAMETERVALUEUNION_NOT_SET;
}
inline ParameterValue::ParameterValueUnionCase ParameterValue::ParameterValueUnion_case() const {
  return ParameterValue::ParameterValueUnionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// EntityParameter

// .IMC_DCCL.ParameterName name = 1;
inline void EntityParameter::clear_name() {
  name_ = 0;
}
inline ::IMC_DCCL::ParameterName EntityParameter::name() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameter.name)
  return static_cast< ::IMC_DCCL::ParameterName >(name_);
}
inline void EntityParameter::set_name(::IMC_DCCL::ParameterName value) {
  
  name_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EntityParameter.name)
}

// .IMC_DCCL.ParameterValue value = 2;
inline bool EntityParameter::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline void EntityParameter::clear_value() {
  if (GetArenaNoVirtual() == NULL && value_ != NULL) {
    delete value_;
  }
  value_ = NULL;
}
inline const ::IMC_DCCL::ParameterValue& EntityParameter::_internal_value() const {
  return *value_;
}
inline const ::IMC_DCCL::ParameterValue& EntityParameter::value() const {
  const ::IMC_DCCL::ParameterValue* p = value_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameter.value)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::ParameterValue*>(
      &::IMC_DCCL::_ParameterValue_default_instance_);
}
inline ::IMC_DCCL::ParameterValue* EntityParameter::release_value() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.EntityParameter.value)
  
  ::IMC_DCCL::ParameterValue* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::IMC_DCCL::ParameterValue* EntityParameter::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ParameterValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.EntityParameter.value)
  return value_;
}
inline void EntityParameter::set_allocated_value(::IMC_DCCL::ParameterValue* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.EntityParameter.value)
}

// -------------------------------------------------------------------

// EntityParameters

// .IMC_DCCL.EntityName name = 1;
inline void EntityParameters::clear_name() {
  name_ = 0;
}
inline ::IMC_DCCL::EntityName EntityParameters::name() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameters.name)
  return static_cast< ::IMC_DCCL::EntityName >(name_);
}
inline void EntityParameters::set_name(::IMC_DCCL::EntityName value) {
  
  name_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.EntityParameters.name)
}

// repeated .IMC_DCCL.EntityParameter params = 2 [(.dccl.field) = {
inline int EntityParameters::params_size() const {
  return params_.size();
}
inline void EntityParameters::clear_params() {
  params_.Clear();
}
inline ::IMC_DCCL::EntityParameter* EntityParameters::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.EntityParameters.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameter >*
EntityParameters::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.EntityParameters.params)
  return &params_;
}
inline const ::IMC_DCCL::EntityParameter& EntityParameters::params(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.EntityParameters.params)
  return params_.Get(index);
}
inline ::IMC_DCCL::EntityParameter* EntityParameters::add_params() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.EntityParameters.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameter >&
EntityParameters::params() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.EntityParameters.params)
  return params_;
}

// -------------------------------------------------------------------

// ManeuverID

// .IMC_DCCL.ManeuverType maneuver_type = 1;
inline void ManeuverID::clear_maneuver_type() {
  maneuver_type_ = 0;
}
inline ::IMC_DCCL::ManeuverType ManeuverID::maneuver_type() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ManeuverID.maneuver_type)
  return static_cast< ::IMC_DCCL::ManeuverType >(maneuver_type_);
}
inline void ManeuverID::set_maneuver_type(::IMC_DCCL::ManeuverType value) {
  
  maneuver_type_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.ManeuverID.maneuver_type)
}

// int32 maneuver_number = 2 [(.dccl.field) = {
inline void ManeuverID::clear_maneuver_number() {
  maneuver_number_ = 0;
}
inline ::google::protobuf::int32 ManeuverID::maneuver_number() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.ManeuverID.maneuver_number)
  return maneuver_number_;
}
inline void ManeuverID::set_maneuver_number(::google::protobuf::int32 value) {
  
  maneuver_number_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.ManeuverID.maneuver_number)
}

// -------------------------------------------------------------------

// PlanManeuver

// .IMC_DCCL.ManeuverID maneuver_id = 1;
inline bool PlanManeuver::has_maneuver_id() const {
  return this != internal_default_instance() && maneuver_id_ != NULL;
}
inline void PlanManeuver::clear_maneuver_id() {
  if (GetArenaNoVirtual() == NULL && maneuver_id_ != NULL) {
    delete maneuver_id_;
  }
  maneuver_id_ = NULL;
}
inline const ::IMC_DCCL::ManeuverID& PlanManeuver::_internal_maneuver_id() const {
  return *maneuver_id_;
}
inline const ::IMC_DCCL::ManeuverID& PlanManeuver::maneuver_id() const {
  const ::IMC_DCCL::ManeuverID* p = maneuver_id_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanManeuver.maneuver_id)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::ManeuverID*>(
      &::IMC_DCCL::_ManeuverID_default_instance_);
}
inline ::IMC_DCCL::ManeuverID* PlanManeuver::release_maneuver_id() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanManeuver.maneuver_id)
  
  ::IMC_DCCL::ManeuverID* temp = maneuver_id_;
  maneuver_id_ = NULL;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanManeuver::mutable_maneuver_id() {
  
  if (maneuver_id_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaNoVirtual());
    maneuver_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanManeuver.maneuver_id)
  return maneuver_id_;
}
inline void PlanManeuver::set_allocated_maneuver_id(::IMC_DCCL::ManeuverID* maneuver_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete maneuver_id_;
  }
  if (maneuver_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      maneuver_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, maneuver_id, submessage_arena);
    }
    
  } else {
    
  }
  maneuver_id_ = maneuver_id;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanManeuver.maneuver_id)
}

// .IMC_DCCL.Maneuver data = 2;
inline bool PlanManeuver::has_data() const {
  return this != internal_default_instance() && data_ != NULL;
}
inline void PlanManeuver::clear_data() {
  if (GetArenaNoVirtual() == NULL && data_ != NULL) {
    delete data_;
  }
  data_ = NULL;
}
inline const ::IMC_DCCL::Maneuver& PlanManeuver::_internal_data() const {
  return *data_;
}
inline const ::IMC_DCCL::Maneuver& PlanManeuver::data() const {
  const ::IMC_DCCL::Maneuver* p = data_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanManeuver.data)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::Maneuver*>(
      &::IMC_DCCL::_Maneuver_default_instance_);
}
inline ::IMC_DCCL::Maneuver* PlanManeuver::release_data() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanManeuver.data)
  
  ::IMC_DCCL::Maneuver* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::IMC_DCCL::Maneuver* PlanManeuver::mutable_data() {
  
  if (data_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::Maneuver>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanManeuver.data)
  return data_;
}
inline void PlanManeuver::set_allocated_data(::IMC_DCCL::Maneuver* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    
  } else {
    
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanManeuver.data)
}

// repeated .IMC_DCCL.EntityParameters start_actions = 3 [(.dccl.field) = {
inline int PlanManeuver::start_actions_size() const {
  return start_actions_.size();
}
inline void PlanManeuver::clear_start_actions() {
  start_actions_.Clear();
}
inline ::IMC_DCCL::EntityParameters* PlanManeuver::mutable_start_actions(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanManeuver.start_actions)
  return start_actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
PlanManeuver::mutable_start_actions() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanManeuver.start_actions)
  return &start_actions_;
}
inline const ::IMC_DCCL::EntityParameters& PlanManeuver::start_actions(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanManeuver.start_actions)
  return start_actions_.Get(index);
}
inline ::IMC_DCCL::EntityParameters* PlanManeuver::add_start_actions() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanManeuver.start_actions)
  return start_actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
PlanManeuver::start_actions() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanManeuver.start_actions)
  return start_actions_;
}

// -------------------------------------------------------------------

// PlanVariable

// string name = 1 [(.dccl.field) = {
inline void PlanVariable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlanVariable::name() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.name)
  return name_.GetNoArena();
}
inline void PlanVariable::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.name)
}
#if LANG_CXX11
inline void PlanVariable::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IMC_DCCL.PlanVariable.name)
}
#endif
inline void PlanVariable::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IMC_DCCL.PlanVariable.name)
}
inline void PlanVariable::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IMC_DCCL.PlanVariable.name)
}
inline ::std::string* PlanVariable::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanVariable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanVariable::release_name() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanVariable.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlanVariable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanVariable.name)
}

// string value = 2 [(.dccl.field) = {
inline void PlanVariable::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlanVariable::value() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.value)
  return value_.GetNoArena();
}
inline void PlanVariable::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.value)
}
#if LANG_CXX11
inline void PlanVariable::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IMC_DCCL.PlanVariable.value)
}
#endif
inline void PlanVariable::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IMC_DCCL.PlanVariable.value)
}
inline void PlanVariable::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IMC_DCCL.PlanVariable.value)
}
inline ::std::string* PlanVariable::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanVariable.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanVariable::release_value() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanVariable.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlanVariable::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanVariable.value)
}

// .IMC_DCCL.Type type = 3;
inline void PlanVariable::clear_type() {
  type_ = 0;
}
inline ::IMC_DCCL::Type PlanVariable::type() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.type)
  return static_cast< ::IMC_DCCL::Type >(type_);
}
inline void PlanVariable::set_type(::IMC_DCCL::Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.type)
}

// .IMC_DCCL.AccessType access = 4;
inline void PlanVariable::clear_access() {
  access_ = 0;
}
inline ::IMC_DCCL::AccessType PlanVariable::access() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanVariable.access)
  return static_cast< ::IMC_DCCL::AccessType >(access_);
}
inline void PlanVariable::set_access(::IMC_DCCL::AccessType value) {
  
  access_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanVariable.access)
}

// -------------------------------------------------------------------

// PlanTransition

// .IMC_DCCL.ManeuverID source_man = 1;
inline bool PlanTransition::has_source_man() const {
  return this != internal_default_instance() && source_man_ != NULL;
}
inline void PlanTransition::clear_source_man() {
  if (GetArenaNoVirtual() == NULL && source_man_ != NULL) {
    delete source_man_;
  }
  source_man_ = NULL;
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::_internal_source_man() const {
  return *source_man_;
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::source_man() const {
  const ::IMC_DCCL::ManeuverID* p = source_man_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanTransition.source_man)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::ManeuverID*>(
      &::IMC_DCCL::_ManeuverID_default_instance_);
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::release_source_man() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanTransition.source_man)
  
  ::IMC_DCCL::ManeuverID* temp = source_man_;
  source_man_ = NULL;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::mutable_source_man() {
  
  if (source_man_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaNoVirtual());
    source_man_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanTransition.source_man)
  return source_man_;
}
inline void PlanTransition::set_allocated_source_man(::IMC_DCCL::ManeuverID* source_man) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_man_;
  }
  if (source_man) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_man = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_man, submessage_arena);
    }
    
  } else {
    
  }
  source_man_ = source_man;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanTransition.source_man)
}

// .IMC_DCCL.ManeuverID dest_man = 2;
inline bool PlanTransition::has_dest_man() const {
  return this != internal_default_instance() && dest_man_ != NULL;
}
inline void PlanTransition::clear_dest_man() {
  if (GetArenaNoVirtual() == NULL && dest_man_ != NULL) {
    delete dest_man_;
  }
  dest_man_ = NULL;
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::_internal_dest_man() const {
  return *dest_man_;
}
inline const ::IMC_DCCL::ManeuverID& PlanTransition::dest_man() const {
  const ::IMC_DCCL::ManeuverID* p = dest_man_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanTransition.dest_man)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::ManeuverID*>(
      &::IMC_DCCL::_ManeuverID_default_instance_);
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::release_dest_man() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanTransition.dest_man)
  
  ::IMC_DCCL::ManeuverID* temp = dest_man_;
  dest_man_ = NULL;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanTransition::mutable_dest_man() {
  
  if (dest_man_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaNoVirtual());
    dest_man_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanTransition.dest_man)
  return dest_man_;
}
inline void PlanTransition::set_allocated_dest_man(::IMC_DCCL::ManeuverID* dest_man) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dest_man_;
  }
  if (dest_man) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dest_man = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dest_man, submessage_arena);
    }
    
  } else {
    
  }
  dest_man_ = dest_man;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanTransition.dest_man)
}

// .IMC_DCCL.TransitionCondition conditions = 3;
inline void PlanTransition::clear_conditions() {
  conditions_ = 0;
}
inline ::IMC_DCCL::TransitionCondition PlanTransition::conditions() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanTransition.conditions)
  return static_cast< ::IMC_DCCL::TransitionCondition >(conditions_);
}
inline void PlanTransition::set_conditions(::IMC_DCCL::TransitionCondition value) {
  
  conditions_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanTransition.conditions)
}

// -------------------------------------------------------------------

// Header

// int32 src = 1 [(.dccl.field) = {
inline void Header::clear_src() {
  src_ = 0;
}
inline ::google::protobuf::int32 Header::src() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.src)
  return src_;
}
inline void Header::set_src(::google::protobuf::int32 value) {
  
  src_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.src)
}

// int32 src_ent = 2 [(.dccl.field) = {
inline void Header::clear_src_ent() {
  src_ent_ = 0;
}
inline ::google::protobuf::int32 Header::src_ent() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.src_ent)
  return src_ent_;
}
inline void Header::set_src_ent(::google::protobuf::int32 value) {
  
  src_ent_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.src_ent)
}

// int32 dst = 3 [(.dccl.field) = {
inline void Header::clear_dst() {
  dst_ = 0;
}
inline ::google::protobuf::int32 Header::dst() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.dst)
  return dst_;
}
inline void Header::set_dst(::google::protobuf::int32 value) {
  
  dst_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.dst)
}

// int32 dst_ent = 4 [(.dccl.field) = {
inline void Header::clear_dst_ent() {
  dst_ent_ = 0;
}
inline ::google::protobuf::int32 Header::dst_ent() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.Header.dst_ent)
  return dst_ent_;
}
inline void Header::set_dst_ent(::google::protobuf::int32 value) {
  
  dst_ent_ = value;
  // @@protoc_insertion_point(field_set:IMC_DCCL.Header.dst_ent)
}

// -------------------------------------------------------------------

// PlanSpecification

// string plan_id = 1 [(.dccl.field) = {
inline void PlanSpecification::clear_plan_id() {
  plan_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlanSpecification::plan_id() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.plan_id)
  return plan_id_.GetNoArena();
}
inline void PlanSpecification::set_plan_id(const ::std::string& value) {
  
  plan_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanSpecification.plan_id)
}
#if LANG_CXX11
inline void PlanSpecification::set_plan_id(::std::string&& value) {
  
  plan_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IMC_DCCL.PlanSpecification.plan_id)
}
#endif
inline void PlanSpecification::set_plan_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  plan_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IMC_DCCL.PlanSpecification.plan_id)
}
inline void PlanSpecification::set_plan_id(const char* value, size_t size) {
  
  plan_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IMC_DCCL.PlanSpecification.plan_id)
}
inline ::std::string* PlanSpecification::mutable_plan_id() {
  
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.plan_id)
  return plan_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanSpecification::release_plan_id() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.plan_id)
  
  return plan_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlanSpecification::set_allocated_plan_id(::std::string* plan_id) {
  if (plan_id != NULL) {
    
  } else {
    
  }
  plan_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plan_id);
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.plan_id)
}

// string description = 2 [(.dccl.field) = {
inline void PlanSpecification::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlanSpecification::description() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.description)
  return description_.GetNoArena();
}
inline void PlanSpecification::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanSpecification.description)
}
#if LANG_CXX11
inline void PlanSpecification::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IMC_DCCL.PlanSpecification.description)
}
#endif
inline void PlanSpecification::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IMC_DCCL.PlanSpecification.description)
}
inline void PlanSpecification::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IMC_DCCL.PlanSpecification.description)
}
inline ::std::string* PlanSpecification::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanSpecification::release_description() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlanSpecification::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.description)
}

// string vnamespace = 3 [(.dccl.field) = {
inline void PlanSpecification::clear_vnamespace() {
  vnamespace_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PlanSpecification::vnamespace() const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.vnamespace)
  return vnamespace_.GetNoArena();
}
inline void PlanSpecification::set_vnamespace(const ::std::string& value) {
  
  vnamespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:IMC_DCCL.PlanSpecification.vnamespace)
}
#if LANG_CXX11
inline void PlanSpecification::set_vnamespace(::std::string&& value) {
  
  vnamespace_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:IMC_DCCL.PlanSpecification.vnamespace)
}
#endif
inline void PlanSpecification::set_vnamespace(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  vnamespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:IMC_DCCL.PlanSpecification.vnamespace)
}
inline void PlanSpecification::set_vnamespace(const char* value, size_t size) {
  
  vnamespace_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:IMC_DCCL.PlanSpecification.vnamespace)
}
inline ::std::string* PlanSpecification::mutable_vnamespace() {
  
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.vnamespace)
  return vnamespace_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PlanSpecification::release_vnamespace() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.vnamespace)
  
  return vnamespace_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PlanSpecification::set_allocated_vnamespace(::std::string* vnamespace) {
  if (vnamespace != NULL) {
    
  } else {
    
  }
  vnamespace_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vnamespace);
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.vnamespace)
}

// .IMC_DCCL.ManeuverID start_man_id = 4;
inline bool PlanSpecification::has_start_man_id() const {
  return this != internal_default_instance() && start_man_id_ != NULL;
}
inline void PlanSpecification::clear_start_man_id() {
  if (GetArenaNoVirtual() == NULL && start_man_id_ != NULL) {
    delete start_man_id_;
  }
  start_man_id_ = NULL;
}
inline const ::IMC_DCCL::ManeuverID& PlanSpecification::_internal_start_man_id() const {
  return *start_man_id_;
}
inline const ::IMC_DCCL::ManeuverID& PlanSpecification::start_man_id() const {
  const ::IMC_DCCL::ManeuverID* p = start_man_id_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.start_man_id)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::ManeuverID*>(
      &::IMC_DCCL::_ManeuverID_default_instance_);
}
inline ::IMC_DCCL::ManeuverID* PlanSpecification::release_start_man_id() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.start_man_id)
  
  ::IMC_DCCL::ManeuverID* temp = start_man_id_;
  start_man_id_ = NULL;
  return temp;
}
inline ::IMC_DCCL::ManeuverID* PlanSpecification::mutable_start_man_id() {
  
  if (start_man_id_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::ManeuverID>(GetArenaNoVirtual());
    start_man_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.start_man_id)
  return start_man_id_;
}
inline void PlanSpecification::set_allocated_start_man_id(::IMC_DCCL::ManeuverID* start_man_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete start_man_id_;
  }
  if (start_man_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start_man_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start_man_id, submessage_arena);
    }
    
  } else {
    
  }
  start_man_id_ = start_man_id;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.start_man_id)
}

// repeated .IMC_DCCL.PlanManeuver maneuvers = 5 [(.dccl.field) = {
inline int PlanSpecification::maneuvers_size() const {
  return maneuvers_.size();
}
inline void PlanSpecification::clear_maneuvers() {
  maneuvers_.Clear();
}
inline ::IMC_DCCL::PlanManeuver* PlanSpecification::mutable_maneuvers(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.maneuvers)
  return maneuvers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >*
PlanSpecification::mutable_maneuvers() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.maneuvers)
  return &maneuvers_;
}
inline const ::IMC_DCCL::PlanManeuver& PlanSpecification::maneuvers(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.maneuvers)
  return maneuvers_.Get(index);
}
inline ::IMC_DCCL::PlanManeuver* PlanSpecification::add_maneuvers() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.maneuvers)
  return maneuvers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanManeuver >&
PlanSpecification::maneuvers() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.maneuvers)
  return maneuvers_;
}

// repeated .IMC_DCCL.PlanTransition transitions = 6 [(.dccl.field) = {
inline int PlanSpecification::transitions_size() const {
  return transitions_.size();
}
inline void PlanSpecification::clear_transitions() {
  transitions_.Clear();
}
inline ::IMC_DCCL::PlanTransition* PlanSpecification::mutable_transitions(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.transitions)
  return transitions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanTransition >*
PlanSpecification::mutable_transitions() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.transitions)
  return &transitions_;
}
inline const ::IMC_DCCL::PlanTransition& PlanSpecification::transitions(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.transitions)
  return transitions_.Get(index);
}
inline ::IMC_DCCL::PlanTransition* PlanSpecification::add_transitions() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.transitions)
  return transitions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanTransition >&
PlanSpecification::transitions() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.transitions)
  return transitions_;
}

// repeated .IMC_DCCL.EntityParameters start_actions = 7 [(.dccl.field) = {
inline int PlanSpecification::start_actions_size() const {
  return start_actions_.size();
}
inline void PlanSpecification::clear_start_actions() {
  start_actions_.Clear();
}
inline ::IMC_DCCL::EntityParameters* PlanSpecification::mutable_start_actions(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.start_actions)
  return start_actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >*
PlanSpecification::mutable_start_actions() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.start_actions)
  return &start_actions_;
}
inline const ::IMC_DCCL::EntityParameters& PlanSpecification::start_actions(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.start_actions)
  return start_actions_.Get(index);
}
inline ::IMC_DCCL::EntityParameters* PlanSpecification::add_start_actions() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.start_actions)
  return start_actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::EntityParameters >&
PlanSpecification::start_actions() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.start_actions)
  return start_actions_;
}

// repeated .IMC_DCCL.PlanVariable variables = 8 [(.dccl.field) = {
inline int PlanSpecification::variables_size() const {
  return variables_.size();
}
inline void PlanSpecification::clear_variables() {
  variables_.Clear();
}
inline ::IMC_DCCL::PlanVariable* PlanSpecification::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.variables)
  return variables_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanVariable >*
PlanSpecification::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:IMC_DCCL.PlanSpecification.variables)
  return &variables_;
}
inline const ::IMC_DCCL::PlanVariable& PlanSpecification::variables(int index) const {
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.variables)
  return variables_.Get(index);
}
inline ::IMC_DCCL::PlanVariable* PlanSpecification::add_variables() {
  // @@protoc_insertion_point(field_add:IMC_DCCL.PlanSpecification.variables)
  return variables_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::IMC_DCCL::PlanVariable >&
PlanSpecification::variables() const {
  // @@protoc_insertion_point(field_list:IMC_DCCL.PlanSpecification.variables)
  return variables_;
}

// .IMC_DCCL.Header head = 9;
inline bool PlanSpecification::has_head() const {
  return this != internal_default_instance() && head_ != NULL;
}
inline void PlanSpecification::clear_head() {
  if (GetArenaNoVirtual() == NULL && head_ != NULL) {
    delete head_;
  }
  head_ = NULL;
}
inline const ::IMC_DCCL::Header& PlanSpecification::_internal_head() const {
  return *head_;
}
inline const ::IMC_DCCL::Header& PlanSpecification::head() const {
  const ::IMC_DCCL::Header* p = head_;
  // @@protoc_insertion_point(field_get:IMC_DCCL.PlanSpecification.head)
  return p != NULL ? *p : *reinterpret_cast<const ::IMC_DCCL::Header*>(
      &::IMC_DCCL::_Header_default_instance_);
}
inline ::IMC_DCCL::Header* PlanSpecification::release_head() {
  // @@protoc_insertion_point(field_release:IMC_DCCL.PlanSpecification.head)
  
  ::IMC_DCCL::Header* temp = head_;
  head_ = NULL;
  return temp;
}
inline ::IMC_DCCL::Header* PlanSpecification::mutable_head() {
  
  if (head_ == NULL) {
    auto* p = CreateMaybeMessage<::IMC_DCCL::Header>(GetArenaNoVirtual());
    head_ = p;
  }
  // @@protoc_insertion_point(field_mutable:IMC_DCCL.PlanSpecification.head)
  return head_;
}
inline void PlanSpecification::set_allocated_head(::IMC_DCCL::Header* head) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete head_;
  }
  if (head) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      head = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, head, submessage_arena);
    }
    
  } else {
    
  }
  head_ = head;
  // @@protoc_insertion_point(field_set_allocated:IMC_DCCL.PlanSpecification.head)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace IMC_DCCL

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::IMC_DCCL::ZUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ZUnits>() {
  return ::IMC_DCCL::ZUnits_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::SpeedUnits> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::SpeedUnits>() {
  return ::IMC_DCCL::SpeedUnits_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::LoiterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::LoiterType>() {
  return ::IMC_DCCL::LoiterType_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::DirectionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::DirectionType>() {
  return ::IMC_DCCL::DirectionType_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::ManeuverType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ManeuverType>() {
  return ::IMC_DCCL::ManeuverType_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::ParameterName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ParameterName>() {
  return ::IMC_DCCL::ParameterName_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::ParamValue> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::ParamValue>() {
  return ::IMC_DCCL::ParamValue_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::EntityName> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::EntityName>() {
  return ::IMC_DCCL::EntityName_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::TransitionCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::TransitionCondition>() {
  return ::IMC_DCCL::TransitionCondition_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::Type>() {
  return ::IMC_DCCL::Type_descriptor();
}
template <> struct is_proto_enum< ::IMC_DCCL::AccessType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::IMC_DCCL::AccessType>() {
  return ::IMC_DCCL::AccessType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_IMC_5fDCCL_2eproto
